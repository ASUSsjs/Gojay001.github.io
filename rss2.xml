<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>大迷毛|成长录</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>学习 思考 沉淀</description>
    <pubDate>Tue, 28 Nov 2017 06:52:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>跟我学Shiro（四）-INI配置</title>
      <link>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/</link>
      <guid>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Tue, 28 Nov 2017 06:42:36 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;SecurityManager&quot;&gt;&lt;a href=&quot;#SecurityManager&quot; class=&quot;headerlink&quot; title=&quot;SecurityManager&quot;&gt;&lt;/a&gt;SecurityManager&lt;/h1&gt;&lt;p&gt;Shiro是从根对象 &lt;code&gt;SecurityManager&lt;/code&gt; 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 &lt;code&gt;SecurityUtils&lt;/code&gt; 让我们绑定它为&lt;code&gt;全局&lt;/code&gt;的，方便后续操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。&lt;br&gt;但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。&lt;br&gt;Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h1><p>Shiro是从根对象 <code>SecurityManager</code> 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 <code>SecurityUtils</code> 让我们绑定它为<code>全局</code>的，方便后续操作。</p><blockquote><p>因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。<br>但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。<br>Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。</p></blockquote><a id="more"></a><h2 id="纯Java代码写法"><a href="#纯Java代码写法" class="headerlink" title="纯Java代码写法"></a>纯Java代码写法</h2><blockquote><p>com.github.gojay001.test.NonConfigurationCreateTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DefaultSecurityManager securityManager = new DefaultSecurityManager();</div><div class="line"></div><div class="line">//设置authenticator</div><div class="line">ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();</div><div class="line">authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());</div><div class="line">securityManager.setAuthenticator(authenticator);</div><div class="line"></div><div class="line">//设置authorizer</div><div class="line">ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();</div><div class="line">authorizer.setPermissionResolver(new WildcardPermissionResolver());</div><div class="line">securityManager.setAuthorizer(authorizer);</div><div class="line"></div><div class="line">//设置Realm</div><div class="line">DruidDataSource ds = new DruidDataSource();</div><div class="line">ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</div><div class="line">ds.setUrl(&quot;jdbc:mysql://localhost:3306/shiro&quot;);</div><div class="line">ds.setUsername(&quot;root&quot;);</div><div class="line">ds.setPassword(&quot;root&quot;);</div><div class="line"></div><div class="line">JdbcRealm jdbcRealm = new JdbcRealm();</div><div class="line">jdbcRealm.setDataSource(ds);</div><div class="line">jdbcRealm.setPermissionsLookupEnabled(true);</div><div class="line">securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure><h2 id="等价的INI配置"><a href="#等价的INI配置" class="headerlink" title="等价的INI配置"></a>等价的INI配置</h2><h3 id="shiro-config-ini："><a href="#shiro-config-ini：" class="headerlink" title="shiro-config.ini："></a>shiro-config.ini：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#覆盖默认的securityManager</div><div class="line">#securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div><div class="line"></div><div class="line">#authenticator</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy</div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#realm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line"></div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><blockquote><p><code>对象名=全限定类名</code>  相对于调用public无参构造器创建对象<br><code>对象名.属性名=值</code>    相当于调用setter方法设置常量值<br><code>对象名.属性名=$对象引用</code>    相当于调用setter方法设置对象引用</p></blockquote><h3 id="com-github-gojay001-test-ConfigurationCreateTest："><a href="#com-github-gojay001-test-ConfigurationCreateTest：" class="headerlink" title="com.github.gojay001.test.ConfigurationCreateTest："></a>com.github.gojay001.test.ConfigurationCreateTest：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Factory&lt;SecurityManager&gt; factory =</div><div class="line">    new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;);</div><div class="line"></div><div class="line">SecurityManager securityManager = factory.getInstance();</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure><blockquote><p>如上代码是从Shiro <code>INI配置</code>中获取相应的<code>securityManager</code>实例：  </p><ol><li>默认情况先创建一个名字为 <code>securityManager</code> ，类型为 <code>org.apache.shiro.mgt.DefaultSecurityManager</code> 的默认的 <code>SecurityManager</code> ，如果想<code>自定义</code>，只需要在ini配置文件中指定“securityManager=SecurityManager实现类”即可，名字必须为securityManager，它是起始的根；  </li><li><code>IniSecurityManagerFactory</code> 是创建 <code>securityManager</code> 的工厂，其需要一个ini配置文件路径，其支持<code>classpath:</code>（类路径）、<code>file:</code>（文件系统）、<code>url:</code>（网络）三种路径格式，默认是<code>文件系统</code>；  </li><li>接着获取<code>SecuriyManager实例</code>，后续步骤和之前的一样。</li></ol></blockquote><p>如上可以看出Shiro INI配置方式本身提供了一个简单的<code>IoC/DI机制</code>方便在配置文件配置，但是是从 <code>securityManager</code> 这个根对象开始导航。</p><h1 id="INI配置"><a href="#INI配置" class="headerlink" title="INI配置"></a>INI配置</h1><p><code>ini配置文件</code>类似于Java中的 <code>properties（key=value）</code> ，不过提供了将key/value分类的特性，key是每个部分不重复即可，而不是整个配置文件。如下是INI配置分类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">#提供了对根对象securityManager及其依赖的配置  </div><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager  </div><div class="line">…………  </div><div class="line">securityManager.realms=$jdbcRealm  </div><div class="line">  </div><div class="line">[users]  </div><div class="line">#提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2  </div><div class="line">username=password,role1,role2  </div><div class="line">  </div><div class="line">[roles]  </div><div class="line">#提供了角色及权限之间关系的配置，角色=权限1，权限2  </div><div class="line">role1=permission1,permission2  </div><div class="line">  </div><div class="line">[urls]  </div><div class="line">#用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器  </div><div class="line">/index.html = anon  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p><h2 id="main-部分"><a href="#main-部分" class="headerlink" title="[main]部分"></a>[main]部分</h2><p>提供了对根对象 <strong>securityManager</strong> 及其依赖对象的配置。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div></pre></td></tr></table></figure><p>其构造器必须是<code>public空参构造器</code>，通过反射创建相应的实例。</p><h3 id="常量值setter注入"><a href="#常量值setter注入" class="headerlink" title="常量值setter注入"></a>常量值setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div></pre></td></tr></table></figure><p>会自动调用 <code>jdbcRealm.setPermissionsLookupEnabled(true)</code> ，对于这种常量值会自动类型转换。</p><h3 id="对象引用setter注入"><a href="#对象引用setter注入" class="headerlink" title="对象引用setter注入"></a>对象引用setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator  </div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy  </div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy  </div><div class="line">securityManager.authenticator=$authenticator</div></pre></td></tr></table></figure><p>会自动通过 <code>securityManager.setAuthenticator(authenticator)</code> 注入引用依赖。</p><h3 id="嵌套属性setter注入"><a href="#嵌套属性setter注入" class="headerlink" title="嵌套属性setter注入"></a>嵌套属性setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager.authenticator.authenticationStrategy=$authenticationStrategy</div></pre></td></tr></table></figure><p>支持这种嵌套方式的setter注入。</p><h3 id="byte数组setter注入"><a href="#byte数组setter注入" class="headerlink" title="byte数组setter注入"></a>byte数组setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#base64 byte[]  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">#hex byte[]  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure><p>默认需要使用Base64进行编码，也可以使用0x十六进制。</p><h3 id="Array-Set-List-setter注入"><a href="#Array-Set-List-setter注入" class="headerlink" title="Array/Set/List setter注入"></a>Array/Set/List setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authenticator.array=1,2,3  </div><div class="line">authenticator.set=$jdbcRealm,$jdbcRealm</div></pre></td></tr></table></figure><p>多个之间通过“，”分割。</p><h3 id="Map-setter注入"><a href="#Map-setter注入" class="headerlink" title="Map setter注入"></a>Map setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc</div></pre></td></tr></table></figure><p>格式是： <code>map=key：value，key：value</code> ，可以注入常量及引用值，常量的话都看作字符串（即使有泛型也不会自动造型）。  </p><h3 id="实例化-注入顺序"><a href="#实例化-注入顺序" class="headerlink" title="实例化/注入顺序"></a>实例化/注入顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">realm=Realm1  </div><div class="line">realm=Realm12  </div><div class="line">  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure><p>后边的<code>覆盖</code>前边的注入。</p><h2 id="users-部分"><a href="#users-部分" class="headerlink" title="[users]部分"></a>[users]部分</h2><p>配置用户名/密码及其角色，格式：<code>用户名=密码，角色1，角色2</code>，角色部分可省略。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test</div></pre></td></tr></table></figure></p><p>密码一般生成其摘要/加密存储。</p><h2 id="roles-部分"><a href="#roles-部分" class="headerlink" title="[roles]部分"></a>[roles]部分</h2><p>配置角色及权限之间的关系，格式：<code>角色=权限1，权限2</code>；如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[roles]  </div><div class="line">role1=user:create,user:update  </div><div class="line">role2=*</div></pre></td></tr></table></figure></p><p>如果只有角色没有对应的权限，可以不配roles。</p><h2 id="urls-部分"><a href="#urls-部分" class="headerlink" title="[urls]部分"></a>[urls]部分</h2><p>配置url及相应的拦截器之间的关系，格式：<code>url=拦截器[参数]，拦截器[参数]</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[urls]  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（三）-授权</title>
      <link>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/</link>
      <guid>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/</guid>
      <pubDate>Thu, 23 Nov 2017 09:06:29 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：&lt;code&gt;主体&lt;/code&gt;（Subject）、&lt;code&gt;资源&lt;/code&gt;（Resource）、&lt;code&gt;权限&lt;/code&gt;（Permission）、&lt;code&gt;角色&lt;/code&gt;（Role）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主体&lt;/strong&gt;：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源&lt;/strong&gt;：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权限&lt;/strong&gt;：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;角色&lt;/strong&gt;：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式角色&lt;/strong&gt;：即直接通过角色来验证用户有没有操作权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显式角色&lt;/strong&gt;：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;了解更多&lt;/strong&gt;：搜索&lt;code&gt;“RBAC”&lt;/code&gt;和&lt;code&gt;“RBAC新解”&lt;/code&gt;分别了解&lt;code&gt;“基于角色的访问控制”&lt;/code&gt;和&lt;code&gt;“基于资源的访问控制”&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>授权</strong>：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：<code>主体</code>（Subject）、<code>资源</code>（Resource）、<code>权限</code>（Permission）、<code>角色</code>（Role）。</p><ul><li><strong>主体</strong>：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</li><li><strong>资源</strong>：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</li><li><strong>权限</strong>：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。</li><li><strong>角色</strong>：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</li><li><strong>隐式角色</strong>：即直接通过角色来验证用户有没有操作权限。</li><li><strong>显式角色</strong>：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。</li></ul><blockquote><p><strong>了解更多</strong>：搜索<code>“RBAC”</code>和<code>“RBAC新解”</code>分别了解<code>“基于角色的访问控制”</code>和<code>“基于资源的访问控制”</code>。</p></blockquote><a id="more"></a><h1 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h1><blockquote><p>Shiro支持三种方式的授权。</p></blockquote><h2 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h2><p>通过写if/else授权代码块完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Subject subject = SecurityUtils.getSubject();  </div><div class="line">if(subject.hasRole(“admin”)) &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125; else &#123;  </div><div class="line">    //无权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h2><p>通过在执行的Java方法上放置相应的注解完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequiresRoles(&quot;admin&quot;)  </div><div class="line">public void hello() &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>没有权限将抛出相应的异常。</p><h2 id="JSP-GSP标签"><a href="#JSP-GSP标签" class="headerlink" title="JSP/GSP标签"></a>JSP/GSP标签</h2><p>在JSP/GSP页面通过相应的标签完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;  </div><div class="line">&lt;!— 有权限 —&gt;  </div><div class="line">&lt;/shiro:hasRole&gt;</div></pre></td></tr></table></figure></p><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色"><a href="#在ini配置文件配置用户拥有的角色" class="headerlink" title="在ini配置文件配置用户拥有的角色"></a>在ini配置文件配置用户拥有的角色</h3><blockquote><p>shiro-role.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div></pre></td></tr></table></figure><blockquote><p><strong>规则</strong>：<code>“用户名=密码,角色1，角色2”</code>，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息；也就是说<code>Shiro不负责维护用户-角色信息</code>，需要应用提供，Shiro只是提供相应的接口方便验证。</p></blockquote><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote><p>com.github.gojay001.test.RoleTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testHasRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有角色：role1</div><div class="line">    Assert.assertTrue(subject().hasRole(&quot;role1&quot;));</div><div class="line">    // 判断拥有角色：role1 and role2</div><div class="line">    Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));</div><div class="line">    // 判断拥有角色：role1 and role2 and !role3</div><div class="line">    boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));</div><div class="line">    Assert.assertEquals(true, result[0]);</div><div class="line">    Assert.assertEquals(true, result[1]);</div><div class="line">    Assert.assertEquals(false, result[2]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供了<code>hasRole/hasAllRoles</code>用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有角色：role1</div><div class="line">    subject().checkRole(&quot;role1&quot;);</div><div class="line">    // 断言拥有角色：role1 and role3 失败抛出异常</div><div class="line">    subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供的<code>checkRole/checkRoles</code>和<code>hasRole/hasAllRoles</code>不同的地方是它在判断为假的情况下会<code>抛出UnauthorizedException异常</code>。</p></blockquote><p><strong>基于角色的访问控制</strong>（即隐式角色）的缺点：如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把<code>所有相关的地方</code>进行删除；这就是粗粒度造成的问题。</p><h2 id="基于资源的访问控制（显式角色）"><a href="#基于资源的访问控制（显式角色）" class="headerlink" title="基于资源的访问控制（显式角色）"></a>基于资源的访问控制（显式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色及角色-权限关系"><a href="#在ini配置文件配置用户拥有的角色及角色-权限关系" class="headerlink" title="在ini配置文件配置用户拥有的角色及角色-权限关系"></a>在ini配置文件配置用户拥有的角色及角色-权限关系</h3><blockquote><p>shiro-permission.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div><div class="line">[roles]</div><div class="line">role1=user:create,user:update</div><div class="line">role2=user:create,user:delete</div></pre></td></tr></table></figure><blockquote><p><strong>规则</strong>：<code>“用户名=密码，角色1，角色2”“角色=权限1，权限2”</code>，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。</p></blockquote><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote><p>com.github.gojay001.test.PermissionTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));</div><div class="line">    // 判断拥有权限：user:update and user:delete</div><div class="line">    Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;));</div><div class="line">    // 判断没有权限：user:view</div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供了<code>isPermitted</code>和<code>isPermittedAll</code>用于判断用户是否拥有某个权限或所有权限，也<code>没有提供如isPermittedAny</code>用于判断拥有某一个权限的接口。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckPermission() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有权限：user:create</div><div class="line">    subject().checkPermission(&quot;user:create&quot;);</div><div class="line">    // 断言拥有权限：user:delete and user:update</div><div class="line">    subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);</div><div class="line">    // 断言拥有权限：user:view 失败抛出异常</div><div class="line">    subject().checkPermissions(&quot;user:view&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>checkPermissions</code>失败的情况下会抛出UnauthorizedException异常。</p></blockquote><p><strong>基于资源的访问控制</strong>（显式角色），也可以叫基于权限的访问控制，这种方式的一般规则是<code>“资源标识符：操作”</code>，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。 </p><h1 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h1><p><strong>字符串通配符权限</strong><br><strong>规则</strong>：<code>“资源标识符：操作：对象实例ID”</code>  即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>“:”</code>表示资源/操作/实例的分割；<code>“,”</code>表示操作的分割；<code>“*”</code>表示任意资源/操作/实例。</p><h2 id="单个资源单个权限"><a href="#单个资源单个权限" class="headerlink" title="单个资源单个权限"></a>单个资源单个权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;);</div></pre></td></tr></table></figure><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>权限。</p></blockquote><h2 id="单个资源多个权限"><a href="#单个资源多个权限" class="headerlink" title="单个资源多个权限"></a>单个资源多个权限</h2><p>ini配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role41=system:user:update,system:user:delete</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);</div></pre></td></tr></table></figure></p><p>可以简写为：<code>&quot;system:user:update,delete&quot;</code></p><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>和<code>“delete”</code>权限。</p></blockquote><h2 id="单个资源全部权限"><a href="#单个资源全部权限" class="headerlink" title="单个资源全部权限"></a>单个资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role51=&quot;system:user:create,update,delete,view&quot;</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;);</div></pre></td></tr></table></figure></p><p>可以简写为：<code>system:user:*</code></p><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“create”</code>、<code>“update”</code>、<code>“delete”</code>和<code>“view”</code>所有权限。</p></blockquote><h2 id="所有资源全部权限"><a href="#所有资源全部权限" class="headerlink" title="所有资源全部权限"></a>所有资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role61=*:view</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>用户拥有所有资源的<code>“view”</code>所有权限。</p></blockquote><h2 id="实例级别的权限"><a href="#实例级别的权限" class="headerlink" title="实例级别的权限"></a>实例级别的权限</h2><h3 id="单个实例单个权限"><a href="#单个实例单个权限" class="headerlink" title="单个实例单个权限"></a>单个实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role71=user:view:1</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有view权限。</p></blockquote><h3 id="单个实例多个权限"><a href="#单个实例多个权限" class="headerlink" title="单个实例多个权限"></a>单个实例多个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role72=&quot;user:update,delete:1&quot;</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:delete,update:1&quot;);  </div><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有update、delete权限。</p></blockquote><h3 id="单个实例所有权限"><a href="#单个实例所有权限" class="headerlink" title="单个实例所有权限"></a>单个实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role73=user:*:1</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h3 id="所有实例单个权限"><a href="#所有实例单个权限" class="headerlink" title="所有实例单个权限"></a>所有实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role74=user:auth:*</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h3 id="所有实例所有权限"><a href="#所有实例所有权限" class="headerlink" title="所有实例所有权限"></a>所有实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role75=user:*:*</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h2 id="Shiro对权限字符串缺失部分的处理"><a href="#Shiro对权限字符串缺失部分的处理" class="headerlink" title="Shiro对权限字符串缺失部分的处理"></a>Shiro对权限字符串缺失部分的处理</h2><ul><li>如<code>user:view</code> 等价于 <code>user:view:*</code>；<br><code>organization</code> 等价于 <code>organization:*</code> 或者 <code>organization:*:*</code>。<br>可以这么理解，这种方式实现了<strong>前缀匹配</strong>。</li><li>如<code>user:*</code> 可以匹配 <code>user:delete</code>；<br><code>user:delete</code> 可以匹配 <code>user:delete:1</code>；<br><code>user:*:1</code> 可以匹配 <code>user:view:1</code>；<br><code>user</code> 可以匹配 <code>user:view</code> 或 <code>user:view:1</code>等。<br>即*可以匹配所有，不加*可以进行前缀匹配；</li><li>如<code>*:view</code> 不能匹配 <code>system:user:view</code>；需要使用 <code>*:*:view</code>；<br>即<strong>后缀匹配</strong>必须指定前缀（多个冒号就需要多个*来匹配）。</li></ul><h2 id="WildcardPermission"><a href="#WildcardPermission" class="headerlink" title="WildcardPermission"></a>WildcardPermission</h2><p>如下两种方式是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermission(&quot;menu:view:1&quot;);  </div><div class="line">subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;));</div></pre></td></tr></table></figure></p><blockquote><p>因此没什么必要的话使用字符串更方便。</p></blockquote><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p><code>通配符匹配</code>方式比<code>字符串匹配</code>来说是更复杂的，因此需要花费更长时间，但是一般系统的权限不会太多，且可以配合缓存来提供其性能，如果这样性能还达不到要求我们可以实现位操作算法实现性能更好的权限匹配。另外实例级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如在sql查询时加上权限字符串之类的方式在查询时就完成了权限匹配。</p><h1 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h1><p><img src="/2017/11/23/跟我学Shiro（三）-授权/3-1.png" alt="跟我学Shiro（三）-授权/3-1.png"></p><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote><ol><li>首先调用<code>Subject.isPermitted*/hasRole*</code>接口，其会委托给SecurityManager，而<code>SecurityManager</code>接着会委托给<code>Authorizer</code>；</li><li><code>Authorizer</code>是真正的授权者；如果我们调用如<code>isPermitted(“user:view”)</code>，其首先会通过<code>PermissionResolver</code>把字符串转换成相应的<code>Permission实例</code>；</li><li>在进行授权之前，其会<code>调用相应的Realm</code>获取Subject相应的<code>角色/权限</code>用于匹配传入的角色/权限；</li><li><code>Authorizer</code>会<code>判断</code>Realm的角色/权限是否和传入的<code>匹配</code>，如果有<code>多个Realm</code>，会委托给<code>ModularRealmAuthorizer</code>进行循环判断，如果匹配如isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</li></ol></blockquote><ul><li>ModularRealmAuthorizer进行多Realm匹配流程：</li></ul><blockquote><ol><li>首先检查相应的<code>Realm</code>是否实现了<code>Authorizer</code>；</li><li>如果实现了Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*接口</code>进行匹配；</li><li>如果有一个<code>Realm匹配</code>那么将返回true，否则返回false。</li></ol></blockquote><ul><li>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：</li></ul><blockquote><ol><li>如果调用<code>hasRole*</code>，则直接获取<code>AuthorizationInfo.getRoles()</code>与传入的角色比较即可；</li><li>如果调用如<code>isPermitted(“user:view”)</code>，首先通过<code>PermissionResolver</code>将权限字符串转换成相应的<code>Permission实例</code>，默认使用<code>WildcardPermissionResolver</code>，即转换为通配符的<code>WildcardPermission</code>；</li><li>通过<code>AuthorizationInfo.getObjectPermissions()</code>得到<code>Permission实例集合</code>；通过<code>AuthorizationInfo. getStringPermissions()</code>得到字符串集合并通过PermissionResolver解析为<code>Permission实例</code>；然后获取用户的角色，并通过<code>RolePermissionResolver</code>解析角色对应的<code>权限集合</code>（默认没有实现，可以自己提供）；</li><li>接着调用<code>Permission. implies(Permission p)</code>逐个与传入的权限比较，如果有<code>匹配</code>的则返回true，否则false。</li></ol></blockquote><h1 id="Authorizer"><a href="#Authorizer" class="headerlink" title="Authorizer"></a>Authorizer</h1><p><strong>Authorizer</strong>的职责是进行授权（访问控制），提供了相应的角色/权限判断接口。<code>SecurityManager</code>继承了<code>Authorizer接口</code>，且提供了<code>ModularRealmAuthorizer</code>用于多Realm时的授权匹配。<br><strong>PermissionResolver</strong>用于解析权限字符串到Permission实例。<br><strong>RolePermissionResolver</strong>用于根据角色解析相应的权限集合。</p><ul><li><p>可以通过如下ini配置更改<code>Authorizer</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer  </div><div class="line">securityManager.authorizer=$authorizer</div></pre></td></tr></table></figure></li><li><p>设置<code>ModularRealmAuthorizer</code>的<code>permissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>PermissionResolverAware</code>接口），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver  </div><div class="line">authorizer.permissionResolver=$permissionResolver</div></pre></td></tr></table></figure></li><li><p>设置<code>ModularRealmAuthorizer</code>的<code>rolePermissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>RolePermissionResolverAware</code>接口），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver  </div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote><p>shiro-jdbc-authorizer.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#自定义authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">#自定义permissionResolver</div><div class="line">#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">permissionResolver=com.github.gojay001.permission.BitAndWildPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">#自定义rolePermissionResolver</div><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver</div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div><div class="line"></div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#自定义realm 一定要放在securityManager.authorizer赋值之后</div><div class="line">#因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver</div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><blockquote><p>不能使用<code>IniSecurityManagerFactory</code>创建的<code>IniRealm</code>，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。</p></blockquote><h3 id="定义BitAndWildPermissionResolver及BitPermission"><a href="#定义BitAndWildPermissionResolver及BitPermission" class="headerlink" title="定义BitAndWildPermissionResolver及BitPermission"></a>定义BitAndWildPermissionResolver及BitPermission</h3><blockquote><p><strong>BitPermission</strong>用于实现位移方式的权限，如规则是：<br>权限字符串格式：<code>+资源字符串+权限位+实例ID</code>；以+开头中间通过+分割；权限：<code>0 表示所有权限</code>；<code>1 新增</code>（二进制：0001）、<code>2 修改</code>（二进制：0010）、<code>4 删除</code>（二进制：0100）、<code>8 查看</code>（二进制：1000）；如 <code>+user+10</code> 表示对资源user拥有<code>修改/查看</code>权限。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class BitPermission implements Permission &#123;</div><div class="line">    private String resourceIdentify;</div><div class="line">    private int permissionBit;</div><div class="line">    private String instanceId;</div><div class="line"></div><div class="line">    public BitPermission(String permissionString) &#123;</div><div class="line">        String[] array = permissionString.split(&quot;\\+&quot;);</div><div class="line"></div><div class="line">        if (array.length &gt; 1) &#123;</div><div class="line">            resourceIdentify = array[1];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(resourceIdentify)) &#123;</div><div class="line">            resourceIdentify = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 2) &#123;</div><div class="line">            permissionBit = Integer.valueOf(array[2]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 3) &#123;</div><div class="line">            instanceId = array[3];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(instanceId)) &#123;</div><div class="line">            instanceId = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean implies(Permission permission) &#123;</div><div class="line">        if(!(permission instanceof BitPermission)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        BitPermission other = (BitPermission) permission;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;BitPermission&#123;&quot; +</div><div class="line">                &quot;resourceIdentify=&apos;&quot; + resourceIdentify + &apos;\&apos;&apos; +</div><div class="line">                &quot;, permissionBit=&quot; + permissionBit +</div><div class="line">                &quot;, instanceId=&apos;&quot; + instanceId + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Permission接口</strong>提供了<code>boolean implies(Permission p)方法</code>用于判断权限匹配的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BitAndWildPermissionResolver implements PermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Permission resolvePermission(String permissionString) &#123;  </div><div class="line">        if(permissionString.startsWith(&quot;+&quot;)) &#123;  </div><div class="line">            return new BitPermission(permissionString);  </div><div class="line">        &#125;  </div><div class="line">        return new WildcardPermission(permissionString);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>BitAndWildPermissionResolver</strong>实现了<code>PermissionResolver接口</code>，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。</p><h3 id="定义MyRolePermissionResolver"><a href="#定义MyRolePermissionResolver" class="headerlink" title="定义MyRolePermissionResolver"></a>定义MyRolePermissionResolver</h3><p><strong>RolePermissionResolver</strong>用于根据角色字符串来解析得到权限集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MyRolePermissionResolver implements RolePermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123;  </div><div class="line">        if(&quot;role1&quot;.equals(roleString)) &#123;  </div><div class="line">            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><p>使用<strong>JdbcRealm</strong>，需要做的操作如下：</p><ul><li>执行<code>sql/shiro-init-data.sql</code> 插入相关的权限数据；</li><li>使用<code>shiro-jdbc-authorizer.ini配置文件</code>，需要<code>设置jdbcRealm.permissionsLookupEnabled为true</code>来开启权限查询。</li></ul><blockquote><p>这里也可以自定义实现Realm，可参考com.github.gojay001.realm.MyRealm</p></blockquote><h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted2() &#123;</div><div class="line">    login(&quot;classpath:shiro-jdbc-authorizer.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;));</div><div class="line">    // 通过二进制位的方式表示权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));// 新增权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));// 查看权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));// 新增及查看</div><div class="line"></div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));// 没有删除权限</div><div class="line"></div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));// 通过MyRolePermissionResolver解析得到的权限</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="授权流程-1"><a href="#授权流程-1" class="headerlink" title="授权流程"></a>授权流程</h2><ul><li>Subject.isPermitted*/hasRole*</li><li>SecurityManager</li><li>Authorizer</li><li>PermissionResolver/RolePermissionResolver/Permission</li><li>Realm</li></ul><h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><ul><li>user</li><li>role</li><li>permission</li></ul><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul><li>Authorizer</li><li>PermissionResolver</li><li>RolePermissionResolver</li><li>Realm</li></ul><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><ul><li>hasRole/hasAllRoles</li><li>checkRole/checkRoles</li><li>isPermitted/isPermittedAll</li><li>checkPermission/checkPermissions</li></ul><blockquote><p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（二）-身份认证</title>
      <link>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <guid>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <pubDate>Wed, 22 Nov 2017 06:22:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;身份验证&lt;/strong&gt;：在应用中能&lt;code&gt;证明他就是他本人&lt;/code&gt;。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。&lt;br&gt;在 shiro 中，用户需要提供 &lt;code&gt;principals&lt;/code&gt; （身份）和 &lt;code&gt;credentials&lt;/code&gt;（证明）给 shiro，从而应用能验证用户身份。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;principals&lt;/strong&gt;：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但&lt;code&gt;只有一个 Primary principals&lt;/code&gt;，一般是用户名/密码/手机号。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;credentials&lt;/strong&gt;：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的 principals 和 credentials 组合就是&lt;code&gt;用户名/密码&lt;/code&gt;了。&lt;br&gt;另外两个相关的概念是之前提到的 &lt;code&gt;Subject&lt;/code&gt; 及 &lt;code&gt;Realm&lt;/code&gt;，分别是主体及验证主体的数据源。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>身份验证</strong>：在应用中能<code>证明他就是他本人</code>。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>在 shiro 中，用户需要提供 <code>principals</code> （身份）和 <code>credentials</code>（证明）给 shiro，从而应用能验证用户身份。  </p><ul><li><strong>principals</strong>：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但<code>只有一个 Primary principals</code>，一般是用户名/密码/手机号。 </li><li><strong>credentials</strong>：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   </li></ul><blockquote><p>最常见的 principals 和 credentials 组合就是<code>用户名/密码</code>了。<br>另外两个相关的概念是之前提到的 <code>Subject</code> 及 <code>Realm</code>，分别是主体及验证主体的数据源。</p></blockquote><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="使用Maven构建"><a href="#使用Maven构建" class="headerlink" title="使用Maven构建"></a>使用Maven构建</h2><p>准备环境依赖：添加 <code>junit</code>、<code>common-logging</code> 及 <code>shiro-core</code> 依赖；</p><blockquote><p><strong>更新</strong>：加入slf4j-nop依赖包。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">        &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.7.25&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure><h1 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h1><h2 id="准备一些用户身份-凭据"><a href="#准备一些用户身份-凭据" class="headerlink" title="准备一些用户身份/凭据"></a>准备一些用户身份/凭据</h2><blockquote><p>shiro.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">gojay=test</div><div class="line">root=root</div></pre></td></tr></table></figure><p>此处使用ini配置文件，通过<code>[user]</code>指定两个主体。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><blockquote><p>com.github.gojay001.test.LoginLogoutTest<br><strong>更新</strong>：注意类过时。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testLoginLogout() &#123;</div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</div><div class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line"></div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils</div><div class="line">    SecurityManager securityManager = factory.getInstance();</div><div class="line">    SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //4、登录，即身份验证</div><div class="line">        subject.login(token);</div><div class="line">    &#125; catch (AuthenticationException e) &#123;</div><div class="line">        //5、身份验证失败</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Assert.assertEquals(true, subject.isAuthenticated());</div><div class="line"></div><div class="line">    //6、退出</div><div class="line">    subject.logout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>首先通过new IniSecurityManagerFactory并指定一个ini配置文件来<code>创建一个SecurityManager工厂</code>；</li><li>接着<code>获取SecurityManager并绑定到SecurityUtils</code>，这是一个全局设置，设置一次即可；</li><li>通过SecurityUtils<code>得到Subject</code>，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后<code>获取身份验证的Token</code>，如用户名/密码；</li><li><code>调用subject.login方法</code>进行登录，其会自动委托给SecurityManager.login方法进行登录；</li><li><code>如果身份验证失败捕获AuthenticationException或其子类</code>，常见的如： <code>DisabledAccountException</code>（禁用的帐号）、<code>LockedAccountException</code>（锁定的帐号）、<code>UnknownAccountException</code>（错误的帐号）、<code>ExcessiveAttemptsException</code>（登录失败次数过多）、<code>IncorrectCredentialsException</code> （错误的凭证）、<code>ExpiredCredentialsException</code>（过期的凭证）等，具体查看其继承关系；</li><li>最后可以<code>调用subject.logout退出</code>，其会自动委托给SecurityManager.logout方法退出。</li></ul><h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><blockquote><ol><li>收集用户身份/凭证，即如用户名/密码；</li><li>调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</li><li>最后调用Subject.logout进行退出操作。</li></ol></blockquote><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><blockquote><ol><li><code>用户名/密码硬编码</code>在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；</li><li><code>用户身份Token</code>可能不仅仅是用户名/密码，也可能<code>还有其他的</code>，如登录时允许用户名/邮箱/手机号同时登录。 </li></ol></blockquote><h1 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h1><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-1.png" alt="跟我学Shiro（二）-身份认证/2-1.png"></p><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote><ol><li>首先<code>调用Subject.login(token)</code>进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li><li><code>SecurityManager</code>负责真正的身份验证逻辑；它会<code>委托给Authenticator进行身份验证</code>；</li><li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处<code>可以自定义插入自己的实现</code>；</li><li>Authenticator可能会委托给相应的AuthenticationStrategy<code>进行多Realm身份验证</code>，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li><li>Authenticator会<code>把相应的token传入Realm，从Realm获取身份验证信息</code>，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li></ol></blockquote><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><strong>Realm</strong>：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即<code>安全数据源</code>。</p><p>org.apache.shiro.realm.Realm接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String getName(); //返回一个唯一的Realm名字  </div><div class="line">boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  </div><div class="line">AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;  //根据Token获取认证信息</div></pre></td></tr></table></figure></p><h2 id="单Realm配置"><a href="#单Realm配置" class="headerlink" title="单Realm配置"></a>单Realm配置</h2><h3 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h3><blockquote><p>com.github.gojay001.realm.MyRealm1</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> public class MyRealm1 implements Realm &#123;</div><div class="line">    public String getName() &#123;</div><div class="line">        return &quot;myRealm1&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</div><div class="line">        return authenticationToken instanceof UsernamePasswordToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</div><div class="line">        // 得到用户名</div><div class="line">        String username = (String)authenticationToken.getPrincipal();</div><div class="line">        // 得到密码</div><div class="line">        String password = new String((char[])authenticationToken.getCredentials());</div><div class="line">        if(!&quot;root&quot;.equals(username)) &#123;</div><div class="line">            //用户名错误</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line">        if(!&quot;root&quot;.equals(password)) &#123;</div><div class="line">            //密码错误</div><div class="line">            throw new IncorrectCredentialsException();</div><div class="line">        &#125;</div><div class="line">        //如果身份认证验证成功，返回一个AuthenticationInfo实现；</div><div class="line">        return new SimpleAuthenticationInfo(username, password, getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="ini配置文件指定自定义Realm实现"><a href="#ini配置文件指定自定义Realm实现" class="headerlink" title="ini配置文件指定自定义Realm实现"></a>ini配置文件指定自定义Realm实现</h3><blockquote><p>shiro-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#声明一个realm</div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">#指定securityManager的realms实现</div><div class="line">securityManager.realms=$myRealm1</div></pre></td></tr></table></figure><p>通过$name来引入之前的realm定义。</p><h2 id="多Realm配置"><a href="#多Realm配置" class="headerlink" title="多Realm配置"></a>多Realm配置</h2><h3 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-multi-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#声明一个realm  </div><div class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </div><div class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </div><div class="line">#指定securityManager的realms实现  </div><div class="line">securityManager.realms=$myRealm1,$myRealm2</div></pre></td></tr></table></figure><p>securityManager会按照realms指定的顺序进行身份认证。</p><h2 id="Shiro默认提供的Realm"><a href="#Shiro默认提供的Realm" class="headerlink" title="Shiro默认提供的Realm"></a>Shiro默认提供的Realm</h2><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-2.png" alt="跟我学Shiro（二）-身份认证/2-2.png"></p><p>以后一般继承<code>AuthorizingRealm</code>（授权）即可；其继承了<code>AuthenticatingRealm</code>（即身份验证），而且也间接继承了<code>CachingRealm</code>（带有缓存实现）。<br>其中主要默认实现如下：</p><ul><li><strong>org.apache.shiro.realm.text.IniRealm</strong>：<code>[users]部分</code>指定用户名/密码及其角色；<code>[roles]部分</code>指定角色即权限信息；</li><li><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： <code>user.username=password,role1,role2</code>指定用户名/密码及其角色；<code>role.role1=permission1,permission2</code>指定角色及权限信息；</li><li><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过sql查询相应的信息，如<code>“select password from users where username = ?”</code>获取用户密码，<code>“select role_name from user_roles where username = ?”</code>获取用户角色；<code>“select permission from roles_permissions where role_name = ?”</code>获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</li></ul><h2 id="JDBC-Realm使用"><a href="#JDBC-Realm使用" class="headerlink" title="JDBC Realm使用"></a>JDBC Realm使用</h2><h3 id="数据库及依赖"><a href="#数据库及依赖" class="headerlink" title="数据库及依赖"></a>数据库及依赖</h3><blockquote><p><strong>更新</strong>：alibaba的druid包更新版本。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>本文将使用mysql数据库及druid连接池。</p><h3 id="数据库下建表"><a href="#数据库下建表" class="headerlink" title="数据库下建表"></a>数据库下建表</h3><p><code>users</code>（用户名/密码）、<code>user_roles</code>（用户/角色）、<code>roles_permissions</code>（角色/权限）；<br>具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。</p><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote><p>shiro-jdbc-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm  </div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource  </div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro  </div><div class="line">dataSource.username=root  </div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource  </div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><ol><li><code>变量名=全限定类名</code> 自动创建一个类实例</li><li><code>变量名.属性=值</code> 自动调用相应的setter方法进行赋值</li><li><code>$变量名</code> 引用之前的一个对象实例 </li><li><code>测试代码</code>和之前的没什么区别。</li></ol><h1 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Authenticator</strong>的职责是验证用户帐号，<br>是Shiro API中身份验证核心的入口点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；<br>如果验证失败将抛出相应的AuthenticationException实现。</p><p><strong>SecurityManager</strong>接口继承了Authenticator，另外还有一个<code>ModularRealmAuthenticator实现</code>，其委托给多个Realm进行验证，验证规则通过<code>AuthenticationStrategy接口</code>指定，默认提供的实现：</p><ul><li><strong>FirstSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，<code>只返回第一个Realm</code>身份验证成功的认证信息，其他的忽略；</li><li><strong>AtLeastOneSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，和FirstSuccessfulStrategy不同，<code>返回所有Realm</code>身份验证成功的认证信息；</li><li><strong>AllSuccessfulStrategy</strong>：<code>所有Realm验证成功</code>才算成功，且<code>返回所有Realm</code>身份验证成功的认证信息，如果有一个失败就失败了。<blockquote><p><code>ModularRealmAuthenticator</code>默认使用<code>AtLeastOneSuccessfulStrategy</code>策略。</p></blockquote></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>假设有三个realm：<br>myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；<br>myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；<br>myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root；</p></blockquote><h3 id="ini配置文件-1"><a href="#ini配置文件-1" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-authenticator-all-success.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#指定securityManager的authenticator实现</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#指定securityManager.authenticator的authenticationStrategy</div><div class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</div><div class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</div><div class="line"></div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">myRealm2=com.github.gojay001.realm.MyRealm2</div><div class="line">myRealm3=com.github.gojay001.realm.MyRealm3</div><div class="line">securityManager.realms=$myRealm1,$myRealm3</div></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p>com.github.gojay001.test.AuthenticatorTest</p></blockquote><h4 id="首先通用化登录逻辑"><a href="#首先通用化登录逻辑" class="headerlink" title="首先通用化登录逻辑"></a>首先通用化登录逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void login(String configFile) &#123;  </div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </div><div class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </div><div class="line">            new IniSecurityManagerFactory(configFile);  </div><div class="line">  </div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </div><div class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </div><div class="line">    SecurityUtils.setSecurityManager(securityManager);  </div><div class="line">  </div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);  </div><div class="line">  </div><div class="line">    subject.login(token);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy成功"><a href="#测试AllSuccessfulStrategy成功" class="headerlink" title="测试AllSuccessfulStrategy成功"></a>测试AllSuccessfulStrategy成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test  </div><div class="line">public void testAllSuccessfulStrategyWithSuccess() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">  </div><div class="line">    //得到一个身份集合，其包含了Realm验证成功的身份信息  </div><div class="line">    PrincipalCollection principalCollection = subject.getPrincipals();  </div><div class="line">    Assert.assertEquals(2, principalCollection.asList().size());  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy失败"><a href="#测试AllSuccessfulStrategy失败" class="headerlink" title="测试AllSuccessfulStrategy失败"></a>测试AllSuccessfulStrategy失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnknownAccountException.class)  </div><div class="line">public void testAllSuccessfulStrategyWithFail() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>shiro-authenticator-all-fail.ini</code> 与 <code>shiro-authenticator-all-success.ini</code> 不同的配置是使用了 <code>securityManager.realms=$myRealm1,$myRealm2</code> ；即myRealm验证失败。</p><p> 对于 <code>AtLeastOneSuccessfulStrategy</code> 和 <code>FirstSuccessfulStrategy</code> 的区别：唯一不同点一个是<code>返回所有</code>验证成功的Realm的认证信息；另一个是<code>只返回第一个</code>验证成功的Realm的认证信息.<code>示例代码同上</code></p></blockquote><h3 id="自定义AuthenticationStrategy实现"><a href="#自定义AuthenticationStrategy实现" class="headerlink" title="自定义AuthenticationStrategy实现"></a>自定义AuthenticationStrategy实现</h3><p>首先看其API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//在所有Realm验证之前调用  </div><div class="line">AuthenticationInfo beforeAllAttempts(  </div><div class="line">Collection&lt;? extends Realm&gt; realms, AuthenticationToken token)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之前调用  </div><div class="line">AuthenticationInfo beforeAttempt(  </div><div class="line">Realm realm, AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之后调用  </div><div class="line">AuthenticationInfo afterAttempt(  </div><div class="line">Realm realm, AuthenticationToken token,   </div><div class="line">AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)  </div><div class="line">throws AuthenticationException;  </div><div class="line">//在所有Realm之后调用  </div><div class="line">AuthenticationInfo afterAllAttempts(  </div><div class="line">AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>因为每个<code>AuthenticationStrategy</code>实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；<br>通过如上接口可以进行如合并/返回第一个验证成功的认证信息。<br>自定义实现时一般<code>继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code> 即可。<code>参考代码同上</code></p><blockquote><p>到此基本的身份验证就结束了。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="Assert过时"><a href="#Assert过时" class="headerlink" title="Assert过时"></a>Assert过时</h3><blockquote><p><strong>Assert in junit.framework has been deprecated</strong><br><strong>解决</strong>：将 <code>import junit.framework.Assert;</code> 改为 <code>import org.junit.Assert;</code> </p></blockquote><h3 id="SLF4J加载失败"><a href="#SLF4J加载失败" class="headerlink" title="SLF4J加载失败"></a>SLF4J加载失败</h3><blockquote><p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”<br><strong>解决</strong>：Maven引入slf4j-nop包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p></blockquote><h3 id="implements不需要-Override"><a href="#implements不需要-Override" class="headerlink" title="implements不需要@Override"></a>implements不需要@Override</h3><h3 id="alibaba的druid版本更新"><a href="#alibaba的druid版本更新" class="headerlink" title="alibaba的druid版本更新"></a>alibaba的druid版本更新</h3><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="用户登录流程"><a href="#用户登录流程" class="headerlink" title="用户登录流程"></a>用户登录流程</h3><ul><li>Subject.login(token)</li><li>SecurityManager</li><li>Authenticator</li><li>AuthenticatorStrategy</li><li>Realm</li></ul><h3 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h3><ul><li>单Realm</li><li>多Realm</li><li>JDBCRealm</li></ul><h3 id="AuthenticatorStrategy"><a href="#AuthenticatorStrategy" class="headerlink" title="AuthenticatorStrategy"></a>AuthenticatorStrategy</h3><ul><li>FirstSuccessfulStrategy</li><li>AtLeastOneSuccessfulStrategy</li><li>AllSuccessfulStrategy</li><li>自定义Strategy</li></ul><blockquote><p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（一）-Shiro简介</title>
      <link>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/</link>
      <guid>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/</guid>
      <pubDate>Sun, 19 Nov 2017 10:23:36 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;认识&quot;&gt;&lt;a href=&quot;#认识&quot; class=&quot;headerlink&quot; title=&quot;认识&quot;&gt;&lt;/a&gt;认识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Apache Shiro是Java的一个安全框架。  &lt;/li&gt;
&lt;li&gt;对比&lt;code&gt;Spring Security&lt;/code&gt;小而简单。  &lt;/li&gt;
&lt;li&gt;可同时用在JavaSE、JavaEE环境中。  &lt;/li&gt;
&lt;li&gt;主要完成认证、授权、加密、会话管理、与Web集成、缓存等。&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><ul><li>Apache Shiro是Java的一个安全框架。  </li><li>对比<code>Spring Security</code>小而简单。  </li><li>可同时用在JavaSE、JavaEE环境中。  </li><li>主要完成认证、授权、加密、会话管理、与Web集成、缓存等。</li></ul><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-1.png" alt="跟我学Shiro（一）-Shiro简介/1-1.png"></p><ul><li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li><li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；</li><li><strong>Session Manager</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；</li><li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li><li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><strong>Testing</strong>：提供测试支持；</li><li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li></ul><blockquote><p>Shiro不会去维护用户、维护权限；这些需要自己设计提供，然后通过相应的接口注入给Shiro。</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="从外部看Shiro："><a href="#从外部看Shiro：" class="headerlink" title="从外部看Shiro："></a>从外部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-2.png" alt="跟我学Shiro（一）-Shiro简介/1-2.png"></p><ul><li><strong>Subject</strong>：主体；代表了与当前应用交互的用户，如网络爬虫、机器人等；所有 <code>Subject</code> 都绑定到 <code>SecurityManager</code>，与 <code>Subject</code> 的所有交互都会委托给 <code>SecurityManager</code>；可以把 <code>Subject</code> 认为是一个门面，<code>SecurityManager</code> 才是实际的执行者；</li><li><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 <code>SecurityManager</code> 交互，且它管理着所有 <code>Subject</code>；它是 Shiro 的核心，负责与其他组件进行交互，可以把它看成<code>Spring NVC</code>中的 <code>DispatcherServlet</code> 前端控制器；</li><li><strong>Realm</strong>：域；<code>Shiro</code> 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 <code>DataSource</code>，即安全数据源。</li></ul><blockquote><p>最简单的一个 Shiro 应用：</p><ul><li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li><li>我们需要给 Shiro 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li><li>可以看出：Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。</li></ul></blockquote><h3 id="从内部看Shiro："><a href="#从内部看Shiro：" class="headerlink" title="从内部看Shiro："></a>从内部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-3.png" alt="跟我学Shiro（一）-Shiro简介/1-3.png"></p><ul><li><strong>Subject</strong>：主体；可以看到主体可以是任何可以与应用交互的“用户”；</li><li><strong>SecurityManager</strong> ：安全管理器；所有具体的交互都通过 <code>SecurityManager</code> 进行控制；它管理着所有 <code>Subject</code>，且负责进行认证和授权、及会话、缓存的管理，是Shiro的心脏；</li><li><strong>Authenticator</strong>：认证器；负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略<code>Authentication Strategy</code>，即什么情况下算用户认证通过了； </li><li><strong>Authrizer</strong>：授权器；用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能；</li><li><strong>Realm</strong>：可以有 1 个或多个 <code>Realm</code>，可以认为是安全实体数据源，即用于获取安全实体的，由用户提供；Shiro 不知道用户/权限存储在哪及以何种格式存储，所以我们一般在应用中都需要实现自己的 <code>Realm</code>；</li><li><strong>SessionManager</strong>：Session需要有人去管理它的生命周期，这个组件就是<code>SessionManager</code>；Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li><li><strong>SessionDAO</strong>：数据访问对象<code>DAO</code>，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如JDBC写到数据库；比如想把 <code>Session</code> 放到<code>Memcached</code>中，可以实现自己的 <code>Memcached SessionDAO</code>；另外 <code>SessionDAO</code> 中可以使用 <code>Cache</code> 进行缓存，以提高性能；</li><li><strong>CacheManager</strong>：缓存控制器；来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能；</li><li><strong>Cryptography</strong>：密码模块;Shiro 提高了一些常见的加密组件用于如密码加密/解密的。</li></ul><blockquote><p>到此 Shiro 架构及其组件就认识完了。</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java Web路径问题解析</title>
      <link>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</link>
      <guid>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</guid>
      <pubDate>Sun, 19 Nov 2017 09:06:29 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;基本概念的理解&quot;&gt;&lt;a href=&quot;#基本概念的理解&quot; class=&quot;headerlink&quot; title=&quot;基本概念的理解&quot;&gt;&lt;/a&gt;基本概念的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;绝对路径&lt;/strong&gt;：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：&lt;code&gt;C:\xyz\test.txt&lt;/code&gt;；&lt;code&gt;http://www.test.com/index.html&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对路径&lt;/strong&gt;：相对与某个基准目录的路径，例如：&lt;code&gt;&amp;quot;/&amp;quot;&lt;/code&gt;代表Web应用的&lt;code&gt;根目录&lt;/code&gt;，&lt;code&gt;&amp;quot;./&amp;quot;&lt;/code&gt;代表&lt;code&gt;当前目录&lt;/code&gt;,&lt;code&gt;&amp;quot;../&amp;quot;&lt;/code&gt;代表&lt;code&gt;上级目录&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外关于URI，URL,URN等内容，请参考RFC相关文档标准。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="基本概念的理解"><a href="#基本概念的理解" class="headerlink" title="基本概念的理解"></a>基本概念的理解</h1><ul><li><strong>绝对路径</strong>：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：<code>C:\xyz\test.txt</code>；<code>http://www.test.com/index.html</code>；</li><li><strong>相对路径</strong>：相对与某个基准目录的路径，例如：<code>&quot;/&quot;</code>代表Web应用的<code>根目录</code>，<code>&quot;./&quot;</code>代表<code>当前目录</code>,<code>&quot;../&quot;</code>代表<code>上级目录</code>。</li></ul><blockquote><p>另外关于URI，URL,URN等内容，请参考RFC相关文档标准。</p></blockquote><a id="more"></a><h1 id="关于JSP-Servlet中的相对路径和绝对路径"><a href="#关于JSP-Servlet中的相对路径和绝对路径" class="headerlink" title="关于JSP/Servlet中的相对路径和绝对路径"></a>关于JSP/Servlet中的相对路径和绝对路径</h1><h2 id="服务器端的地址"><a href="#服务器端的地址" class="headerlink" title="服务器端的地址"></a>服务器端的地址</h2><blockquote><p>服务器端的相对地址指的是相对于你的web应用的地址，这个地址是在服务器端解析的（不同于<code>html</code>和<code>javascript</code>中的相对地址，他们是由客户端浏览器解析的）；<br>在jsp和servlet中的相对地址应该是相对于你的web应用，即相对于<code>http://192.168.0.1/webapp/</code>的。</p></blockquote><p>用到的地方：  </p><ul><li><strong>forward</strong>：servlet中的request.getRequestDispatcher(address);这个address是在服务器端解析的。<br><code>request.getRequestDispatcher(“/pages/a.jsp”)</code>的绝对路径地址：<br><code>http://192.168.0.1/webapp/pages/a.jsp</code>；</li><li><strong>sendRedirect</strong>：在jsp中<code>&lt;%response.sendRedirect(&quot;/user/a.jsp&quot;);%&gt;</code>。</li></ul><h2 id="客户端的地址"><a href="#客户端的地址" class="headerlink" title="客户端的地址"></a>客户端的地址</h2><blockquote><p>所有的html页面中的相对地址都是相对于服务器根目录<code>http://192.168.0.1/</code>的，而<code>不是</code>根目录下的该Web应用的目录：<code>http://192.168.0.1/webapp/</code>。</p></blockquote><ul><li>HTML中的<strong>form表单的action属性</strong>的地址应该是相对于服务器根目录<code>http://192.168.0.1/</code>；如果提交到a.jsp为：<code>action＝&quot;/webapp/user/a.jsp&quot;</code>或<code>action=&quot;&lt;%=request.getContextPath()%&gt;&quot;/user/a.jsp</code>；</li><li><strong>Javascript</strong>也是在客户端解析的，所以其相对路径和form表单一样。</li></ul><blockquote><p>因此，一般情况下，在<code>JSP/HTML</code>页面等引用的<code>CSS</code>、<code>Javascript</code>、<code>Action</code>等属性前面最好都加上<code>&lt;%=request.getContextPath()%&gt;</code>,以确保所引用的文件都属于Web应用中的目录。<br>另外，应该尽量避免使用类似<code>&quot;.&quot;</code>,<code>&quot;./&quot;</code>,<code>&quot;../&quot;</code>等类似的相对该文件位置的相对路径，这样当文件移动时，很容易出问题。</p></blockquote><h2 id="站点根目录和css路径问题"><a href="#站点根目录和css路径问题" class="headerlink" title="站点根目录和css路径问题"></a>站点根目录和css路径问题</h2><blockquote><p>当在<code>jsp中引入css</code>时，如果其相对路径相对于当前jsp文件的，而在一个和这个jsp的<code>路径不一样的servlet中forward</code>这个jsp时，就会发现这个css样式根本没有起作用。<br>这是因为在servlet中转发时<code>css的路径</code>就是相对于这个<code>servlet的相对路径</code>，而非jsp的路径了。<br>所以这时候不能在jsp中用这样的路径：<code>&lt;link href=&quot;one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>或者<code>&lt;link href=&quot;../../one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>。<br>这个时候要用站点根目录，就是相对于<code>http://192.168.0.1/</code>的目录，以<code>&quot;/&quot;</code>开头。<br>因此上述错误应更正为<code>href=”/test/one.css”</code> 类似的站点根目录的相对目录。</p></blockquote><h1 id="获得JSP-Servlet中当前应用的相对路径和绝对路径"><a href="#获得JSP-Servlet中当前应用的相对路径和绝对路径" class="headerlink" title="获得JSP/Servlet中当前应用的相对路径和绝对路径"></a>获得JSP/Servlet中当前应用的相对路径和绝对路径</h1><h2 id="JSP中获得当前应用的相对路径和绝对路径"><a href="#JSP中获得当前应用的相对路径和绝对路径" class="headerlink" title="JSP中获得当前应用的相对路径和绝对路径"></a>JSP中获得当前应用的相对路径和绝对路径</h2><ul><li><strong>根目录</strong>所对应的绝对路径:<code>request.getRequestURI()</code>;</li><li><strong>文件</strong>的绝对路径:<code>application.getRealPath(request.getRequestURI())</code>;</li><li><strong>当前web应用</strong>的绝对路径:<code>application.getRealPath(&quot;/&quot;)</code>;</li><li><strong>请求文件的上层目录</strong>:<code>new File(application.getRealPath(request.getRequestURI())).getParent()</code>;</li></ul><h2 id="Servlet中获得当前应用的相对路径和绝对路径"><a href="#Servlet中获得当前应用的相对路径和绝对路径" class="headerlink" title="Servlet中获得当前应用的相对路径和绝对路径"></a>Servlet中获得当前应用的相对路径和绝对路径</h2><ul><li><strong>根目录</strong>所对应的绝对路径:<code>request.getServletPath()</code>;</li><li><strong>文件</strong>的绝对路径:<br><code>request.getSession().getServletContext().getRealPath(request.getRequestURI())</code>;</li><li><strong>当前web应用</strong>的绝对路径:<code>servletConfig.getServletContext().getRealPath(&quot;/&quot;)</code>;<blockquote><p><strong>ServletContext对象</strong>获得几种方式：<br>javax.servlet.http.HttpSession.getServletContext();<br>javax.servlet.jsp.PageContext.getServletContext();<br>javax.servlet.ServletConfig.getServletContext(); </p></blockquote></li></ul><h1 id="JAVA的Class中获得相对路径，绝对路径"><a href="#JAVA的Class中获得相对路径，绝对路径" class="headerlink" title="JAVA的Class中获得相对路径，绝对路径"></a>JAVA的Class中获得相对路径，绝对路径</h1><h2 id="单独的Java类中获得绝对路径"><a href="#单独的Java类中获得绝对路径" class="headerlink" title="单独的Java类中获得绝对路径"></a>单独的Java类中获得绝对路径</h2><blockquote><p>根据<code>java.io.File</code>的Doc文挡，可知:<br> 默认情况下<code>new File(&quot;/&quot;)</code>代表的目录为：<code>System.getProperty(&quot;user.dir&quot;)</code>;<br>程序获得执行类的当前路径:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.io.File;</div><div class="line">public class FileTest &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;      </div><div class="line">        System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;));    </div><div class="line">        System.out.println(FileTest.class.getClassLoader().getResource(&quot;&quot;));</div><div class="line">　      System.out.println(ClassLoader.getSystemResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;/&quot;));//Class文件所在路径  </div><div class="line">        System.out.println(new File(&quot;/&quot;).getAbsolutePath());   </div><div class="line">        System.out.println(System.getProperty(&quot;user.dir&quot;));    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="服务器中的Java类获得当前路径"><a href="#服务器中的Java类获得当前路径" class="headerlink" title="服务器中的Java类获得当前路径"></a>服务器中的Java类获得当前路径</h2><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3><blockquote><p>WebApplication的系统文件根目录是你的weblogic安装所在根目录。<br>例如：如果你的weblogic安装在<code>c:\bea\weblogic700.....</code><br>那么，你的文件根路径就是<code>c:\</code><br>所以，有两种方式能够让你访问你的服务器端的文件:  </p><ol><li>使用<strong>绝对路径</strong>：<br>比如将你的参数文件放在c:\yourconfig\yourconf.properties，直接使用<code>new FileInputStream(&quot;yourconfig/yourconf.properties&quot;)</code>;  </li><li>使用<strong>相对路径</strong>：<br>相对路径的根目录就是你的<code>webapplication的根路径</code>，即WEB-INF的上一级目录，将你的参数文件放在<br><code>yourwebapp\yourconfig\yourconf.properties</code>，<br>这样使用：<code>new FileInputStream(&quot;./yourconfig/yourconf.properties&quot;)</code>;</li></ol></blockquote><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><blockquote><p>在类中输出<code>System.getProperty(&quot;user.dir&quot;);</code>显示的是<code>%Tomcat_Home%/bin</code></p></blockquote><h3 id="如何读相对路径哪"><a href="#如何读相对路径哪" class="headerlink" title="如何读相对路径哪?"></a>如何读相对路径哪?</h3><blockquote><p>在Java文件中<code>getResource</code>或<code>getResourceAsStream</code>均可。<br>例：<code>getClass().getResourceAsStream(filePath)</code>;filePath可以是”/filename”,这里的/代表web发布根路径下<code>WEB-INF/classes</code>。</p></blockquote><p>参考文档：<a href="http://huttoncs.iteye.com/blog/2270670" target="_blank" rel="external">java路径问题</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
