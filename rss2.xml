<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>大迷毛|成长录</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>学习 思考 沉淀</description>
    <pubDate>Wed, 22 Nov 2017 06:24:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>跟我学Shiro（二）-身份认证</title>
      <link>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <guid>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <pubDate>Wed, 22 Nov 2017 06:22:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;身份验证&lt;/strong&gt;：在应用中能&lt;code&gt;证明他就是他本人&lt;/code&gt;。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。&lt;br&gt;在 shiro 中，用户需要提供 &lt;code&gt;principals&lt;/code&gt; （身份）和 &lt;code&gt;credentials&lt;/code&gt;（证明）给 shiro，从而应用能验证用户身份。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;principals&lt;/strong&gt;：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但&lt;code&gt;只有一个 Primary principals&lt;/code&gt;，一般是用户名/密码/手机号。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;credentials&lt;/strong&gt;：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的 principals 和 credentials 组合就是&lt;code&gt;用户名/密码&lt;/code&gt;了。&lt;br&gt;另外两个相关的概念是之前提到的 &lt;code&gt;Subject&lt;/code&gt; 及 &lt;code&gt;Realm&lt;/code&gt;，分别是主体及验证主体的数据源。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>身份验证</strong>：在应用中能<code>证明他就是他本人</code>。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>在 shiro 中，用户需要提供 <code>principals</code> （身份）和 <code>credentials</code>（证明）给 shiro，从而应用能验证用户身份。  </p><ul><li><strong>principals</strong>：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但<code>只有一个 Primary principals</code>，一般是用户名/密码/手机号。 </li><li><strong>credentials</strong>：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   </li></ul><blockquote><p>最常见的 principals 和 credentials 组合就是<code>用户名/密码</code>了。<br>另外两个相关的概念是之前提到的 <code>Subject</code> 及 <code>Realm</code>，分别是主体及验证主体的数据源。</p></blockquote><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="使用Maven构建"><a href="#使用Maven构建" class="headerlink" title="使用Maven构建"></a>使用Maven构建</h2><p>准备环境依赖：添加 <code>junit</code>、<code>common-logging</code> 及 <code>shiro-core</code> 依赖；</p><blockquote><p><strong>更新</strong>：加入slf4j-nop依赖包。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">        &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.7.25&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure><h1 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h1><h2 id="准备一些用户身份-凭据"><a href="#准备一些用户身份-凭据" class="headerlink" title="准备一些用户身份/凭据"></a>准备一些用户身份/凭据</h2><blockquote><p>shiro.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">gojay=test</div><div class="line">root=root</div></pre></td></tr></table></figure><p>此处使用ini配置文件，通过<code>[user]</code>指定两个主体。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><blockquote><p>com.github.gojay001.test.LoginLogoutTest<br><strong>更新</strong>：注意类过时。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testLoginLogout() &#123;</div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</div><div class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line"></div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils</div><div class="line">    SecurityManager securityManager = factory.getInstance();</div><div class="line">    SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //4、登录，即身份验证</div><div class="line">        subject.login(token);</div><div class="line">    &#125; catch (AuthenticationException e) &#123;</div><div class="line">        //5、身份验证失败</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Assert.assertEquals(true, subject.isAuthenticated());</div><div class="line"></div><div class="line">    //6、退出</div><div class="line">    subject.logout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>首先通过new IniSecurityManagerFactory并指定一个ini配置文件来<code>创建一个SecurityManager工厂</code>；</li><li>接着<code>获取SecurityManager并绑定到SecurityUtils</code>，这是一个全局设置，设置一次即可；</li><li>通过SecurityUtils<code>得到Subject</code>，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后<code>获取身份验证的Token</code>，如用户名/密码；</li><li><code>调用subject.login方法</code>进行登录，其会自动委托给SecurityManager.login方法进行登录；</li><li><code>如果身份验证失败捕获AuthenticationException或其子类</code>，常见的如： <code>DisabledAccountException</code>（禁用的帐号）、<code>LockedAccountException</code>（锁定的帐号）、<code>UnknownAccountException</code>（错误的帐号）、<code>ExcessiveAttemptsException</code>（登录失败次数过多）、<code>IncorrectCredentialsException</code> （错误的凭证）、<code>ExpiredCredentialsException</code>（过期的凭证）等，具体查看其继承关系；</li><li>最后可以<code>调用subject.logout退出</code>，其会自动委托给SecurityManager.logout方法退出。</li></ul><h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><blockquote><ol><li>收集用户身份/凭证，即如用户名/密码；</li><li>调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</li><li>最后调用Subject.logout进行退出操作。</li></ol></blockquote><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><blockquote><ol><li><code>用户名/密码硬编码</code>在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；</li><li><code>用户身份Token</code>可能不仅仅是用户名/密码，也可能<code>还有其他的</code>，如登录时允许用户名/邮箱/手机号同时登录。 </li></ol></blockquote><h1 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h1><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-1.png" alt="跟我学Shiro（二）-身份认证/2-1.png"></p><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote><ol><li>首先<code>调用Subject.login(token)</code>进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li><li><code>SecurityManager</code>负责真正的身份验证逻辑；它会<code>委托给Authenticator进行身份验证</code>；</li><li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处<code>可以自定义插入自己的实现</code>；</li><li>Authenticator可能会委托给相应的AuthenticationStrategy<code>进行多Realm身份验证</code>，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li><li>Authenticator会<code>把相应的token传入Realm，从Realm获取身份验证信息</code>，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li></ol></blockquote><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><strong>Realm</strong>：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即<code>安全数据源</code>。</p><p>org.apache.shiro.realm.Realm接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String getName(); //返回一个唯一的Realm名字  </div><div class="line">boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  </div><div class="line">AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;  //根据Token获取认证信息</div></pre></td></tr></table></figure></p><h2 id="单Realm配置"><a href="#单Realm配置" class="headerlink" title="单Realm配置"></a>单Realm配置</h2><h3 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h3><blockquote><p>com.github.gojay001.realm.MyRealm1</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> public class MyRealm1 implements Realm &#123;</div><div class="line">    public String getName() &#123;</div><div class="line">        return &quot;myRealm1&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</div><div class="line">        return authenticationToken instanceof UsernamePasswordToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</div><div class="line">        // 得到用户名</div><div class="line">        String username = (String)authenticationToken.getPrincipal();</div><div class="line">        // 得到密码</div><div class="line">        String password = new String((char[])authenticationToken.getCredentials());</div><div class="line">        if(!&quot;root&quot;.equals(username)) &#123;</div><div class="line">            //用户名错误</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line">        if(!&quot;root&quot;.equals(password)) &#123;</div><div class="line">            //密码错误</div><div class="line">            throw new IncorrectCredentialsException();</div><div class="line">        &#125;</div><div class="line">        //如果身份认证验证成功，返回一个AuthenticationInfo实现；</div><div class="line">        return new SimpleAuthenticationInfo(username, password, getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="ini配置文件指定自定义Realm实现"><a href="#ini配置文件指定自定义Realm实现" class="headerlink" title="ini配置文件指定自定义Realm实现"></a>ini配置文件指定自定义Realm实现</h3><blockquote><p>shiro-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#声明一个realm</div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">#指定securityManager的realms实现</div><div class="line">securityManager.realms=$myRealm1</div></pre></td></tr></table></figure><p>通过$name来引入之前的realm定义。</p><h2 id="多Realm配置"><a href="#多Realm配置" class="headerlink" title="多Realm配置"></a>多Realm配置</h2><h3 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-multi-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#声明一个realm  </div><div class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </div><div class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </div><div class="line">#指定securityManager的realms实现  </div><div class="line">securityManager.realms=$myRealm1,$myRealm2</div></pre></td></tr></table></figure><p>securityManager会按照realms指定的顺序进行身份认证。</p><h2 id="Shiro默认提供的Realm"><a href="#Shiro默认提供的Realm" class="headerlink" title="Shiro默认提供的Realm"></a>Shiro默认提供的Realm</h2><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-2.png" alt="跟我学Shiro（二）-身份认证/2-2.png"></p><p>以后一般继承<code>AuthorizingRealm</code>（授权）即可；其继承了<code>AuthenticatingRealm</code>（即身份验证），而且也间接继承了<code>CachingRealm</code>（带有缓存实现）。<br>其中主要默认实现如下：</p><ul><li><strong>org.apache.shiro.realm.text.IniRealm</strong>：<code>[users]部分</code>指定用户名/密码及其角色；<code>[roles]部分</code>指定角色即权限信息；</li><li><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： <code>user.username=password,role1,role2</code>指定用户名/密码及其角色；<code>role.role1=permission1,permission2</code>指定角色及权限信息；</li><li><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过sql查询相应的信息，如<code>“select password from users where username = ?”</code>获取用户密码，<code>“select role_name from user_roles where username = ?”</code>获取用户角色；<code>“select permission from roles_permissions where role_name = ?”</code>获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</li></ul><h2 id="JDBC-Realm使用"><a href="#JDBC-Realm使用" class="headerlink" title="JDBC Realm使用"></a>JDBC Realm使用</h2><h3 id="数据库及依赖"><a href="#数据库及依赖" class="headerlink" title="数据库及依赖"></a>数据库及依赖</h3><blockquote><p><strong>更新</strong>：alibaba的druid包更新版本。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>本文将使用mysql数据库及druid连接池。</p><h3 id="数据库下建表"><a href="#数据库下建表" class="headerlink" title="数据库下建表"></a>数据库下建表</h3><p><code>users</code>（用户名/密码）、<code>user_roles</code>（用户/角色）、<code>roles_permissions</code>（角色/权限）；<br>具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。</p><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote><p>shiro-jdbc-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm  </div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource  </div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro  </div><div class="line">dataSource.username=root  </div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource  </div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><ol><li><code>变量名=全限定类名</code> 自动创建一个类实例</li><li><code>变量名.属性=值</code> 自动调用相应的setter方法进行赋值</li><li><code>$变量名</code> 引用之前的一个对象实例 </li><li><code>测试代码</code>和之前的没什么区别。</li></ol><h1 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Authenticator</strong>的职责是验证用户帐号，<br>是Shiro API中身份验证核心的入口点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；<br>如果验证失败将抛出相应的AuthenticationException实现。</p><p><strong>SecurityManager</strong>接口继承了Authenticator，另外还有一个<code>ModularRealmAuthenticator实现</code>，其委托给多个Realm进行验证，验证规则通过<code>AuthenticationStrategy接口</code>指定，默认提供的实现：</p><ul><li><strong>FirstSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，<code>只返回第一个Realm</code>身份验证成功的认证信息，其他的忽略；</li><li><strong>AtLeastOneSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，和FirstSuccessfulStrategy不同，<code>返回所有Realm</code>身份验证成功的认证信息；</li><li><strong>AllSuccessfulStrategy</strong>：<code>所有Realm验证成功</code>才算成功，且<code>返回所有Realm</code>身份验证成功的认证信息，如果有一个失败就失败了。<blockquote><p><code>ModularRealmAuthenticator</code>默认使用<code>AtLeastOneSuccessfulStrategy</code>策略。</p></blockquote></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>假设有三个realm：<br>myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；<br>myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；<br>myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root；</p></blockquote><h3 id="ini配置文件-1"><a href="#ini配置文件-1" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-authenticator-all-success.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#指定securityManager的authenticator实现</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#指定securityManager.authenticator的authenticationStrategy</div><div class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</div><div class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</div><div class="line"></div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">myRealm2=com.github.gojay001.realm.MyRealm2</div><div class="line">myRealm3=com.github.gojay001.realm.MyRealm3</div><div class="line">securityManager.realms=$myRealm1,$myRealm3</div></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p>com.github.gojay001.test.AuthenticatorTest</p></blockquote><h4 id="首先通用化登录逻辑"><a href="#首先通用化登录逻辑" class="headerlink" title="首先通用化登录逻辑"></a>首先通用化登录逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void login(String configFile) &#123;  </div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </div><div class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </div><div class="line">            new IniSecurityManagerFactory(configFile);  </div><div class="line">  </div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </div><div class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </div><div class="line">    SecurityUtils.setSecurityManager(securityManager);  </div><div class="line">  </div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);  </div><div class="line">  </div><div class="line">    subject.login(token);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy成功"><a href="#测试AllSuccessfulStrategy成功" class="headerlink" title="测试AllSuccessfulStrategy成功"></a>测试AllSuccessfulStrategy成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test  </div><div class="line">public void testAllSuccessfulStrategyWithSuccess() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">  </div><div class="line">    //得到一个身份集合，其包含了Realm验证成功的身份信息  </div><div class="line">    PrincipalCollection principalCollection = subject.getPrincipals();  </div><div class="line">    Assert.assertEquals(2, principalCollection.asList().size());  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy失败"><a href="#测试AllSuccessfulStrategy失败" class="headerlink" title="测试AllSuccessfulStrategy失败"></a>测试AllSuccessfulStrategy失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnknownAccountException.class)  </div><div class="line">public void testAllSuccessfulStrategyWithFail() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>shiro-authenticator-all-fail.ini</code> 与 <code>shiro-authenticator-all-success.ini</code> 不同的配置是使用了 <code>securityManager.realms=$myRealm1,$myRealm2</code> ；即myRealm验证失败。</p><p> 对于 <code>AtLeastOneSuccessfulStrategy</code> 和 <code>FirstSuccessfulStrategy</code> 的区别：唯一不同点一个是<code>返回所有</code>验证成功的Realm的认证信息；另一个是<code>只返回第一个</code>验证成功的Realm的认证信息.<code>示例代码同上</code></p></blockquote><h3 id="自定义AuthenticationStrategy实现"><a href="#自定义AuthenticationStrategy实现" class="headerlink" title="自定义AuthenticationStrategy实现"></a>自定义AuthenticationStrategy实现</h3><p>首先看其API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//在所有Realm验证之前调用  </div><div class="line">AuthenticationInfo beforeAllAttempts(  </div><div class="line">Collection&lt;? extends Realm&gt; realms, AuthenticationToken token)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之前调用  </div><div class="line">AuthenticationInfo beforeAttempt(  </div><div class="line">Realm realm, AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之后调用  </div><div class="line">AuthenticationInfo afterAttempt(  </div><div class="line">Realm realm, AuthenticationToken token,   </div><div class="line">AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)  </div><div class="line">throws AuthenticationException;  </div><div class="line">//在所有Realm之后调用  </div><div class="line">AuthenticationInfo afterAllAttempts(  </div><div class="line">AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>因为每个<code>AuthenticationStrategy</code>实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；<br>通过如上接口可以进行如合并/返回第一个验证成功的认证信息。<br>自定义实现时一般<code>继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code> 即可。<code>参考代码同上</code></p><blockquote><p>到此基本的身份验证就结束了。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="Assert过时"><a href="#Assert过时" class="headerlink" title="Assert过时"></a>Assert过时</h3><blockquote><p><strong>Assert in junit.framework has been deprecated</strong><br><strong>解决</strong>：将 <code>import junit.framework.Assert;</code> 改为 <code>import org.junit.Assert;</code> </p></blockquote><h3 id="SLF4J加载失败"><a href="#SLF4J加载失败" class="headerlink" title="SLF4J加载失败"></a>SLF4J加载失败</h3><blockquote><p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”<br><strong>解决</strong>：Maven引入slf4j-nop包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p></blockquote><h3 id="implements不需要-Override"><a href="#implements不需要-Override" class="headerlink" title="implements不需要@Override"></a>implements不需要@Override</h3><h3 id="alibaba的druid版本更新"><a href="#alibaba的druid版本更新" class="headerlink" title="alibaba的druid版本更新"></a>alibaba的druid版本更新</h3><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="用户登录流程"><a href="#用户登录流程" class="headerlink" title="用户登录流程"></a>用户登录流程</h3><ul><li>Subject.login(token)</li><li>SecurityManager</li><li>Authenticator</li><li>AuthenticatorStrategy</li><li>Realm</li></ul><h3 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h3><ul><li>单Realm</li><li>多Realm</li><li>JDBCRealm</li></ul><h3 id="AuthenticatorStrategy"><a href="#AuthenticatorStrategy" class="headerlink" title="AuthenticatorStrategy"></a>AuthenticatorStrategy</h3><ul><li>FirstSuccessfulStrategy</li><li>AtLeastOneSuccessfulStrategy</li><li>AllSuccessfulStrategy</li><li>自定义Strategy</li></ul><blockquote><p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（一）-Shiro简介</title>
      <link>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/</link>
      <guid>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/</guid>
      <pubDate>Sun, 19 Nov 2017 10:23:36 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;h2 id=&quot;认识&quot;&gt;&lt;a href=&quot;#认识&quot; class=&quot;headerlink&quot; title=&quot;认识&quot;&gt;&lt;/a&gt;认识&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Apache Shiro是Java的一个安全框架。  &lt;/li&gt;
&lt;li&gt;对比&lt;code&gt;Spring Security&lt;/code&gt;小而简单。  &lt;/li&gt;
&lt;li&gt;可同时用在JavaSE、JavaEE环境中。  &lt;/li&gt;
&lt;li&gt;主要完成认证、授权、加密、会话管理、与Web集成、缓存等。&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><ul><li>Apache Shiro是Java的一个安全框架。  </li><li>对比<code>Spring Security</code>小而简单。  </li><li>可同时用在JavaSE、JavaEE环境中。  </li><li>主要完成认证、授权、加密、会话管理、与Web集成、缓存等。</li></ul><a id="more"></a><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-1.png" alt="跟我学Shiro（一）-Shiro简介/1-1.png"></p><ul><li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li><li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；</li><li><strong>Session Manager</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；</li><li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li><li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li><li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li><li><strong>Testing</strong>：提供测试支持；</li><li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li><li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li></ul><blockquote><p>Shiro不会去维护用户、维护权限；这些需要自己设计提供，然后通过相应的接口注入给Shiro。</p></blockquote><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="从外部看Shiro："><a href="#从外部看Shiro：" class="headerlink" title="从外部看Shiro："></a>从外部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-2.png" alt="跟我学Shiro（一）-Shiro简介/1-2.png"></p><ul><li><strong>Subject</strong>：主体；代表了与当前应用交互的用户，如网络爬虫、机器人等；所有 <code>Subject</code> 都绑定到 <code>SecurityManager</code>，与 <code>Subject</code> 的所有交互都会委托给 <code>SecurityManager</code>；可以把 <code>Subject</code> 认为是一个门面，<code>SecurityManager</code> 才是实际的执行者；</li><li><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 <code>SecurityManager</code> 交互，且它管理着所有 <code>Subject</code>；它是 Shiro 的核心，负责与其他组件进行交互，可以把它看成<code>Spring NVC</code>中的 <code>DispatcherServlet</code> 前端控制器；</li><li><strong>Realm</strong>：域；<code>Shiro</code> 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 <code>DataSource</code>，即安全数据源。</li></ul><blockquote><p>最简单的一个 Shiro 应用：</p><ul><li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li><li>我们需要给 Shiro 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li><li>可以看出：Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。</li></ul></blockquote><h3 id="从内部看Shiro："><a href="#从内部看Shiro：" class="headerlink" title="从内部看Shiro："></a>从内部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-3.png" alt="跟我学Shiro（一）-Shiro简介/1-3.png"></p><ul><li><strong>Subject</strong>：主体；可以看到主体可以是任何可以与应用交互的“用户”；</li><li><strong>SecurityManager</strong> ：安全管理器；所有具体的交互都通过 <code>SecurityManager</code> 进行控制；它管理着所有 <code>Subject</code>，且负责进行认证和授权、及会话、缓存的管理，是Shiro的心脏；</li><li><strong>Authenticator</strong>：认证器；负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略<code>Authentication Strategy</code>，即什么情况下算用户认证通过了； </li><li><strong>Authrizer</strong>：授权器；用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能；</li><li><strong>Realm</strong>：可以有 1 个或多个 <code>Realm</code>，可以认为是安全实体数据源，即用于获取安全实体的，由用户提供；Shiro 不知道用户/权限存储在哪及以何种格式存储，所以我们一般在应用中都需要实现自己的 <code>Realm</code>；</li><li><strong>SessionManager</strong>：Session需要有人去管理它的生命周期，这个组件就是<code>SessionManager</code>；Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li><li><strong>SessionDAO</strong>：数据访问对象<code>DAO</code>，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如JDBC写到数据库；比如想把 <code>Session</code> 放到<code>Memcached</code>中，可以实现自己的 <code>Memcached SessionDAO</code>；另外 <code>SessionDAO</code> 中可以使用 <code>Cache</code> 进行缓存，以提高性能；</li><li><strong>CacheManager</strong>：缓存控制器；来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能；</li><li><strong>Cryptography</strong>：密码模块;Shiro 提高了一些常见的加密组件用于如密码加密/解密的。</li></ul><blockquote><p>到此 Shiro 架构及其组件就认识完了。</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java Web路径问题解析</title>
      <link>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</link>
      <guid>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</guid>
      <pubDate>Sun, 19 Nov 2017 09:06:29 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;基本概念的理解&quot;&gt;&lt;a href=&quot;#基本概念的理解&quot; class=&quot;headerlink&quot; title=&quot;基本概念的理解&quot;&gt;&lt;/a&gt;基本概念的理解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;绝对路径&lt;/strong&gt;：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：&lt;code&gt;C:\xyz\test.txt&lt;/code&gt;；&lt;code&gt;http://www.test.com/index.html&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对路径&lt;/strong&gt;：相对与某个基准目录的路径，例如：&lt;code&gt;&amp;quot;/&amp;quot;&lt;/code&gt;代表Web应用的&lt;code&gt;根目录&lt;/code&gt;，&lt;code&gt;&amp;quot;./&amp;quot;&lt;/code&gt;代表&lt;code&gt;当前目录&lt;/code&gt;,&lt;code&gt;&amp;quot;../&amp;quot;&lt;/code&gt;代表&lt;code&gt;上级目录&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外关于URI，URL,URN等内容，请参考RFC相关文档标准。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="基本概念的理解"><a href="#基本概念的理解" class="headerlink" title="基本概念的理解"></a>基本概念的理解</h1><ul><li><strong>绝对路径</strong>：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：<code>C:\xyz\test.txt</code>；<code>http://www.test.com/index.html</code>；</li><li><strong>相对路径</strong>：相对与某个基准目录的路径，例如：<code>&quot;/&quot;</code>代表Web应用的<code>根目录</code>，<code>&quot;./&quot;</code>代表<code>当前目录</code>,<code>&quot;../&quot;</code>代表<code>上级目录</code>。</li></ul><blockquote><p>另外关于URI，URL,URN等内容，请参考RFC相关文档标准。</p></blockquote><a id="more"></a><h1 id="关于JSP-Servlet中的相对路径和绝对路径"><a href="#关于JSP-Servlet中的相对路径和绝对路径" class="headerlink" title="关于JSP/Servlet中的相对路径和绝对路径"></a>关于JSP/Servlet中的相对路径和绝对路径</h1><h2 id="服务器端的地址"><a href="#服务器端的地址" class="headerlink" title="服务器端的地址"></a>服务器端的地址</h2><blockquote><p>服务器端的相对地址指的是相对于你的web应用的地址，这个地址是在服务器端解析的（不同于<code>html</code>和<code>javascript</code>中的相对地址，他们是由客户端浏览器解析的）；<br>在jsp和servlet中的相对地址应该是相对于你的web应用，即相对于<code>http://192.168.0.1/webapp/</code>的。</p></blockquote><p>用到的地方：  </p><ul><li><strong>forward</strong>：servlet中的request.getRequestDispatcher(address);这个address是在服务器端解析的。<br><code>request.getRequestDispatcher(“/pages/a.jsp”)</code>的绝对路径地址：<br><code>http://192.168.0.1/webapp/pages/a.jsp</code>；</li><li><strong>sendRedirect</strong>：在jsp中<code>&lt;%response.sendRedirect(&quot;/user/a.jsp&quot;);%&gt;</code>。</li></ul><h2 id="客户端的地址"><a href="#客户端的地址" class="headerlink" title="客户端的地址"></a>客户端的地址</h2><blockquote><p>所有的html页面中的相对地址都是相对于服务器根目录<code>http://192.168.0.1/</code>的，而<code>不是</code>根目录下的该Web应用的目录：<code>http://192.168.0.1/webapp/</code>。</p></blockquote><ul><li>HTML中的<strong>form表单的action属性</strong>的地址应该是相对于服务器根目录<code>http://192.168.0.1/</code>；如果提交到a.jsp为：<code>action＝&quot;/webapp/user/a.jsp&quot;</code>或<code>action=&quot;&lt;%=request.getContextPath()%&gt;&quot;/user/a.jsp</code>；</li><li><strong>Javascript</strong>也是在客户端解析的，所以其相对路径和form表单一样。</li></ul><blockquote><p>因此，一般情况下，在<code>JSP/HTML</code>页面等引用的<code>CSS</code>、<code>Javascript</code>、<code>Action</code>等属性前面最好都加上<code>&lt;%=request.getContextPath()%&gt;</code>,以确保所引用的文件都属于Web应用中的目录。<br>另外，应该尽量避免使用类似<code>&quot;.&quot;</code>,<code>&quot;./&quot;</code>,<code>&quot;../&quot;</code>等类似的相对该文件位置的相对路径，这样当文件移动时，很容易出问题。</p></blockquote><h2 id="站点根目录和css路径问题"><a href="#站点根目录和css路径问题" class="headerlink" title="站点根目录和css路径问题"></a>站点根目录和css路径问题</h2><blockquote><p>当在<code>jsp中引入css</code>时，如果其相对路径相对于当前jsp文件的，而在一个和这个jsp的<code>路径不一样的servlet中forward</code>这个jsp时，就会发现这个css样式根本没有起作用。<br>这是因为在servlet中转发时<code>css的路径</code>就是相对于这个<code>servlet的相对路径</code>，而非jsp的路径了。<br>所以这时候不能在jsp中用这样的路径：<code>&lt;link href=&quot;one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>或者<code>&lt;link href=&quot;../../one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>。<br>这个时候要用站点根目录，就是相对于<code>http://192.168.0.1/</code>的目录，以<code>&quot;/&quot;</code>开头。<br>因此上述错误应更正为<code>href=”/test/one.css”</code> 类似的站点根目录的相对目录。</p></blockquote><h1 id="获得JSP-Servlet中当前应用的相对路径和绝对路径"><a href="#获得JSP-Servlet中当前应用的相对路径和绝对路径" class="headerlink" title="获得JSP/Servlet中当前应用的相对路径和绝对路径"></a>获得JSP/Servlet中当前应用的相对路径和绝对路径</h1><h2 id="JSP中获得当前应用的相对路径和绝对路径"><a href="#JSP中获得当前应用的相对路径和绝对路径" class="headerlink" title="JSP中获得当前应用的相对路径和绝对路径"></a>JSP中获得当前应用的相对路径和绝对路径</h2><ul><li><strong>根目录</strong>所对应的绝对路径:<code>request.getRequestURI()</code>;</li><li><strong>文件</strong>的绝对路径:<code>application.getRealPath(request.getRequestURI())</code>;</li><li><strong>当前web应用</strong>的绝对路径:<code>application.getRealPath(&quot;/&quot;)</code>;</li><li><strong>请求文件的上层目录</strong>:<code>new File(application.getRealPath(request.getRequestURI())).getParent()</code>;</li></ul><h2 id="Servlet中获得当前应用的相对路径和绝对路径"><a href="#Servlet中获得当前应用的相对路径和绝对路径" class="headerlink" title="Servlet中获得当前应用的相对路径和绝对路径"></a>Servlet中获得当前应用的相对路径和绝对路径</h2><ul><li><strong>根目录</strong>所对应的绝对路径:<code>request.getServletPath()</code>;</li><li><strong>文件</strong>的绝对路径:<br><code>request.getSession().getServletContext().getRealPath(request.getRequestURI())</code>;</li><li><strong>当前web应用</strong>的绝对路径:<code>servletConfig.getServletContext().getRealPath(&quot;/&quot;)</code>;<blockquote><p><strong>ServletContext对象</strong>获得几种方式：<br>javax.servlet.http.HttpSession.getServletContext();<br>javax.servlet.jsp.PageContext.getServletContext();<br>javax.servlet.ServletConfig.getServletContext(); </p></blockquote></li></ul><h1 id="JAVA的Class中获得相对路径，绝对路径"><a href="#JAVA的Class中获得相对路径，绝对路径" class="headerlink" title="JAVA的Class中获得相对路径，绝对路径"></a>JAVA的Class中获得相对路径，绝对路径</h1><h2 id="单独的Java类中获得绝对路径"><a href="#单独的Java类中获得绝对路径" class="headerlink" title="单独的Java类中获得绝对路径"></a>单独的Java类中获得绝对路径</h2><blockquote><p>根据<code>java.io.File</code>的Doc文挡，可知:<br> 默认情况下<code>new File(&quot;/&quot;)</code>代表的目录为：<code>System.getProperty(&quot;user.dir&quot;)</code>;<br>程序获得执行类的当前路径:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.io.File;</div><div class="line">public class FileTest &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;      </div><div class="line">        System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;));    </div><div class="line">        System.out.println(FileTest.class.getClassLoader().getResource(&quot;&quot;));</div><div class="line">　      System.out.println(ClassLoader.getSystemResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;/&quot;));//Class文件所在路径  </div><div class="line">        System.out.println(new File(&quot;/&quot;).getAbsolutePath());   </div><div class="line">        System.out.println(System.getProperty(&quot;user.dir&quot;));    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="服务器中的Java类获得当前路径"><a href="#服务器中的Java类获得当前路径" class="headerlink" title="服务器中的Java类获得当前路径"></a>服务器中的Java类获得当前路径</h2><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3><blockquote><p>WebApplication的系统文件根目录是你的weblogic安装所在根目录。<br>例如：如果你的weblogic安装在<code>c:\bea\weblogic700.....</code><br>那么，你的文件根路径就是<code>c:\</code><br>所以，有两种方式能够让你访问你的服务器端的文件:  </p><ol><li>使用<strong>绝对路径</strong>：<br>比如将你的参数文件放在c:\yourconfig\yourconf.properties，直接使用<code>new FileInputStream(&quot;yourconfig/yourconf.properties&quot;)</code>;  </li><li>使用<strong>相对路径</strong>：<br>相对路径的根目录就是你的<code>webapplication的根路径</code>，即WEB-INF的上一级目录，将你的参数文件放在<br><code>yourwebapp\yourconfig\yourconf.properties</code>，<br>这样使用：<code>new FileInputStream(&quot;./yourconfig/yourconf.properties&quot;)</code>;</li></ol></blockquote><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><blockquote><p>在类中输出<code>System.getProperty(&quot;user.dir&quot;);</code>显示的是<code>%Tomcat_Home%/bin</code></p></blockquote><h3 id="如何读相对路径哪"><a href="#如何读相对路径哪" class="headerlink" title="如何读相对路径哪?"></a>如何读相对路径哪?</h3><blockquote><p>在Java文件中<code>getResource</code>或<code>getResourceAsStream</code>均可。<br>例：<code>getClass().getResourceAsStream(filePath)</code>;filePath可以是”/filename”,这里的/代表web发布根路径下<code>WEB-INF/classes</code>。</p></blockquote><p>参考文档：<a href="http://huttoncs.iteye.com/blog/2270670" target="_blank" rel="external">java路径问题</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>web编码问题详解</title>
      <link>http://yoursite.com/2017/11/15/web%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</link>
      <guid>http://yoursite.com/2017/11/15/web%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</guid>
      <pubDate>Wed, 15 Nov 2017 04:06:11 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近搭建spring mvc项目时又再次遇到了编码问题，仔细想想，虽然以前用JSP+Servlet的时候解决了中文乱码的问题，但是都没有仔细分析过每个流程。于是今天在这里整理一下,web应用中常见的与编码相关配置：&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近搭建spring mvc项目时又再次遇到了编码问题，仔细想想，虽然以前用JSP+Servlet的时候解决了中文乱码的问题，但是都没有仔细分析过每个流程。于是今天在这里整理一下,web应用中常见的与编码相关配置：<br><a id="more"></a></p><h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><blockquote><p>首先配置好项目里的编码，这里主要有三个地方需要注意：</p></blockquote><h2 id="页面乱码"><a href="#页面乱码" class="headerlink" title="页面乱码"></a>页面乱码</h2><blockquote><p>页面乱码相对简单，只需要设置相关字符集编码即可。</p></blockquote><h3 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</div></pre></td></tr></table></figure><blockquote><p>pageEncoding：该页面编码格式；<br>charset：页面解码格式。</p></blockquote><h3 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt;</div></pre></td></tr></table></figure><h2 id="传值乱码"><a href="#传值乱码" class="headerlink" title="传值乱码"></a>传值乱码</h2><blockquote><p>页面到controller传值乱码需要在web.xml配置字符编码过滤器。</p></blockquote><h3 id="直接应用spring中字符编码过滤器"><a href="#直接应用spring中字符编码过滤器" class="headerlink" title="直接应用spring中字符编码过滤器"></a>直接应用spring中字符编码过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!--字符编码--&gt;</div><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure><h4 id="字符编码拦截器作用："><a href="#字符编码拦截器作用：" class="headerlink" title="字符编码拦截器作用："></a>字符编码拦截器作用：</h4><blockquote><p>分析源码发现作用相当于servlet中：<br>request.setCharacterEncoding(“UTF-8”);<br>response.setCharacterEncoding(“UTF-8”);</p></blockquote><h4 id="spring自带过滤器主要针对POST请求，对GET请求无效："><a href="#spring自带过滤器主要针对POST请求，对GET请求无效：" class="headerlink" title="spring自带过滤器主要针对POST请求，对GET请求无效："></a>spring自带过滤器主要针对POST请求，对GET请求无效：</h4><blockquote><p>对于GET请求的参数乱码，解决方法是采用数据还原：<br>String userName= request.getParameter(“userName”);<br>userName=new String(userName.getBytes(“iso8859-1”),”UTF-8”);</p></blockquote><h4 id="lt-url-pattern-gt-中匹配说明："><a href="#lt-url-pattern-gt-中匹配说明：" class="headerlink" title="&lt;url-pattern&gt;中匹配说明："></a><code>&lt;url-pattern&gt;</code>中匹配说明：</h4><blockquote><p><code>/</code>：不会匹配到<code>/*.jsp</code>，但会匹配<code>/login</code>等路径类型的url；<br><code>/*</code>：会匹配<code>/login</code>、<code>*.jsp</code>、<code>*.html</code>等路径；</p></blockquote><h3 id="根据源码可自己编写字符编码过滤器"><a href="#根据源码可自己编写字符编码过滤器" class="headerlink" title="根据源码可自己编写字符编码过滤器"></a>根据源码可自己编写字符编码过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CharacterEncodingFilter implements Filter &#123;</div><div class="line">    private String encoding = null;</div><div class="line">    private FilterConfig filterConfig = null;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(FilterConfig config) throws ServletException &#123;</div><div class="line">        this.filterConfig = config;</div><div class="line">        this.encoding = config.getInitParameter(&quot;encoding&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        if (encoding != null) &#123;</div><div class="line">            request.setCharacterEncoding(encoding);</div><div class="line">            response.setContentType(&quot;text/html;charset=&quot; + encoding);</div><div class="line">        &#125;</div><div class="line">        chain.doFilter(request, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="存入数据库乱码"><a href="#存入数据库乱码" class="headerlink" title="存入数据库乱码"></a>存入数据库乱码</h2><blockquote><p>需要在数据库配置文件设置参数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url=jdbc:mysql://gojay001.mysql.rds.aliyuncs.com:3306/trade?useUnicode=true&amp;characterEncoding=utf8</div></pre></td></tr></table></figure><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><blockquote><p>按照上述确认了项目内的字符编码后，在实际运行环境中可能还是会出现乱码的情况，比如发布到云服务器上。这时候就需要配置相关的环境，主要是数据库和tomcat的配置。</p></blockquote><h2 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h2><blockquote><p>在tomcat的conf/server.xml中配置Get请求默认编码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;  </div><div class="line">      connectionTimeout=&quot;20000&quot;  </div><div class="line">      redirectPort=&quot;8443&quot;   </div><div class="line">      URIEncoding=&quot;UTF-8&quot;  </div><div class="line">      useBodyEncodingForURI=&quot;true&quot;  </div><div class="line">      /&gt;</div></pre></td></tr></table></figure><h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><blockquote><p>参考：<a href="http://www.linuxidc.com/Linux/2014-10/108610.htm" target="_blank" rel="external">CentOS安装MySQL中文乱码问题解决</a><br>1、原因：安装mysql之后默认的字符编码为latin1;<br>2、查看：<code>show variables like &#39;%char%&#39;</code>;<br>3、修改为下面内容后重启mysql：<code>vi /etc/my.cf</code>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">character_set_server=utf8</div><div class="line">lower_case_table_names=1</div><div class="line">datadir=/var/lib/mysql</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line">user=mysql</div><div class="line">symbolic-links=0</div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[mysqld_safe]</div><div class="line">default-character-set = utf8</div><div class="line">log-error=/var/log/mysqld.log</div><div class="line">pid-file=/var/run/mysqld/mysqld.pid</div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set = utf8</div><div class="line"></div><div class="line">[mysql.server]</div><div class="line">default-character-set = utf8</div><div class="line"></div><div class="line">[mysql]</div><div class="line">default-character-set = utf8</div></pre></td></tr></table></figure></p></blockquote><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h3 id="HTML文件仍然显示乱码："><a href="#HTML文件仍然显示乱码：" class="headerlink" title="HTML文件仍然显示乱码："></a>HTML文件仍然显示乱码：</h3><p><strong>将编码格式保存为UTF-8包含BOM</strong></p><blockquote><p>这次总结编码也就是因为遇到这个问题，一直以为是项目配置或者服务器的问题，困扰了几天后才发现这个原因。至于为什么需要带BOM，网上的评论也很多，这里也确实解决了我出现的问题。</p></blockquote><h3 id="静态资源访问："><a href="#静态资源访问：" class="headerlink" title="静态资源访问："></a>静态资源访问：</h3><p>1、在web.xml中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!--解决静态资源访问--&gt;</div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure></p><p>2、路径说明：<br><strong>/page/index.html</strong>:根目录下的page文件夹；<br><strong>../page/index.html</strong>:当前路径的上一级的page文件夹；<br><strong>page/index.html</strong>:当前路径的page文件夹。</p><blockquote><p>以上目前我所遇到并解决的问题，可能还有其他相关我不了解的配置，以后学习了也会继续补充上来。</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/15/web%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>阿里云搭建java Web环境</title>
      <link>http://yoursite.com/2017/11/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83/</link>
      <guid>http://yoursite.com/2017/11/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Mon, 06 Nov 2017 13:59:10 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;最近重新在阿里云上配置了服务器和数据库，今天正好整理一下配置过程并且结合以前在CentOS下搭建java Web的流程，写在这里，以免以后忘记了不知所措。下面进入主题：&lt;br&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><hr><p>最近重新在阿里云上配置了服务器和数据库，今天正好整理一下配置过程并且结合以前在CentOS下搭建java Web的流程，写在这里，以免以后忘记了不知所措。下面进入主题：<br><a id="more"></a></p><h1 id="二、配置阿里云"><a href="#二、配置阿里云" class="headerlink" title="二、配置阿里云"></a>二、配置阿里云</h1><hr><p>阿里云有学生优惠9.9一个月的云服务器，可以直接购买配置，选择CentOS。我在活动期间购买时花了9.9买了.xin域名和域名解析1年，还送了阿里云一整套6个月：服务器、数据库、OSS等等。我目前只在云服务器下搭建java Web环境并发布项目，然后连接的云数据库。服务器和数据库的配置都比较简单，阿里云上也有官方文档可以查看，按着步骤一步步配置下来就行了。</p><h1 id="三、工具准备"><a href="#三、工具准备" class="headerlink" title="三、工具准备"></a>三、工具准备</h1><hr><p>我采用的是在Windows下开发，然后将项目发布在云服务器上。所以，首先需要在Windows下准备几个工具。</p><h2 id="1、SecureCRT"><a href="#1、SecureCRT" class="headerlink" title="1、SecureCRT"></a>1、SecureCRT</h2><p>SecureCRT用于连接云服务器，能够在Windows下直接操作服务器。</p><h3 id="安装SecureCRT："><a href="#安装SecureCRT：" class="headerlink" title="安装SecureCRT："></a>安装SecureCRT：</h3><blockquote><p>下载SecureCRT及注册机<br>安装<br>打开注册机生成key<br>输入注册信息</p></blockquote><p>因为安装SercureCRT比较简单，这里就不过多介绍，在这里附上一个详细的<a href="http://www.cnblogs.com/qingtingzhe/articles/5008902.html" target="_blank" rel="external">安装步骤</a>。</p><h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><blockquote><p>输入ip、username、password建立session；<br>设置session选项；<code>（输出日志文件文件可以保存命令）</code><br>其他一些<a href="http://blog.csdn.net/sfslife/article/details/50923954" target="_blank" rel="external">个性化配置</a>可以参考。</p></blockquote><h2 id="2、FileZilla-FTP-Client"><a href="#2、FileZilla-FTP-Client" class="headerlink" title="2、FileZilla FTP Client"></a>2、FileZilla FTP Client</h2><p>FileZilla用于从Windows上传文件到服务器。</p><h3 id="下载、安装FileZilla"><a href="#下载、安装FileZilla" class="headerlink" title="下载、安装FileZilla"></a>下载、安装FileZilla</h3><p>直接官网下载安装</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>输入sftp://ip，username，password（端口若无修改可以不填）</p><h1 id="四、安装java-Web环境"><a href="#四、安装java-Web环境" class="headerlink" title="四、安装java Web环境"></a>四、安装java Web环境</h1><hr><h2 id="1、安装JDK并配置环境变量"><a href="#1、安装JDK并配置环境变量" class="headerlink" title="1、安装JDK并配置环境变量"></a>1、安装JDK并配置环境变量</h2><h3 id="查看当前系统是否安装过JDK："><a href="#查看当前系统是否安装过JDK：" class="headerlink" title="查看当前系统是否安装过JDK："></a>查看当前系统是否安装过JDK：</h3><p><code>rpm -qa|grep java</code>（某些系统默认安装了JDK1.7）</p><h3 id="如果有JDK，卸载："><a href="#如果有JDK，卸载：" class="headerlink" title="如果有JDK，卸载："></a>如果有JDK，卸载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-4ojpp.155</div><div class="line">yum -y remove java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</div></pre></td></tr></table></figure><h3 id="上传并解压安装包："><a href="#上传并解压安装包：" class="headerlink" title="上传并解压安装包："></a>上传并解压安装包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local</div><div class="line">mkdir jdk_home tomcat_home soft</div></pre></td></tr></table></figure><p>通过Filezilla上传tar.gz压缩包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd soft</div><div class="line">tar -xvf jdk-8u144-linux-x64.tar.gz -C /usr/local/jdk_home</div></pre></td></tr></table></figure></p><h3 id="配置JDK环境变量："><a href="#配置JDK环境变量：" class="headerlink" title="配置JDK环境变量："></a>配置JDK环境变量：</h3><ul><li>打开文件：<code>vi /etc/profile</code>  </li><li><p>将下列内容追加到末尾：</p><blockquote><p>#set java environment<br>  JAVA_HOME=/usr/local/jdk_home/jdk1.8<br>  CLASSPATH=.:$JAVA_HOME/lib/tools.jar<br>  PATH=$JAVA_HOME/bin:$PATH<br>  export JAVA_HOME CLASSPATH PATH  </p></blockquote></li><li><p>使文件生效：<code>source /etc/profile</code></p></li></ul><h3 id="查看java版本："><a href="#查看java版本：" class="headerlink" title="查看java版本："></a>查看java版本：</h3><p><code>java-version</code></p><h2 id="2、安装MySQL并配置"><a href="#2、安装MySQL并配置" class="headerlink" title="2、安装MySQL并配置"></a>2、安装MySQL并配置</h2><h3 id="mysql的安装"><a href="#mysql的安装" class="headerlink" title="mysql的安装"></a>mysql的安装</h3><blockquote><p>yum install mysql<br>yum install mysql-devel<br>yum install mysql-server（会出错）</p></blockquote><p><strong>CentOS 7将MySQL从默认的程序列表中移除，用mariadb代替了。</strong></p><h3 id="官网下载安装mysql-server"><a href="#官网下载安装mysql-server" class="headerlink" title="官网下载安装mysql-server"></a>官网下载安装mysql-server</h3><blockquote><p>wget <a href="http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm" target="_blank" rel="external">http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</a><br>rpm -ivh mysql-community-release-el7-5.noarch.rpm<br>yum install mysql-community-server</p></blockquote><h3 id="安装成功后重启mysql服务"><a href="#安装成功后重启mysql服务" class="headerlink" title="安装成功后重启mysql服务"></a>安装成功后重启mysql服务</h3><p><code>service mysqld restart</code></p><h3 id="初次安装mysql，root账号没有密码"><a href="#初次安装mysql，root账号没有密码" class="headerlink" title="初次安装mysql，root账号没有密码"></a>初次安装mysql，root账号没有密码</h3><p><code>mysql -u root</code><br>设置密码：<code>set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;root&#39;);</code></p><h3 id="安装完后mariadb自动被替换了，将不再生效"><a href="#安装完后mariadb自动被替换了，将不再生效" class="headerlink" title="安装完后mariadb自动被替换了，将不再生效"></a>安装完后mariadb自动被替换了，将不再生效</h3><p><code>rpm -qa |grep mariadb</code></p><h3 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h3><ul><li><p>编码：<br>打开mysql配置文件：<code>vi /etc/my.cnf</code><br>在最后追加编码配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysql]  </div><div class="line">default-character-set =utf8</div></pre></td></tr></table></figure></li><li><p>远程连接设置：</p><blockquote><p>把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户：<br><code>mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;root&#39;;</code><br>如果是新用户而不是root，则要先新建用户:<br><code>mysql&gt; create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;;</code></p></blockquote></li></ul><h3 id="测试mysql启动停止"><a href="#测试mysql启动停止" class="headerlink" title="测试mysql启动停止"></a>测试mysql启动停止</h3><p><code>service mysqld start/stop</code></p><p><code>mysql的安装就到这里了，附上一个[详细说明](http://www.cnblogs.com/starof/p/4680083.html)。</code></p><h2 id="3、安装Tomcat并配置"><a href="#3、安装Tomcat并配置" class="headerlink" title="3、安装Tomcat并配置"></a>3、安装Tomcat并配置</h2><h3 id="解析Tomact"><a href="#解析Tomact" class="headerlink" title="解析Tomact"></a>解析Tomact</h3><blockquote><p>解压：tar -xvf apache-tomcat-9.0.0.M26.tar.gz -C /usr/local/tomcat_home；<br>重命名：mv apache-tomcat-9.0…. tomcat9</p></blockquote><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><blockquote><p><code>vi /etc/profile</code><br>在文件最后追加配置：<br> #tomcat evn<br> CATALINA_HOME=/usr/local/tomcat_home/tomcat9<br> export CATALINA_HOME</p></blockquote><h3 id="配置tomcat的catalina-sh文件"><a href="#配置tomcat的catalina-sh文件" class="headerlink" title="配置tomcat的catalina.sh文件"></a>配置tomcat的catalina.sh文件</h3><blockquote><p>cd $CATALINA_HOME/bin<br>vi catalina.sh<br>找到 # OS specific support，然后在这行下面添加以下配置：<br>CATALINA_HOME=/usr/local/tomcat_home/tomcat9<br>JAVA_HOME=/usr/local/jdk_home/jdk1.8</p></blockquote><h3 id="安装tomcat服务"><a href="#安装tomcat服务" class="headerlink" title="安装tomcat服务"></a>安装tomcat服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $CATALINA_HOME/bin</div><div class="line">cp catalina.sh /etc/init.d/tomcat</div></pre></td></tr></table></figure><h3 id="测试tomcat的启动和停用"><a href="#测试tomcat的启动和停用" class="headerlink" title="测试tomcat的启动和停用"></a>测试tomcat的启动和停用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service tomcat start</div><div class="line">service tomcat stop</div></pre></td></tr></table></figure><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a><a href="http://blog.csdn.net/u011846257/article/details/54707864" target="_blank" rel="external">防火墙配置</a></h3><p><code>到这里Tomcat环境就已经搭建完成了，附上[参考文档](http://www.jianshu.com/p/b71296e8b9a7)。</code></p><h1 id="五、更多配置"><a href="#五、更多配置" class="headerlink" title="五、更多配置"></a>五、更多配置</h1><hr><p>这里只是简单地在阿里云的云服务器上搭建了java Web环境，其他的一些配置就需要以后有需求或者遇到困难的时候解决。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
