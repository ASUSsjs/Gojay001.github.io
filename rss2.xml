<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>大迷毛|成长录</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>学习 思考 沉淀</description>
    <pubDate>Wed, 29 Nov 2017 09:18:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>跟我学Shiro（六）-Realm及相关对象</title>
      <link>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%85%AD%EF%BC%89-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/</link>
      <guid>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%85%AD%EF%BC%89-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/</guid>
      <pubDate>Wed, 29 Nov 2017 09:10:58 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Realm&quot;&gt;&lt;a href=&quot;#Realm&quot; class=&quot;headerlink&quot; title=&quot;Realm&quot;&gt;&lt;/a&gt;Realm&lt;/h1&gt;&lt;h2 id=&quot;定义实体及关系&quot;&gt;&lt;a href=&quot;#定义实体及关系&quot; class=&quot;headerlink&quot; title=&quot;定义实体及关系&quot;&gt;&lt;/a&gt;定义实体及关系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-1.png&quot; alt=&quot;跟我学Shiro（六）-Realm及相关对象/6-1.png&quot;&gt;&lt;br&gt;&lt;strong&gt;用户-角色&lt;/strong&gt;之间是多对多关系，&lt;strong&gt;角色-权限&lt;/strong&gt;之间是多对多关系；且&lt;code&gt;用户&lt;/code&gt;和&lt;code&gt;权限&lt;/code&gt;之间通过&lt;code&gt;角色&lt;/code&gt;建立关系。&lt;br&gt;在系统中验证时通过&lt;code&gt;权限验证&lt;/code&gt;，角色只是权限集合，即所谓的显式角色。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户&lt;/strong&gt;实体包括：编号&lt;code&gt;id&lt;/code&gt;、用户名&lt;code&gt;username&lt;/code&gt;、密码&lt;code&gt;password&lt;/code&gt;、盐&lt;code&gt;salt&lt;/code&gt;、是否锁定&lt;code&gt;locked&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;角色&lt;/strong&gt;实体包括：、编号&lt;code&gt;id&lt;/code&gt;、角色标识符&lt;code&gt;role&lt;/code&gt;、描述&lt;code&gt;description&lt;/code&gt;、是否可用&lt;code&gt;available&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权限&lt;/strong&gt;实体包括：编号&lt;code&gt;id&lt;/code&gt;、权限标识符&lt;code&gt;permission&lt;/code&gt;、描述&lt;code&gt;description&lt;/code&gt;、是否可用&lt;code&gt;available&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外还有两个&lt;strong&gt;关系实体&lt;/strong&gt;：&lt;br&gt;&lt;strong&gt;用户-角色&lt;/strong&gt;实体：用户编号、角色编号，且组合为复合主键）；&lt;br&gt;&lt;strong&gt;角色-权限&lt;/strong&gt;实体：角色编号、权限编号，且组合为复合主键）。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><h2 id="定义实体及关系"><a href="#定义实体及关系" class="headerlink" title="定义实体及关系"></a>定义实体及关系</h2><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-1.png" alt="跟我学Shiro（六）-Realm及相关对象/6-1.png"><br><strong>用户-角色</strong>之间是多对多关系，<strong>角色-权限</strong>之间是多对多关系；且<code>用户</code>和<code>权限</code>之间通过<code>角色</code>建立关系。<br>在系统中验证时通过<code>权限验证</code>，角色只是权限集合，即所谓的显式角色。</p><ul><li><strong>用户</strong>实体包括：编号<code>id</code>、用户名<code>username</code>、密码<code>password</code>、盐<code>salt</code>、是否锁定<code>locked</code>；</li><li><strong>角色</strong>实体包括：、编号<code>id</code>、角色标识符<code>role</code>、描述<code>description</code>、是否可用<code>available</code>；</li><li><strong>权限</strong>实体包括：编号<code>id</code>、权限标识符<code>permission</code>、描述<code>description</code>、是否可用<code>available</code>。</li></ul><blockquote><p>另外还有两个<strong>关系实体</strong>：<br><strong>用户-角色</strong>实体：用户编号、角色编号，且组合为复合主键）；<br><strong>角色-权限</strong>实体：角色编号、权限编号，且组合为复合主键）。</p></blockquote><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>为了方便数据库操作，使用 <code>org.springframework: spring-jdbc: 4.0.0.RELEASE</code> 依赖。</p><h3 id="定义Service及Dao"><a href="#定义Service及Dao" class="headerlink" title="定义Service及Dao"></a>定义Service及Dao</h3><blockquote><p>为了实现的简单性，只实现必须的功能，其他的可以自己实现即可。</p></blockquote><h4 id="PermissionService"><a href="#PermissionService" class="headerlink" title="PermissionService"></a>PermissionService</h4><p>实现基本的<strong>创建/删除</strong>权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface PermissionService &#123;  </div><div class="line">    public Permission createPermission(Permission permission);  </div><div class="line">    public void deletePermission(Long permissionId);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="RoleService"><a href="#RoleService" class="headerlink" title="RoleService"></a>RoleService</h4><p>相对于PermissionService多了<strong>关联/移除关联角色-权限</strong>功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface RoleService &#123;  </div><div class="line">    public Role createRole(Role role);  </div><div class="line">    public void deleteRole(Long roleId);  </div><div class="line">    // 添加角色-权限之间关系  </div><div class="line">    public void correlationPermissions(Long roleId, Long... permissionIds);  </div><div class="line">    // 移除角色-权限之间关系  </div><div class="line">    public void uncorrelationPermissions(Long roleId, Long... permissionIds);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h4><p>使用 <strong>findByUsername</strong> 、 <strong>findRoles</strong> 及 <strong>findPermissions</strong> 来查找用户名对应的帐号、角色及权限信息。  </p><blockquote><p>之后的Realm就使用这些方法来查找相关信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface UserService &#123;  </div><div class="line">    // 创建账户</div><div class="line">    public User createUser(User user);   </div><div class="line">    // 修改密码</div><div class="line">    public void changePassword(Long userId, String newPassword);  </div><div class="line">    // 添加用户-角色关系</div><div class="line">    public void correlationRoles(Long userId, Long... roleIds);   </div><div class="line">    // 移除用户-角色关系</div><div class="line">    public void uncorrelationRoles(Long userId, Long... roleIds);  </div><div class="line">    // 根据用户名查找用户</div><div class="line">    public User findByUsername(String username);  </div><div class="line">    // 根据用户名查找其角色</div><div class="line">    public Set&lt;String&gt; findRoles(String username); </div><div class="line">    // 根据用户名查找其权限  </div><div class="line">    public Set&lt;String&gt; findPermissions(String username); </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="UserServiceImpl"><a href="#UserServiceImpl" class="headerlink" title="UserServiceImpl"></a>UserServiceImpl</h4><p>在创建账户及修改密码时直接把<strong>生成密码操作</strong>委托给 <code>PasswordHelper</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public User createUser(User user) &#123;  </div><div class="line">    // 加密密码  </div><div class="line">    passwordUtils.encryptPassword(user);  </div><div class="line">    return userDao.createUser(user);  </div><div class="line">&#125;  </div><div class="line">public void changePassword(Long userId, String newPassword) &#123;  </div><div class="line">    User user =userDao.findOne(userId);  </div><div class="line">    user.setPassword(newPassword);  </div><div class="line">    passwordUtils.encryptPassword(user);  </div><div class="line">    userDao.updateUser(user);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="PasswordUtils"><a href="#PasswordUtils" class="headerlink" title="PasswordUtils"></a>PasswordUtils</h4><p>之后的CredentialsMatcher需要和此处加密的算法一样。<br>user.getCredentialsSalt()辅助方法返回username+salt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class PasswordUtils &#123;  </div><div class="line">    private RandomNumberGenerator randomNumberGenerator =  </div><div class="line">     new SecureRandomNumberGenerator();  </div><div class="line">    private String algorithmName = &quot;md5&quot;;  </div><div class="line">    private final int hashIterations = 2;  </div><div class="line">    public void encryptPassword(User user) &#123;  </div><div class="line">        user.setSalt(randomNumberGenerator.nextBytes().toHex());  </div><div class="line">        String newPassword = new SimpleHash(  </div><div class="line">                algorithmName,  </div><div class="line">                user.getPassword(),  </div><div class="line">                ByteSource.Util.bytes(user.getCredentialsSalt()),  </div><div class="line">                hashIterations).toHex();  </div><div class="line">        user.setPassword(newPassword);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>为了节省篇幅，对于<strong>DAO/Service</strong>的接口及实现，具体请参考源码 <code>com.github.gojay001</code> ；<br>另外参考Service层的测试用例 <code>com.github.gojay001.service.ServiceTest</code> 。</p></blockquote><h3 id="定义Realm"><a href="#定义Realm" class="headerlink" title="定义Realm"></a>定义Realm</h3><h4 id="RetryLimitHashedCredentialsMatcher"><a href="#RetryLimitHashedCredentialsMatcher" class="headerlink" title="RetryLimitHashedCredentialsMatcher"></a>RetryLimitHashedCredentialsMatcher</h4><blockquote><p>com.github.gojay001.credentials</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher &#123;</div><div class="line"></div><div class="line">    private Ehcache passwordRetryCache;</div><div class="line"></div><div class="line">    public RetryLimitHashedCredentialsMatcher() &#123;</div><div class="line">        CacheManager cacheManager = CacheManager.newInstance(CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;));</div><div class="line">        passwordRetryCache = cacheManager.getCache(&quot;passwordRetryCache&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">        String username = (String)token.getPrincipal();</div><div class="line">        // retry count + 1</div><div class="line">        Element element = passwordRetryCache.get(username);</div><div class="line">        if(element == null) &#123;</div><div class="line">            element = new Element(username , new AtomicInteger(0));</div><div class="line">            passwordRetryCache.put(element);</div><div class="line">        &#125;</div><div class="line">        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();</div><div class="line">        if(retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">            // if retry count &gt; 5 throw</div><div class="line">            throw new ExcessiveAttemptsException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean matches = super.doCredentialsMatch(token, info);</div><div class="line">        if(matches) &#123;</div><div class="line">            // clear retry count</div><div class="line">            passwordRetryCache.remove(username);</div><div class="line">        &#125;</div><div class="line">        return matches;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="UserRealm"><a href="#UserRealm" class="headerlink" title="UserRealm"></a>UserRealm</h4><blockquote><p>com.github.gojay001.realm</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class UserRealm extends AuthorizingRealm &#123;</div><div class="line">    private UserService userService = new UserServiceImpl();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">        String username = (String)principals.getPrimaryPrincipal();</div><div class="line"></div><div class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">        authorizationInfo.setRoles(userService.findRoles(username));</div><div class="line">        authorizationInfo.setStringPermissions(userService.findPermissions(username));</div><div class="line"></div><div class="line">        return authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line"></div><div class="line">        String username = (String)token.getPrincipal();</div><div class="line"></div><div class="line">        User user = userService.findByUsername(username);</div><div class="line"></div><div class="line">        //没找到帐号</div><div class="line">        if(user == null) &#123;</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //帐号锁定</div><div class="line">        if(Boolean.TRUE.equals(user.getLocked())) &#123;</div><div class="line">            throw new LockedAccountException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现</div><div class="line">        return new SimpleAuthenticationInfo(</div><div class="line">                user.getUsername(),</div><div class="line">                user.getPassword(),</div><div class="line">                // salt=username+salt</div><div class="line">                ByteSource.Util.bytes(user.getCredentialsSalt()),</div><div class="line">                //realm name</div><div class="line">                getName()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><strong>UserRealm父类AuthorizingRealm将获取Subject相关信息分成两步</strong>：获取身份验证信息 <code>doGetAuthenticationInfo</code> 及授权信息 <code>doGetAuthorizationInfo</code> ；</li><li><strong>doGetAuthenticationInfo</strong>：首先根据传入的用户名获取User信息；在组装SimpleAuthenticationInfo信息时，需要传入：身份信息<code>用户名</code>、凭据<code>密文密码</code>、盐<code>username+salt</code>， <em>CredentialsMatcher</em> 使用盐加密传入的明文密码和此处的密文密码进行匹配。</li><li><strong>doGetAuthorizationInfo</strong>：<code>PrincipalCollection</code> 是一个身份集合，因为我们现在就一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的<code>用户名</code>即可；然后根据用户名<code>调用UserService接口</code>获取角色及权限信息。</li></ul><h1 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-2.png" alt="跟我学Shiro（六）-Realm及相关对象/6-2.png"><br><strong>AuthenticationToken</strong>用于收集用户提交的身份 <code>用户名</code> 及凭据 <code>密码</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AuthenticationToken extends Serializable &#123;  </div><div class="line">    Object getPrincipal(); </div><div class="line">    Object getCredentials(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li><strong>RememberMeAuthenticationToken</strong>：提供了 <code>boolean isRememberMe()</code> <strong>记住我</strong>的功能；</li><li><strong>HostAuthenticationToken</strong>：提供了 <code>String getHost()</code> 方法用于获取用户<strong>主机</strong>的功能。</li></ul><blockquote><p>Shiro提供了一个直接拿来用的<strong>UsernamePasswordToken</strong>，用于实现用户名/密码Token组。实现了 <code>RememberMeAuthenticationToken</code> 和 <code>HostAuthenticationToken</code> ，可以实现记住我及主机验证的支持。</p></blockquote><h1 id="AuthenticationInfo"><a href="#AuthenticationInfo" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-3.png" alt="跟我学Shiro（六）-Realm及相关对象/6-3.png"><br><strong>AuthenticationInfo</strong>有两个作用：</p><ul><li>如果Realm是 <code>AuthenticatingRealm</code> 子类，则提供给 <code>AuthenticatingRealm</code> 内部使用的 <code>CredentialsMatcher</code> 进行凭据验证；（如果没有继承它需要在自己的Realm中自己实现验证）。</li><li>提供给 <code>SecurityManager</code> 来创建 <code>Subject</code> （提供身份信息）。</li></ul><blockquote><p><strong>MergableAuthenticationInfo</strong>用于提供在多Realm时<code>合并AuthenticationInfo的功能</code>，主要合并Principal。<br>比如 <code>HashedCredentialsMatcher</code> ，在验证时会判断 <code>AuthenticationInfo</code> 是否是<strong>SaltedAuthenticationInfo</strong>子类，来获取盐信息。<br><strong>Account</strong>相当于我们之前的 <code>User</code> ， <code>SimpleAccount</code> 是其一个实现。<br>其他情况一般返回<strong>SimpleAuthenticationInfo</strong>即可。</p></blockquote><h1 id="PrincipalCollection"><a href="#PrincipalCollection" class="headerlink" title="PrincipalCollection"></a>PrincipalCollection</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-4.png" alt="跟我学Shiro（六）-Realm及相关对象/6-4.png"><br>因为我们可以在Shiro中同时配置多个Realm，所以身份信息可能就有多个；因此其提供了<strong>PrincipalCollection</strong>用于<code>聚合这些身份信息</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface PrincipalCollection extends Iterable, Serializable &#123;  </div><div class="line">    // 得到主要的身份</div><div class="line">    Object getPrimaryPrincipal();   </div><div class="line">    // 根据身份类型获取第一个</div><div class="line">    &lt;T&gt; T oneByType(Class&lt;T&gt; type);   </div><div class="line">    // 根据身份类型获取一组</div><div class="line">    &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type);   </div><div class="line">    // 转换为List</div><div class="line">    List asList();   </div><div class="line">    // 转换为Set</div><div class="line">    Set asSet();</div><div class="line">    // 根据Realm名字获取</div><div class="line">    Collection fromRealm(String realmName);   </div><div class="line">    // 获取所有身份验证通过的Realm名字</div><div class="line">    Set&lt;String&gt; getRealmNames();   </div><div class="line">    // 判断是否为空</div><div class="line">    boolean isEmpty();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p><strong>getPrimaryPrincipal</strong>：如果只有一个Principal那么直接返回即可，如果有多个Principal，则返回第一个（因为内部使用Map存储，所以可以认为是返回任意一个）；<br><strong>oneByType/byType</strong>：根据<code>凭据的类型</code>返回相应的Principal；<br><strong>fromRealm</strong>根据<code>Realm名字</code>（每个Principal都与一个Realm关联）获取相应的Principal。</p></blockquote><p><strong>MutablePrincipalCollection</strong>是一个可变的PrincipalCollection接口，即提供了如下可变方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface MutablePrincipalCollection extends PrincipalCollection &#123;  </div><div class="line">    // 添加Realm-Principal的关联</div><div class="line">    void add(Object principal, String realmName);   </div><div class="line">    // 添加一组Realm-Principal的关联</div><div class="line">    void addAll(Collection principals, String realmName);</div><div class="line">    // 添加PrincipalCollection</div><div class="line">    void addAll(PrincipalCollection principals);</div><div class="line">    // 清空</div><div class="line">    void clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="AuthorizationInfo"><a href="#AuthorizationInfo" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-5.png" alt="跟我学Shiro（六）-Realm及相关对象/6-5.png"><br><strong>AuthorizationInfo</strong>用于<code>聚合授权信息</code>的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface AuthorizationInfo extends Serializable &#123;  </div><div class="line">    // 获取角色字符串信息</div><div class="line">    Collection&lt;String&gt; getRoles();</div><div class="line">    // 获取权限字符串信息</div><div class="line">    Collection&lt;String&gt; getStringPermissions(); </div><div class="line">    // 获取Permission对象信息</div><div class="line">    Collection&lt;Permission&gt; getObjectPermissions(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>当我们使用 <code>AuthorizingRealm</code> 时，如果身份验证成功，在进行授权时就通过 <code>doGetAuthorizationInfo</code> 方法获取角色/权限信息用于授权验证。  </p><blockquote><p>Shiro提供了一个实现 <strong>SimpleAuthorizationInfo</strong> ，大多数时候使用这个即可。</p></blockquote><h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-6.png" alt="跟我学Shiro（六）-Realm及相关对象/6-6.png"><br><strong>Subject</strong>是Shiro的核心对象，基本所有<code>身份验证</code>、<code>授权</code>都是通过Subject完成。</p><h2 id="身份信息获取"><a href="#身份信息获取" class="headerlink" title="身份信息获取"></a>身份信息获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Primary Principal</div><div class="line">Object getPrincipal(); </div><div class="line">// PrincipalCollection</div><div class="line">PrincipalCollection getPrincipals();</div></pre></td></tr></table></figure><h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void login(AuthenticationToken token) throws AuthenticationException;  </div><div class="line">boolean isAuthenticated();  </div><div class="line">boolean isRemembered();</div></pre></td></tr></table></figure><h2 id="角色授权验证"><a href="#角色授权验证" class="headerlink" title="角色授权验证"></a>角色授权验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">boolean hasRole(String roleIdentifier);  </div><div class="line">boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);  </div><div class="line">boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);  </div><div class="line">void checkRole(String roleIdentifier) throws AuthorizationException;  </div><div class="line">void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;  </div><div class="line">void checkRoles(String... roleIdentifiers) throws AuthorizationException;</div></pre></td></tr></table></figure><h2 id="权限授权验证"><a href="#权限授权验证" class="headerlink" title="权限授权验证"></a>权限授权验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">boolean isPermitted(String permission);  </div><div class="line">boolean isPermitted(Permission permission);  </div><div class="line">boolean[] isPermitted(String... permissions);  </div><div class="line">boolean[] isPermitted(List&lt;Permission&gt; permissions);  </div><div class="line">boolean isPermittedAll(String... permissions);  </div><div class="line">boolean isPermittedAll(Collection&lt;Permission&gt; permissions);  </div><div class="line">void checkPermission(String permission) throws AuthorizationException;  </div><div class="line">void checkPermission(Permission permission) throws AuthorizationException;  </div><div class="line">void checkPermissions(String... permissions) throws AuthorizationException;  </div><div class="line">void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;</div></pre></td></tr></table></figure><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 相当于getSession(true)</div><div class="line">Session getSession(); </div><div class="line">Session getSession(boolean create);</div></pre></td></tr></table></figure><blockquote><p>如果 <code>create=false</code> 如果没有会话将<code>返回null</code>；而 <code>create=true</code> 如果没有会话会强制<code>创建一个</code>。</p></blockquote><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void logout();</div></pre></td></tr></table></figure><h2 id="RunAs"><a href="#RunAs" class="headerlink" title="RunAs"></a>RunAs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;  </div><div class="line">boolean isRunAs();  </div><div class="line">PrincipalCollection getPreviousPrincipals();  </div><div class="line">PrincipalCollection releaseRunAs();</div></pre></td></tr></table></figure><p><strong>RunAs</strong>即实现<strong>允许A假设为B身份进行访问</strong>：  </p><blockquote><p>通过调用 <code>subject.runAs(b)</code> 进行访问；<br>接着调用 <code>subject.getPrincipals</code> 将获取到B的身份；<br>此时调用 <code>isRunAs</code> 将返回true，而a的身份需要通过 <code>subject.getPreviousPrincipals</code> 获取；<br>如果不需要RunAs了调用 <code>subject.releaseRunAs</code> 即可。</p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;  </div><div class="line">void execute(Runnable runnable);  </div><div class="line">&lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);  </div><div class="line">Runnable associateWith(Runnable runnable);</div></pre></td></tr></table></figure><blockquote><p>在多线程执行中需要传播到相应的线程才能获取到相应的Subject。<br>最简单的办法就是通过 <code>execute(runnable/callable实例)</code> 直接调用；<br>或者通过 <code>associateWith(runnable/callable实例)</code> 得到一个包装后的实例；<br>它们都是通过：把当前线程的Subject绑定过去；在线程执行结束后自动释放。</p></blockquote><p>Subject自己不会实现相应的身份验证/授权逻辑，而是通过DelegatingSubject委托给SecurityManager实现。</p><p>如果想自定义创建，可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Subject.Builder().principals(身份).authenticated(true/false).buildSubject()</div></pre></td></tr></table></figure></p><h2 id="Subject一般流程"><a href="#Subject一般流程" class="headerlink" title="Subject一般流程"></a>Subject一般流程</h2><ul><li><strong>身份验证</strong>（login）</li><li><strong>授权</strong>（hasRole*/isPermitted*或checkRole*/checkPermission*）</li><li>将相应的数据存储到<strong>会话</strong>（Session）</li><li><strong>切换身份</strong>（RunAs）/<strong>多线程</strong>身份传播</li><li><strong>退出</strong></li></ul><blockquote><p>必须的功能就是1、2、5。到目前为止我们就可以使用Shiro进行应用程序的安全控制了，但是还是缺少如对Web验证、Java方法验证等的一些简化实现。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h2><ul><li>Permission</li><li>Role</li><li>User</li><li>User-Role</li><li>Role-Permission</li></ul><h2 id="AuthenticationToken-1"><a href="#AuthenticationToken-1" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h2><ul><li>Principal</li><li>Credentials</li><li>RemeberMeAuthenticationToken</li><li>HostAuthenticationToken</li><li>UsernamePasswordToken</li></ul><h2 id="AuthenticationInfo-1"><a href="#AuthenticationInfo-1" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h2><ul><li>提供身份信息</li><li>提供凭据验证</li><li>SimpleAuthenticationInfo</li></ul><h2 id="PrincipalCollection-1"><a href="#PrincipalCollection-1" class="headerlink" title="PrincipalCollection"></a>PrincipalCollection</h2><ul><li>Principal</li><li>MutablePrincipalCollection</li><li>PrincipalMap</li></ul><h2 id="AuthorizationInfo-1"><a href="#AuthorizationInfo-1" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h2><ul><li>Roles</li><li>StringPermissions</li><li>ObjectPermissions</li><li>SimpleAuthorizationInfo</li></ul><h2 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h2><ul><li>身份获取</li><li>身份验证</li><li>角色授权</li><li>权限授权</li><li>会话</li><li>退出</li><li>RunAs</li><li>多线程</li></ul><blockquote><p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter6</code></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%85%AD%EF%BC%89-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（五）-编码、加密</title>
      <link>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86/</link>
      <guid>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86/</guid>
      <pubDate>Wed, 29 Nov 2017 03:01:10 GMT</pubDate>
      <description>
      
        &lt;p&gt;在涉及到&lt;strong&gt;密码存储&lt;/strong&gt;问题上，应该加密/生成密码摘要存储，而不是存储明文密码。&lt;/p&gt;
&lt;h1 id=&quot;编码-解码&quot;&gt;&lt;a href=&quot;#编码-解码&quot; class=&quot;headerlink&quot; title=&quot;编码/解码&quot;&gt;&lt;/a&gt;编码/解码&lt;/h1&gt;&lt;p&gt;Shiro提供了 &lt;strong&gt;base64&lt;/strong&gt; 和 &lt;strong&gt;16进制字符串&lt;/strong&gt; 编码/解码的API支持，方便一些编码解码操作。Shiro内部的一些数据的存储/表示都使用了base64和16进制字符串。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String str = &amp;quot;hello&amp;quot;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String base64Encoded = Base64.encodeToString(str.getBytes());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String str2 = Base64.decodeToString(base64Encoded);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Assert.assertEquals(str, str2);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过如上方式可以进行&lt;code&gt;base64编码/解码&lt;/code&gt;操作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;String str = &amp;quot;hello&amp;quot;;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String base64Encoded = Hex.encodeToString(str.getBytes());  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;String str2 = new String(Hex.decode(base64Encoded.getBytes()));  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Assert.assertEquals(str, str2);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过如上方式可以进行&lt;code&gt;16进制字符串编码/解码&lt;/code&gt;操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;还有一个可能经常用到的类&lt;code&gt;CodecSupport&lt;/code&gt;，提供了&lt;code&gt;toBytes(str, &amp;quot;utf-8&amp;quot;)&lt;/code&gt; / &lt;code&gt;toString(bytes, &amp;quot;utf-8&amp;quot;)&lt;/code&gt;用于在byte数组/String之间转换。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在涉及到<strong>密码存储</strong>问题上，应该加密/生成密码摘要存储，而不是存储明文密码。</p><h1 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码/解码"></a>编码/解码</h1><p>Shiro提供了 <strong>base64</strong> 和 <strong>16进制字符串</strong> 编码/解码的API支持，方便一些编码解码操作。Shiro内部的一些数据的存储/表示都使用了base64和16进制字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String base64Encoded = Base64.encodeToString(str.getBytes());  </div><div class="line">String str2 = Base64.decodeToString(base64Encoded);  </div><div class="line">Assert.assertEquals(str, str2);</div></pre></td></tr></table></figure></p><p>通过如上方式可以进行<code>base64编码/解码</code>操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());  </div><div class="line">String str2 = new String(Hex.decode(base64Encoded.getBytes()));  </div><div class="line">Assert.assertEquals(str, str2);</div></pre></td></tr></table></figure></p><p>通过如上方式可以进行<code>16进制字符串编码/解码</code>操作。</p><blockquote><p>还有一个可能经常用到的类<code>CodecSupport</code>，提供了<code>toBytes(str, &quot;utf-8&quot;)</code> / <code>toString(bytes, &quot;utf-8&quot;)</code>用于在byte数组/String之间转换。</p></blockquote><a id="more"></a><h1 id="散列（Hash）算法"><a href="#散列（Hash）算法" class="headerlink" title="散列（Hash）算法"></a>散列（Hash）算法</h1><p><strong>散列算法</strong>一般用于<code>生成数据的摘要信息</code>，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如MD5、SHA等。</p><p>一般进行散列时最好提供一个<code>salt</code>（盐），如用户名和ID（即盐）；这样散列的对象是“密码+用户名+ID”，这样生成的散列值相对来说更难破解。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">String md5 = new Md5Hash(str, salt).toString();//还可以转换为 toBase64()/toHex()</div></pre></td></tr></table></figure><p>如上代码使用<code>MD5算法</code>通过盐“123”生成MD5散列。<br>另外散列时还可以指定散列次数，如2次表示：md5(md5(str))：<br><code>new Md5Hash(str, salt, 2).toString()</code>。</p><h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString();</div></pre></td></tr></table></figure><p>使用<code>SHA256算法</code>生成相应的散列数据，另外还有如SHA1、SHA512算法。</p><h2 id="通用的散列支持"><a href="#通用的散列支持" class="headerlink" title="通用的散列支持"></a>通用的散列支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">//内部使用MessageDigest  </div><div class="line">String simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString();</div></pre></td></tr></table></figure><p>通过调用 <code>SimpleHash</code> 时指定散列算法，其内部使用了Java的 <code>MessageDigest</code> 实现。</p><p>为了方便使用，Shiro提供了 <code>HashService</code> ，默认提供了 <code>DefaultHashService</code> 实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 默认算法SHA-512</div><div class="line">DefaultHashService hashService = new DefaultHashService(); </div><div class="line">hashService.setHashAlgorithmName(&quot;SHA-512&quot;);</div><div class="line">// 私盐，默认无</div><div class="line">hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); </div><div class="line">// 是否生成公盐，默认false</div><div class="line">hashService.setGeneratePublicSalt(true);</div><div class="line">// 用于生成公盐。默认就这个</div><div class="line">hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator());</div><div class="line">// 生成Hash值的迭代次数</div><div class="line">hashService.setHashIterations(1); </div><div class="line">  </div><div class="line">HashRequest request = new HashRequest.Builder()  </div><div class="line">            .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;))  </div><div class="line">            .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build();  </div><div class="line">String hex = hashService.computeHash(request).toHex();</div></pre></td></tr></table></figure></p><ul><li>首先创建一个 <code>DefaultHashService</code> ，默认使用<code>SHA-512算法</code>；</li><li>可以通过 <code>hashAlgorithmName</code> 属性修改算法；</li><li>可以通过 <code>privateSalt</code> 设置一个<code>私盐</code>，其在散列时自动与用户传入的公盐混合产生一个新盐；</li><li>可以通过 <code>generatePublicSalt</code> 属性在用户没有传入公盐的情况下是否生成<code>公盐</code>；</li><li>可以设置 <code>randomNumberGenerator</code> 用于生成<code>公盐</code>；</li><li>可以设置 <code>hashIterations</code> 属性来修改默认加密<code>迭代次数</code>；</li><li>需要构建一个 <code>HashRequest</code> ，传入算法、数据、公盐、迭代次数。</li></ul><p>SecureRandomNumberGenerator用于<strong>生成一个随机数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SecureRandomNumberGenerator randomNumberGenerator =  </div><div class="line">     new SecureRandomNumberGenerator();  </div><div class="line">randomNumberGenerator.setSeed(&quot;123&quot;.getBytes());  </div><div class="line">String hex = randomNumberGenerator.nextBytes().toHex();</div></pre></td></tr></table></figure></p><h1 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h1><p>Shiro提供<strong>对称式加密/解密算法</strong>的支持，如AES、Blowfish等。<br>当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p><h2 id="AES算法实现"><a href="#AES算法实现" class="headerlink" title="AES算法实现"></a>AES算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">// 设置key长度</div><div class="line">aesCipherService.setKeySize(128); </div><div class="line">//生成key  </div><div class="line">Key key = aesCipherService.generateNewKey();  </div><div class="line">String text = &quot;hello&quot;;  </div><div class="line">//加密  </div><div class="line">String encrptText =   </div><div class="line">aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();  </div><div class="line">//解密  </div><div class="line">String text2 =  </div><div class="line"> new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());  </div><div class="line">  </div><div class="line">Assert.assertEquals(text, text2);</div></pre></td></tr></table></figure><h1 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h1><p>Shiro提供了 <code>PasswordService</code> 及 <code>CredentialsMatcher</code> 用于提供<strong>加密</strong>密码及<strong>验证</strong>密码服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    // 输入明文密码得到密文密码</div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface CredentialsMatcher &#123;  </div><div class="line">    // 匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Shiro默认提供了<strong>PasswordService</strong>实现<code>DefaultPasswordService</code>；<strong>CredentialsMatcher</strong>实现<code>PasswordMatcher</code>及<code>HashedCredentialsMatcher</code>（更强大）。</p><h2 id="DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务"><a href="#DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务" class="headerlink" title="DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务"></a>DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务</h2><h3 id="定义Realm"><a href="#定义Realm" class="headerlink" title="定义Realm"></a>定义Realm</h3><blockquote><p>com.github.gojay001.relam.MyRealm</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyRealm extends AuthorizingRealm &#123;  </div><div class="line">    private PasswordService passwordService;  </div><div class="line">    public void setPasswordService(PasswordService passwordService) &#123;  </div><div class="line">        this.passwordService = passwordService;  </div><div class="line">    &#125;  </div><div class="line">     // 省略doGetAuthorizationInfo，具体看代码   </div><div class="line">    @Override  </div><div class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;  </div><div class="line">        return new SimpleAuthenticationInfo(  </div><div class="line">                &quot;root&quot;,  </div><div class="line">                passwordService.encryptPassword(&quot;root&quot;),  </div><div class="line">                getName());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>为了方便，直接注入一个<code>passwordService</code>来加密密码；实际使用时需要在<code>Service层</code>使用passwordService<code>加密</code>密码<code>并存储</code>到数据库。</p></blockquote><h3 id="INI配置"><a href="#INI配置" class="headerlink" title="INI配置"></a>INI配置</h3><blockquote><p>shiro-passwordservice.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">passwordService=org.apache.shiro.authc.credential.DefaultPasswordService  </div><div class="line">hashService=org.apache.shiro.crypto.hash.DefaultHashService  </div><div class="line">passwordService.hashService=$hashService  </div><div class="line">hashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat  </div><div class="line">passwordService.hashFormat=$hashFormat  </div><div class="line">hashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory  </div><div class="line">passwordService.hashFormatFactory=$hashFormatFactory  </div><div class="line">  </div><div class="line">passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcher  </div><div class="line">passwordMatcher.passwordService=$passwordService  </div><div class="line">  </div><div class="line">myRealm=com.github.gojay001.realm.MyRealm  </div><div class="line">myRealm.passwordService=$passwordService  </div><div class="line">myRealm.credentialsMatcher=$passwordMatcher  </div><div class="line">securityManager.realms=$myRealm</div></pre></td></tr></table></figure><ul><li><strong>passwordService</strong>使用<code>DefaultPasswordService</code>，如果有必要也可以自定义；</li><li><strong>hashService</strong>定义散列密码使用的HashService，默认使用<code>DefaultHashService</code>（默认SHA-256算法）；</li><li><strong>hashFormat</strong>用于对散列出的值进行格式化，默认使用<code>Shiro1CryptFormat</code>，另外提供了Base64Format和HexFormat，对于有salt的密码请<code>自定义实现</code>ParsableHashFormat然后把salt格式化到散列值中；</li><li><strong>hashFormatFactory</strong>用于根据散列值得到散列的密码和salt；因为如果使用如SHA算法，那么会生成一个salt，此salt需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用<code>DefaultHashFormatFactory</code>；</li><li><strong>passwordMatcher</strong>使用<code>PasswordMatcher</code>，其是一个CredentialsMatcher实现；</li><li>将<code>credentialsMatcher</code>赋值给<strong>myRealm</strong>，myRealm间接继承了AuthenticatingRealm，其在调用getAuthenticationInfo方法获取到AuthenticationInfo信息后，会使用credentialsMatcher来验证凭据是否匹配，如果不匹配将抛出IncorrectCredentialsException异常。</li></ul><blockquote><p>测试用例参考： <code>com.github.gojay001.test.PasswordTest</code> ，包含JdbcRealm测试用例。<br><strong>缺点</strong>：salt保存在散列值中，没有实现如密码重试次数限制。</p></blockquote><h2 id="HashedCredentialsMatcher实现密码验证服务"><a href="#HashedCredentialsMatcher实现密码验证服务" class="headerlink" title="HashedCredentialsMatcher实现密码验证服务"></a>HashedCredentialsMatcher实现密码验证服务</h2><p>Shiro提供了<strong>CredentialsMatcher</strong>的散列实现<code>HashedCredentialsMatcher</code>，和之前的PasswordMatcher不同的是，它只用于<code>密码验证</code>，且可以<code>提供自己的盐</code>，而不是随机生成盐，且生成密码散列值的算法需要自己写，因为能提供自己的盐。</p><h3 id="生成密码散列值"><a href="#生成密码散列值" class="headerlink" title="生成密码散列值"></a>生成密码散列值</h3><p>此处我们使用<code>MD5算法</code>，“密码+盐（用户名+随机数）”的方式生成散列值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String algorithmName = &quot;md5&quot;;  </div><div class="line">String username = &quot;root&quot;;  </div><div class="line">String password = &quot;root&quot;;  </div><div class="line">String salt1 = username;  </div><div class="line">String salt2 = new SecureRandomNumberGenerator().nextBytes().toHex();  </div><div class="line">int hashIterations = 2;  </div><div class="line">  </div><div class="line">SimpleHash hash = new SimpleHash(algorithmName, password, salt1 + salt2, hashIterations);  </div><div class="line">String encodedPassword = hash.toHex();</div></pre></td></tr></table></figure></p><p>如果要写用户模块，需要在新增用户/重置密码时使用如上算法保存密码，将<code>生成的密码</code>及<code>salt2</code>存入数据库。<br>因为我们的散列算法是：md5(密码+username+salt2)。</p><h3 id="生成Realm"><a href="#生成Realm" class="headerlink" title="生成Realm"></a>生成Realm</h3><h4 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h4><blockquote><p>com.github.gojay001.realm.MyRealm2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">    // 用户名及salt1  </div><div class="line">    String username = &quot;liu&quot;; </div><div class="line">    // 加密后的密码  </div><div class="line">    String password = &quot;202cb962ac59075b964b07152d234b70&quot;; </div><div class="line">    String salt2 = &quot;202cb962ac59075b964b07152d234b70&quot;;  </div><div class="line">SimpleAuthenticationInfo ai =   </div><div class="line">        new SimpleAuthenticationInfo(username, password, getName());  </div><div class="line">    // 盐是用户名+随机数</div><div class="line">    ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); </div><div class="line">        return ai;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>此处就是把步骤1中生成的相应数据组装为 <code>SimpleAuthenticationInfo</code> ，通过 <code>SimpleAuthenticationInfo</code> 的 <code>credentialsSalt</code> 设置盐， <code>HashedCredentialsMatcher</code> 会自动识别这个盐。</p><h4 id="JdbcRealm"><a href="#JdbcRealm" class="headerlink" title="JdbcRealm"></a>JdbcRealm</h4><p>需要修改获取用户信息（包括盐）的sql： <code>“select password, password_salt from users where username = ?”</code> ；<br>而我们的盐是由 <code>username+password_salt</code> 组成，所以需要通过如下ini配置（<code>shiro-jdbc-hashedCredentialsMatcher.ini</code>）修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jdbcRealm.saltStyle=COLUMN  </div><div class="line">jdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ?  </div><div class="line">jdbcRealm.credentialsMatcher=$credentialsMatcher</div></pre></td></tr></table></figure></p><ul><li><strong>saltStyle</strong>表示使用<code>密码+盐</code>的机制，authenticationQuery第一列是密码，第二列是盐；</li><li>通过 <code>authenticationQuery</code> 指定密码及盐查询SQL。</li></ul><h3 id="INI配置-1"><a href="#INI配置-1" class="headerlink" title="INI配置"></a>INI配置</h3><blockquote><p>shiro-hashedCredentialsMatcher.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher  </div><div class="line">credentialsMatcher.hashAlgorithmName=md5  </div><div class="line">credentialsMatcher.hashIterations=2  </div><div class="line">credentialsMatcher.storedCredentialsHexEncoded=true  </div><div class="line">myRealm=com.github.gojay001.realm.MyRealm2  </div><div class="line">myRealm.credentialsMatcher=$credentialsMatcher  </div><div class="line">securityManager.realms=$myRealm</div></pre></td></tr></table></figure><ul><li>通过 <code>credentialsMatcher.hashAlgorithmName=md5</code> 指定散列算法为md5，需要和生成密码时的一样；</li><li><code>credentialsMatcher.hashIterations=2</code> ，散列迭代次数，需要和生成密码时的意义；</li><li><code>credentialsMatcher.storedCredentialsHexEncoded=true</code> 表示是否存储散列后的密码为16进制，需要和生成密码时的一样，默认是base64；</li></ul><blockquote><p>此处最需要注意的就是 <code>HashedCredentialsMatcher</code> 的算法需要和生成密码时的算法一样。另外HashedCredentialsMatcher会自动根据 <code>AuthenticationInfo</code> 的类型是否是 <code>SaltedAuthenticationInfo</code> 来<code>获取credentialsSalt盐</code>。</p></blockquote><h3 id="密码重试次数限制"><a href="#密码重试次数限制" class="headerlink" title="密码重试次数限制"></a>密码重试次数限制</h3><p>如在1个小时内密码最多重试5次，如果尝试次数超过5次就锁定1小时，1小时后可再次重试，如果还是重试失败，可以锁定如1天，以此类推，防止密码被暴力破解。我们通过<strong>继承HashedCredentialsMatcher</strong>，且使用<strong>Ehcache</strong>记录<code>重试次数</code>和<code>超时时间</code>。</p><blockquote><p>com.github.gojay001.credentials.RetryLimitHashedCredentialsMatcher</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;  </div><div class="line">       String username = (String)token.getPrincipal();  </div><div class="line">        //retry count + 1  </div><div class="line">        Element element = passwordRetryCache.get(username);  </div><div class="line">        if(element == null) &#123;  </div><div class="line">            element = new Element(username , new AtomicInteger(0));  </div><div class="line">            passwordRetryCache.put(element);  </div><div class="line">        &#125;  </div><div class="line">        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();  </div><div class="line">        if(retryCount.incrementAndGet() &gt; 5) &#123;  </div><div class="line">            //if retry count &gt; 5 throw  </div><div class="line">            throw new ExcessiveAttemptsException();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        boolean matches = super.doCredentialsMatch(token, info);  </div><div class="line">        if(matches) &#123;  </div><div class="line">            //clear retry count  </div><div class="line">            passwordRetryCache.remove(username);  </div><div class="line">        &#125;  </div><div class="line">        return matches;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上代码逻辑比较简单，即如果密码输入<code>正确</code>，<code>清除cache</code>中的记录；否则<code>cache中的重试次数+1</code>，如果超出5次那么抛出异常表示超出重试次数了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="编码-解码-1"><a href="#编码-解码-1" class="headerlink" title="编码/解码"></a>编码/解码</h2><ul><li>Base64</li><li>Hex</li><li>Hash()</li></ul><h2 id="加密-解密-1"><a href="#加密-解密-1" class="headerlink" title="加密/解密"></a>加密/解密</h2><ul><li>对称式加密/解密</li></ul><h2 id="加密-验证"><a href="#加密-验证" class="headerlink" title="加密/验证"></a>加密/验证</h2><h3 id="PasswordService"><a href="#PasswordService" class="headerlink" title="PasswordService"></a>PasswordService</h3><ul><li>DefaultPasswordService</li></ul><h3 id="CredentialsMatcher"><a href="#CredentialsMatcher" class="headerlink" title="CredentialsMatcher"></a>CredentialsMatcher</h3><ul><li>PasswordMatcher</li><li>HashedCredentialsMatcher</li></ul><h2 id="DefaultPasswordService配合PasswordMatcher"><a href="#DefaultPasswordService配合PasswordMatcher" class="headerlink" title="DefaultPasswordService配合PasswordMatcher"></a>DefaultPasswordService配合PasswordMatcher</h2><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul><li>自定义Realm</li><li>JdbcRealm</li></ul><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><ul><li>passwordService</li><li>hashService</li><li>hashFormat</li><li>hashFormatFactory</li><li>passwordMatcher</li><li>myRealm</li></ul><h2 id="HashedCredentialsMatcher"><a href="#HashedCredentialsMatcher" class="headerlink" title="HashedCredentialsMatcher"></a>HashedCredentialsMatcher</h2><h3 id="生成Realm-1"><a href="#生成Realm-1" class="headerlink" title="生成Realm"></a>生成Realm</h3><ul><li>使用MD5算法</li></ul><h3 id="ini配置-1"><a href="#ini配置-1" class="headerlink" title="ini配置"></a>ini配置</h3><ul><li>credentialsMatcher</li><li>hashAlgorithmName</li><li>hashIterations</li><li>myRealm</li></ul><h3 id="添加密码重试次数限制"><a href="#添加密码重试次数限制" class="headerlink" title="添加密码重试次数限制"></a>添加密码重试次数限制</h3><ul><li>记录重试次数</li></ul><blockquote><p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter5</code></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（四）-INI配置</title>
      <link>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/</link>
      <guid>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Tue, 28 Nov 2017 06:42:36 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;SecurityManager&quot;&gt;&lt;a href=&quot;#SecurityManager&quot; class=&quot;headerlink&quot; title=&quot;SecurityManager&quot;&gt;&lt;/a&gt;SecurityManager&lt;/h1&gt;&lt;p&gt;Shiro是从根对象 &lt;code&gt;SecurityManager&lt;/code&gt; 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 &lt;code&gt;SecurityUtils&lt;/code&gt; 让我们绑定它为&lt;code&gt;全局&lt;/code&gt;的，方便后续操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。&lt;br&gt;但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。&lt;br&gt;Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h1><p>Shiro是从根对象 <code>SecurityManager</code> 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 <code>SecurityUtils</code> 让我们绑定它为<code>全局</code>的，方便后续操作。</p><blockquote><p>因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。<br>但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。<br>Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。</p></blockquote><a id="more"></a><h2 id="纯Java代码写法"><a href="#纯Java代码写法" class="headerlink" title="纯Java代码写法"></a>纯Java代码写法</h2><blockquote><p>com.github.gojay001.test.NonConfigurationCreateTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DefaultSecurityManager securityManager = new DefaultSecurityManager();</div><div class="line"></div><div class="line">//设置authenticator</div><div class="line">ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();</div><div class="line">authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());</div><div class="line">securityManager.setAuthenticator(authenticator);</div><div class="line"></div><div class="line">//设置authorizer</div><div class="line">ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();</div><div class="line">authorizer.setPermissionResolver(new WildcardPermissionResolver());</div><div class="line">securityManager.setAuthorizer(authorizer);</div><div class="line"></div><div class="line">//设置Realm</div><div class="line">DruidDataSource ds = new DruidDataSource();</div><div class="line">ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</div><div class="line">ds.setUrl(&quot;jdbc:mysql://localhost:3306/shiro&quot;);</div><div class="line">ds.setUsername(&quot;root&quot;);</div><div class="line">ds.setPassword(&quot;root&quot;);</div><div class="line"></div><div class="line">JdbcRealm jdbcRealm = new JdbcRealm();</div><div class="line">jdbcRealm.setDataSource(ds);</div><div class="line">jdbcRealm.setPermissionsLookupEnabled(true);</div><div class="line">securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure><h2 id="等价的INI配置"><a href="#等价的INI配置" class="headerlink" title="等价的INI配置"></a>等价的INI配置</h2><h3 id="shiro-config-ini："><a href="#shiro-config-ini：" class="headerlink" title="shiro-config.ini："></a>shiro-config.ini：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#覆盖默认的securityManager</div><div class="line">#securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div><div class="line"></div><div class="line">#authenticator</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy</div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#realm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line"></div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><blockquote><p><code>对象名=全限定类名</code>  相对于调用public无参构造器创建对象<br><code>对象名.属性名=值</code>    相当于调用setter方法设置常量值<br><code>对象名.属性名=$对象引用</code>    相当于调用setter方法设置对象引用</p></blockquote><h3 id="com-github-gojay001-test-ConfigurationCreateTest："><a href="#com-github-gojay001-test-ConfigurationCreateTest：" class="headerlink" title="com.github.gojay001.test.ConfigurationCreateTest："></a>com.github.gojay001.test.ConfigurationCreateTest：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Factory&lt;SecurityManager&gt; factory =</div><div class="line">    new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;);</div><div class="line"></div><div class="line">SecurityManager securityManager = factory.getInstance();</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure><blockquote><p>如上代码是从Shiro <code>INI配置</code>中获取相应的<code>securityManager</code>实例：  </p><ol><li>默认情况先创建一个名字为 <code>securityManager</code> ，类型为 <code>org.apache.shiro.mgt.DefaultSecurityManager</code> 的默认的 <code>SecurityManager</code> ，如果想<code>自定义</code>，只需要在ini配置文件中指定“securityManager=SecurityManager实现类”即可，名字必须为securityManager，它是起始的根；  </li><li><code>IniSecurityManagerFactory</code> 是创建 <code>securityManager</code> 的工厂，其需要一个ini配置文件路径，其支持<code>classpath:</code>（类路径）、<code>file:</code>（文件系统）、<code>url:</code>（网络）三种路径格式，默认是<code>文件系统</code>；  </li><li>接着获取<code>SecuriyManager实例</code>，后续步骤和之前的一样。</li></ol></blockquote><p>如上可以看出Shiro INI配置方式本身提供了一个简单的<code>IoC/DI机制</code>方便在配置文件配置，但是是从 <code>securityManager</code> 这个根对象开始导航。</p><h1 id="INI配置"><a href="#INI配置" class="headerlink" title="INI配置"></a>INI配置</h1><p><code>ini配置文件</code>类似于Java中的 <code>properties（key=value）</code> ，不过提供了将key/value分类的特性，key是每个部分不重复即可，而不是整个配置文件。如下是INI配置分类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">#提供了对根对象securityManager及其依赖的配置  </div><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager  </div><div class="line">…………  </div><div class="line">securityManager.realms=$jdbcRealm  </div><div class="line">  </div><div class="line">[users]  </div><div class="line">#提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2  </div><div class="line">username=password,role1,role2  </div><div class="line">  </div><div class="line">[roles]  </div><div class="line">#提供了角色及权限之间关系的配置，角色=权限1，权限2  </div><div class="line">role1=permission1,permission2  </div><div class="line">  </div><div class="line">[urls]  </div><div class="line">#用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器  </div><div class="line">/index.html = anon  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p><h2 id="main-部分"><a href="#main-部分" class="headerlink" title="[main]部分"></a>[main]部分</h2><p>提供了对根对象 <strong>securityManager</strong> 及其依赖对象的配置。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div></pre></td></tr></table></figure><p>其构造器必须是<code>public空参构造器</code>，通过反射创建相应的实例。</p><h3 id="常量值setter注入"><a href="#常量值setter注入" class="headerlink" title="常量值setter注入"></a>常量值setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div></pre></td></tr></table></figure><p>会自动调用 <code>jdbcRealm.setPermissionsLookupEnabled(true)</code> ，对于这种常量值会自动类型转换。</p><h3 id="对象引用setter注入"><a href="#对象引用setter注入" class="headerlink" title="对象引用setter注入"></a>对象引用setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator  </div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy  </div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy  </div><div class="line">securityManager.authenticator=$authenticator</div></pre></td></tr></table></figure><p>会自动通过 <code>securityManager.setAuthenticator(authenticator)</code> 注入引用依赖。</p><h3 id="嵌套属性setter注入"><a href="#嵌套属性setter注入" class="headerlink" title="嵌套属性setter注入"></a>嵌套属性setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager.authenticator.authenticationStrategy=$authenticationStrategy</div></pre></td></tr></table></figure><p>支持这种嵌套方式的setter注入。</p><h3 id="byte数组setter注入"><a href="#byte数组setter注入" class="headerlink" title="byte数组setter注入"></a>byte数组setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#base64 byte[]  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">#hex byte[]  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure><p>默认需要使用Base64进行编码，也可以使用0x十六进制。</p><h3 id="Array-Set-List-setter注入"><a href="#Array-Set-List-setter注入" class="headerlink" title="Array/Set/List setter注入"></a>Array/Set/List setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authenticator.array=1,2,3  </div><div class="line">authenticator.set=$jdbcRealm,$jdbcRealm</div></pre></td></tr></table></figure><p>多个之间通过“，”分割。</p><h3 id="Map-setter注入"><a href="#Map-setter注入" class="headerlink" title="Map setter注入"></a>Map setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc</div></pre></td></tr></table></figure><p>格式是： <code>map=key：value，key：value</code> ，可以注入常量及引用值，常量的话都看作字符串（即使有泛型也不会自动造型）。  </p><h3 id="实例化-注入顺序"><a href="#实例化-注入顺序" class="headerlink" title="实例化/注入顺序"></a>实例化/注入顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">realm=Realm1  </div><div class="line">realm=Realm12  </div><div class="line">  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure><p>后边的<code>覆盖</code>前边的注入。</p><h2 id="users-部分"><a href="#users-部分" class="headerlink" title="[users]部分"></a>[users]部分</h2><p>配置用户名/密码及其角色，格式：<code>用户名=密码，角色1，角色2</code>，角色部分可省略。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test</div></pre></td></tr></table></figure></p><p>密码一般生成其摘要/加密存储。</p><h2 id="roles-部分"><a href="#roles-部分" class="headerlink" title="[roles]部分"></a>[roles]部分</h2><p>配置角色及权限之间的关系，格式：<code>角色=权限1，权限2</code>；如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[roles]  </div><div class="line">role1=user:create,user:update  </div><div class="line">role2=*</div></pre></td></tr></table></figure></p><p>如果只有角色没有对应的权限，可以不配roles。</p><h2 id="urls-部分"><a href="#urls-部分" class="headerlink" title="[urls]部分"></a>[urls]部分</h2><p>配置url及相应的拦截器之间的关系，格式：<code>url=拦截器[参数]，拦截器[参数]</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[urls]  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p><blockquote><p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter4</code></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（三）-授权</title>
      <link>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/</link>
      <guid>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/</guid>
      <pubDate>Thu, 23 Nov 2017 09:06:29 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;授权&lt;/strong&gt;：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：&lt;code&gt;主体&lt;/code&gt;（Subject）、&lt;code&gt;资源&lt;/code&gt;（Resource）、&lt;code&gt;权限&lt;/code&gt;（Permission）、&lt;code&gt;角色&lt;/code&gt;（Role）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主体&lt;/strong&gt;：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源&lt;/strong&gt;：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权限&lt;/strong&gt;：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;角色&lt;/strong&gt;：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隐式角色&lt;/strong&gt;：即直接通过角色来验证用户有没有操作权限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;显式角色&lt;/strong&gt;：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;了解更多&lt;/strong&gt;：搜索&lt;code&gt;“RBAC”&lt;/code&gt;和&lt;code&gt;“RBAC新解”&lt;/code&gt;分别了解&lt;code&gt;“基于角色的访问控制”&lt;/code&gt;和&lt;code&gt;“基于资源的访问控制”&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>授权</strong>：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：<code>主体</code>（Subject）、<code>资源</code>（Resource）、<code>权限</code>（Permission）、<code>角色</code>（Role）。</p><ul><li><strong>主体</strong>：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</li><li><strong>资源</strong>：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</li><li><strong>权限</strong>：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。</li><li><strong>角色</strong>：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</li><li><strong>隐式角色</strong>：即直接通过角色来验证用户有没有操作权限。</li><li><strong>显式角色</strong>：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。</li></ul><blockquote><p><strong>了解更多</strong>：搜索<code>“RBAC”</code>和<code>“RBAC新解”</code>分别了解<code>“基于角色的访问控制”</code>和<code>“基于资源的访问控制”</code>。</p></blockquote><a id="more"></a><h1 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h1><blockquote><p>Shiro支持三种方式的授权。</p></blockquote><h2 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h2><p>通过写if/else授权代码块完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Subject subject = SecurityUtils.getSubject();  </div><div class="line">if(subject.hasRole(“admin”)) &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125; else &#123;  </div><div class="line">    //无权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h2><p>通过在执行的Java方法上放置相应的注解完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequiresRoles(&quot;admin&quot;)  </div><div class="line">public void hello() &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>没有权限将抛出相应的异常。</p><h2 id="JSP-GSP标签"><a href="#JSP-GSP标签" class="headerlink" title="JSP/GSP标签"></a>JSP/GSP标签</h2><p>在JSP/GSP页面通过相应的标签完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;  </div><div class="line">&lt;!— 有权限 —&gt;  </div><div class="line">&lt;/shiro:hasRole&gt;</div></pre></td></tr></table></figure></p><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色"><a href="#在ini配置文件配置用户拥有的角色" class="headerlink" title="在ini配置文件配置用户拥有的角色"></a>在ini配置文件配置用户拥有的角色</h3><blockquote><p>shiro-role.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div></pre></td></tr></table></figure><blockquote><p><strong>规则</strong>：<code>“用户名=密码,角色1，角色2”</code>，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息；也就是说<code>Shiro不负责维护用户-角色信息</code>，需要应用提供，Shiro只是提供相应的接口方便验证。</p></blockquote><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote><p>com.github.gojay001.test.RoleTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testHasRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有角色：role1</div><div class="line">    Assert.assertTrue(subject().hasRole(&quot;role1&quot;));</div><div class="line">    // 判断拥有角色：role1 and role2</div><div class="line">    Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));</div><div class="line">    // 判断拥有角色：role1 and role2 and !role3</div><div class="line">    boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));</div><div class="line">    Assert.assertEquals(true, result[0]);</div><div class="line">    Assert.assertEquals(true, result[1]);</div><div class="line">    Assert.assertEquals(false, result[2]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供了<code>hasRole/hasAllRoles</code>用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有角色：role1</div><div class="line">    subject().checkRole(&quot;role1&quot;);</div><div class="line">    // 断言拥有角色：role1 and role3 失败抛出异常</div><div class="line">    subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供的<code>checkRole/checkRoles</code>和<code>hasRole/hasAllRoles</code>不同的地方是它在判断为假的情况下会<code>抛出UnauthorizedException异常</code>。</p></blockquote><p><strong>基于角色的访问控制</strong>（即隐式角色）的缺点：如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把<code>所有相关的地方</code>进行删除；这就是粗粒度造成的问题。</p><h2 id="基于资源的访问控制（显式角色）"><a href="#基于资源的访问控制（显式角色）" class="headerlink" title="基于资源的访问控制（显式角色）"></a>基于资源的访问控制（显式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色及角色-权限关系"><a href="#在ini配置文件配置用户拥有的角色及角色-权限关系" class="headerlink" title="在ini配置文件配置用户拥有的角色及角色-权限关系"></a>在ini配置文件配置用户拥有的角色及角色-权限关系</h3><blockquote><p>shiro-permission.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div><div class="line">[roles]</div><div class="line">role1=user:create,user:update</div><div class="line">role2=user:create,user:delete</div></pre></td></tr></table></figure><blockquote><p><strong>规则</strong>：<code>“用户名=密码，角色1，角色2”“角色=权限1，权限2”</code>，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。</p></blockquote><h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote><p>com.github.gojay001.test.PermissionTest</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));</div><div class="line">    // 判断拥有权限：user:update and user:delete</div><div class="line">    Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;));</div><div class="line">    // 判断没有权限：user:view</div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Shiro提供了<code>isPermitted</code>和<code>isPermittedAll</code>用于判断用户是否拥有某个权限或所有权限，也<code>没有提供如isPermittedAny</code>用于判断拥有某一个权限的接口。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckPermission() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有权限：user:create</div><div class="line">    subject().checkPermission(&quot;user:create&quot;);</div><div class="line">    // 断言拥有权限：user:delete and user:update</div><div class="line">    subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);</div><div class="line">    // 断言拥有权限：user:view 失败抛出异常</div><div class="line">    subject().checkPermissions(&quot;user:view&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>checkPermissions</code>失败的情况下会抛出UnauthorizedException异常。</p></blockquote><p><strong>基于资源的访问控制</strong>（显式角色），也可以叫基于权限的访问控制，这种方式的一般规则是<code>“资源标识符：操作”</code>，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。 </p><h1 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h1><p><strong>字符串通配符权限</strong><br><strong>规则</strong>：<code>“资源标识符：操作：对象实例ID”</code>  即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>“:”</code>表示资源/操作/实例的分割；<code>“,”</code>表示操作的分割；<code>“*”</code>表示任意资源/操作/实例。</p><h2 id="单个资源单个权限"><a href="#单个资源单个权限" class="headerlink" title="单个资源单个权限"></a>单个资源单个权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;);</div></pre></td></tr></table></figure><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>权限。</p></blockquote><h2 id="单个资源多个权限"><a href="#单个资源多个权限" class="headerlink" title="单个资源多个权限"></a>单个资源多个权限</h2><p>ini配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role41=system:user:update,system:user:delete</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);</div></pre></td></tr></table></figure></p><p>可以简写为：<code>&quot;system:user:update,delete&quot;</code></p><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>和<code>“delete”</code>权限。</p></blockquote><h2 id="单个资源全部权限"><a href="#单个资源全部权限" class="headerlink" title="单个资源全部权限"></a>单个资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role51=&quot;system:user:create,update,delete,view&quot;</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;);</div></pre></td></tr></table></figure></p><p>可以简写为：<code>system:user:*</code></p><blockquote><p>用户拥有资源<code>“system:user”</code>的<code>“create”</code>、<code>“update”</code>、<code>“delete”</code>和<code>“view”</code>所有权限。</p></blockquote><h2 id="所有资源全部权限"><a href="#所有资源全部权限" class="headerlink" title="所有资源全部权限"></a>所有资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role61=*:view</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>用户拥有所有资源的<code>“view”</code>所有权限。</p></blockquote><h2 id="实例级别的权限"><a href="#实例级别的权限" class="headerlink" title="实例级别的权限"></a>实例级别的权限</h2><h3 id="单个实例单个权限"><a href="#单个实例单个权限" class="headerlink" title="单个实例单个权限"></a>单个实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role71=user:view:1</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有view权限。</p></blockquote><h3 id="单个实例多个权限"><a href="#单个实例多个权限" class="headerlink" title="单个实例多个权限"></a>单个实例多个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role72=&quot;user:update,delete:1&quot;</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:delete,update:1&quot;);  </div><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有update、delete权限。</p></blockquote><h3 id="单个实例所有权限"><a href="#单个实例所有权限" class="headerlink" title="单个实例所有权限"></a>单个实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role73=user:*:1</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h3 id="所有实例单个权限"><a href="#所有实例单个权限" class="headerlink" title="所有实例单个权限"></a>所有实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role74=user:auth:*</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h3 id="所有实例所有权限"><a href="#所有实例所有权限" class="headerlink" title="所有实例所有权限"></a>所有实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role75=user:*:*</div></pre></td></tr></table></figure></p><p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p><blockquote><p>对资源user的1实例拥有所有权限。</p></blockquote><h2 id="Shiro对权限字符串缺失部分的处理"><a href="#Shiro对权限字符串缺失部分的处理" class="headerlink" title="Shiro对权限字符串缺失部分的处理"></a>Shiro对权限字符串缺失部分的处理</h2><ul><li>如<code>user:view</code> 等价于 <code>user:view:*</code>；<br><code>organization</code> 等价于 <code>organization:*</code> 或者 <code>organization:*:*</code>。<br>可以这么理解，这种方式实现了<strong>前缀匹配</strong>。</li><li>如<code>user:*</code> 可以匹配 <code>user:delete</code>；<br><code>user:delete</code> 可以匹配 <code>user:delete:1</code>；<br><code>user:*:1</code> 可以匹配 <code>user:view:1</code>；<br><code>user</code> 可以匹配 <code>user:view</code> 或 <code>user:view:1</code>等。<br>即*可以匹配所有，不加*可以进行前缀匹配；</li><li>如<code>*:view</code> 不能匹配 <code>system:user:view</code>；需要使用 <code>*:*:view</code>；<br>即<strong>后缀匹配</strong>必须指定前缀（多个冒号就需要多个*来匹配）。</li></ul><h2 id="WildcardPermission"><a href="#WildcardPermission" class="headerlink" title="WildcardPermission"></a>WildcardPermission</h2><p>如下两种方式是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermission(&quot;menu:view:1&quot;);  </div><div class="line">subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;));</div></pre></td></tr></table></figure></p><blockquote><p>因此没什么必要的话使用字符串更方便。</p></blockquote><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p><code>通配符匹配</code>方式比<code>字符串匹配</code>来说是更复杂的，因此需要花费更长时间，但是一般系统的权限不会太多，且可以配合缓存来提供其性能，如果这样性能还达不到要求我们可以实现位操作算法实现性能更好的权限匹配。另外实例级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如在sql查询时加上权限字符串之类的方式在查询时就完成了权限匹配。</p><h1 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h1><p><img src="/2017/11/23/跟我学Shiro（三）-授权/3-1.png" alt="跟我学Shiro（三）-授权/3-1.png"></p><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote><ol><li>首先调用<code>Subject.isPermitted*/hasRole*</code>接口，其会委托给SecurityManager，而<code>SecurityManager</code>接着会委托给<code>Authorizer</code>；</li><li><code>Authorizer</code>是真正的授权者；如果我们调用如<code>isPermitted(“user:view”)</code>，其首先会通过<code>PermissionResolver</code>把字符串转换成相应的<code>Permission实例</code>；</li><li>在进行授权之前，其会<code>调用相应的Realm</code>获取Subject相应的<code>角色/权限</code>用于匹配传入的角色/权限；</li><li><code>Authorizer</code>会<code>判断</code>Realm的角色/权限是否和传入的<code>匹配</code>，如果有<code>多个Realm</code>，会委托给<code>ModularRealmAuthorizer</code>进行循环判断，如果匹配如isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</li></ol></blockquote><ul><li>ModularRealmAuthorizer进行多Realm匹配流程：</li></ul><blockquote><ol><li>首先检查相应的<code>Realm</code>是否实现了<code>Authorizer</code>；</li><li>如果实现了Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*接口</code>进行匹配；</li><li>如果有一个<code>Realm匹配</code>那么将返回true，否则返回false。</li></ol></blockquote><ul><li>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：</li></ul><blockquote><ol><li>如果调用<code>hasRole*</code>，则直接获取<code>AuthorizationInfo.getRoles()</code>与传入的角色比较即可；</li><li>如果调用如<code>isPermitted(“user:view”)</code>，首先通过<code>PermissionResolver</code>将权限字符串转换成相应的<code>Permission实例</code>，默认使用<code>WildcardPermissionResolver</code>，即转换为通配符的<code>WildcardPermission</code>；</li><li>通过<code>AuthorizationInfo.getObjectPermissions()</code>得到<code>Permission实例集合</code>；通过<code>AuthorizationInfo. getStringPermissions()</code>得到字符串集合并通过PermissionResolver解析为<code>Permission实例</code>；然后获取用户的角色，并通过<code>RolePermissionResolver</code>解析角色对应的<code>权限集合</code>（默认没有实现，可以自己提供）；</li><li>接着调用<code>Permission. implies(Permission p)</code>逐个与传入的权限比较，如果有<code>匹配</code>的则返回true，否则false。</li></ol></blockquote><h1 id="Authorizer"><a href="#Authorizer" class="headerlink" title="Authorizer"></a>Authorizer</h1><p><strong>Authorizer</strong>的职责是进行授权（访问控制），提供了相应的角色/权限判断接口。<code>SecurityManager</code>继承了<code>Authorizer接口</code>，且提供了<code>ModularRealmAuthorizer</code>用于多Realm时的授权匹配。<br><strong>PermissionResolver</strong>用于解析权限字符串到Permission实例。<br><strong>RolePermissionResolver</strong>用于根据角色解析相应的权限集合。</p><ul><li><p>可以通过如下ini配置更改<code>Authorizer</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer  </div><div class="line">securityManager.authorizer=$authorizer</div></pre></td></tr></table></figure></li><li><p>设置<code>ModularRealmAuthorizer</code>的<code>permissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>PermissionResolverAware</code>接口），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver  </div><div class="line">authorizer.permissionResolver=$permissionResolver</div></pre></td></tr></table></figure></li><li><p>设置<code>ModularRealmAuthorizer</code>的<code>rolePermissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>RolePermissionResolverAware</code>接口），如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver  </div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote><p>shiro-jdbc-authorizer.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#自定义authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">#自定义permissionResolver</div><div class="line">#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">permissionResolver=com.github.gojay001.permission.BitAndWildPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">#自定义rolePermissionResolver</div><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver</div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div><div class="line"></div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#自定义realm 一定要放在securityManager.authorizer赋值之后</div><div class="line">#因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver</div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><blockquote><p>不能使用<code>IniSecurityManagerFactory</code>创建的<code>IniRealm</code>，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。</p></blockquote><h3 id="定义BitAndWildPermissionResolver及BitPermission"><a href="#定义BitAndWildPermissionResolver及BitPermission" class="headerlink" title="定义BitAndWildPermissionResolver及BitPermission"></a>定义BitAndWildPermissionResolver及BitPermission</h3><blockquote><p><strong>BitPermission</strong>用于实现位移方式的权限，如规则是：<br>权限字符串格式：<code>+资源字符串+权限位+实例ID</code>；以+开头中间通过+分割；权限：<code>0 表示所有权限</code>；<code>1 新增</code>（二进制：0001）、<code>2 修改</code>（二进制：0010）、<code>4 删除</code>（二进制：0100）、<code>8 查看</code>（二进制：1000）；如 <code>+user+10</code> 表示对资源user拥有<code>修改/查看</code>权限。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class BitPermission implements Permission &#123;</div><div class="line">    private String resourceIdentify;</div><div class="line">    private int permissionBit;</div><div class="line">    private String instanceId;</div><div class="line"></div><div class="line">    public BitPermission(String permissionString) &#123;</div><div class="line">        String[] array = permissionString.split(&quot;\\+&quot;);</div><div class="line"></div><div class="line">        if (array.length &gt; 1) &#123;</div><div class="line">            resourceIdentify = array[1];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(resourceIdentify)) &#123;</div><div class="line">            resourceIdentify = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 2) &#123;</div><div class="line">            permissionBit = Integer.valueOf(array[2]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 3) &#123;</div><div class="line">            instanceId = array[3];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(instanceId)) &#123;</div><div class="line">            instanceId = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean implies(Permission permission) &#123;</div><div class="line">        if(!(permission instanceof BitPermission)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        BitPermission other = (BitPermission) permission;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;BitPermission&#123;&quot; +</div><div class="line">                &quot;resourceIdentify=&apos;&quot; + resourceIdentify + &apos;\&apos;&apos; +</div><div class="line">                &quot;, permissionBit=&quot; + permissionBit +</div><div class="line">                &quot;, instanceId=&apos;&quot; + instanceId + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>Permission接口</strong>提供了<code>boolean implies(Permission p)方法</code>用于判断权限匹配的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BitAndWildPermissionResolver implements PermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Permission resolvePermission(String permissionString) &#123;  </div><div class="line">        if(permissionString.startsWith(&quot;+&quot;)) &#123;  </div><div class="line">            return new BitPermission(permissionString);  </div><div class="line">        &#125;  </div><div class="line">        return new WildcardPermission(permissionString);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>BitAndWildPermissionResolver</strong>实现了<code>PermissionResolver接口</code>，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。</p><h3 id="定义MyRolePermissionResolver"><a href="#定义MyRolePermissionResolver" class="headerlink" title="定义MyRolePermissionResolver"></a>定义MyRolePermissionResolver</h3><p><strong>RolePermissionResolver</strong>用于根据角色字符串来解析得到权限集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MyRolePermissionResolver implements RolePermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123;  </div><div class="line">        if(&quot;role1&quot;.equals(roleString)) &#123;  </div><div class="line">            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><p>使用<strong>JdbcRealm</strong>，需要做的操作如下：</p><ul><li>执行<code>sql/shiro-init-data.sql</code> 插入相关的权限数据；</li><li>使用<code>shiro-jdbc-authorizer.ini配置文件</code>，需要<code>设置jdbcRealm.permissionsLookupEnabled为true</code>来开启权限查询。</li></ul><blockquote><p>这里也可以自定义实现Realm，可参考com.github.gojay001.realm.MyRealm</p></blockquote><h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted2() &#123;</div><div class="line">    login(&quot;classpath:shiro-jdbc-authorizer.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;));</div><div class="line">    // 通过二进制位的方式表示权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));// 新增权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));// 查看权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));// 新增及查看</div><div class="line"></div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));// 没有删除权限</div><div class="line"></div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));// 通过MyRolePermissionResolver解析得到的权限</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="授权流程-1"><a href="#授权流程-1" class="headerlink" title="授权流程"></a>授权流程</h2><ul><li>Subject.isPermitted*/hasRole*</li><li>SecurityManager</li><li>Authorizer</li><li>PermissionResolver/RolePermissionResolver/Permission</li><li>Realm</li></ul><h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><ul><li>user</li><li>role</li><li>permission</li></ul><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul><li>Authorizer</li><li>PermissionResolver</li><li>RolePermissionResolver</li><li>Realm</li></ul><h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><ul><li>hasRole/hasAllRoles</li><li>checkRole/checkRoles</li><li>isPermitted/isPermittedAll</li><li>checkPermission/checkPermissions</li></ul><blockquote><p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>跟我学Shiro（二）-身份认证</title>
      <link>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</link>
      <guid>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</guid>
      <pubDate>Wed, 22 Nov 2017 06:22:39 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;身份验证&lt;/strong&gt;：在应用中能&lt;code&gt;证明他就是他本人&lt;/code&gt;。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。&lt;br&gt;在 shiro 中，用户需要提供 &lt;code&gt;principals&lt;/code&gt; （身份）和 &lt;code&gt;credentials&lt;/code&gt;（证明）给 shiro，从而应用能验证用户身份。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;principals&lt;/strong&gt;：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但&lt;code&gt;只有一个 Primary principals&lt;/code&gt;，一般是用户名/密码/手机号。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;credentials&lt;/strong&gt;：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最常见的 principals 和 credentials 组合就是&lt;code&gt;用户名/密码&lt;/code&gt;了。&lt;br&gt;另外两个相关的概念是之前提到的 &lt;code&gt;Subject&lt;/code&gt; 及 &lt;code&gt;Realm&lt;/code&gt;，分别是主体及验证主体的数据源。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>身份验证</strong>：在应用中能<code>证明他就是他本人</code>。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>在 shiro 中，用户需要提供 <code>principals</code> （身份）和 <code>credentials</code>（证明）给 shiro，从而应用能验证用户身份。  </p><ul><li><strong>principals</strong>：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但<code>只有一个 Primary principals</code>，一般是用户名/密码/手机号。 </li><li><strong>credentials</strong>：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   </li></ul><blockquote><p>最常见的 principals 和 credentials 组合就是<code>用户名/密码</code>了。<br>另外两个相关的概念是之前提到的 <code>Subject</code> 及 <code>Realm</code>，分别是主体及验证主体的数据源。</p></blockquote><a id="more"></a><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="使用Maven构建"><a href="#使用Maven构建" class="headerlink" title="使用Maven构建"></a>使用Maven构建</h2><p>准备环境依赖：添加 <code>junit</code>、<code>common-logging</code> 及 <code>shiro-core</code> 依赖；</p><blockquote><p><strong>更新</strong>：加入slf4j-nop依赖包。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">        &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.7.25&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure><h1 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h1><h2 id="准备一些用户身份-凭据"><a href="#准备一些用户身份-凭据" class="headerlink" title="准备一些用户身份/凭据"></a>准备一些用户身份/凭据</h2><blockquote><p>shiro.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">gojay=test</div><div class="line">root=root</div></pre></td></tr></table></figure><p>此处使用ini配置文件，通过<code>[user]</code>指定两个主体。</p><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><blockquote><p>com.github.gojay001.test.LoginLogoutTest<br><strong>更新</strong>：注意类过时。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testLoginLogout() &#123;</div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</div><div class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line"></div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils</div><div class="line">    SecurityManager securityManager = factory.getInstance();</div><div class="line">    SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //4、登录，即身份验证</div><div class="line">        subject.login(token);</div><div class="line">    &#125; catch (AuthenticationException e) &#123;</div><div class="line">        //5、身份验证失败</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Assert.assertEquals(true, subject.isAuthenticated());</div><div class="line"></div><div class="line">    //6、退出</div><div class="line">    subject.logout();</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>首先通过new IniSecurityManagerFactory并指定一个ini配置文件来<code>创建一个SecurityManager工厂</code>；</li><li>接着<code>获取SecurityManager并绑定到SecurityUtils</code>，这是一个全局设置，设置一次即可；</li><li>通过SecurityUtils<code>得到Subject</code>，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后<code>获取身份验证的Token</code>，如用户名/密码；</li><li><code>调用subject.login方法</code>进行登录，其会自动委托给SecurityManager.login方法进行登录；</li><li><code>如果身份验证失败捕获AuthenticationException或其子类</code>，常见的如： <code>DisabledAccountException</code>（禁用的帐号）、<code>LockedAccountException</code>（锁定的帐号）、<code>UnknownAccountException</code>（错误的帐号）、<code>ExcessiveAttemptsException</code>（登录失败次数过多）、<code>IncorrectCredentialsException</code> （错误的凭证）、<code>ExpiredCredentialsException</code>（过期的凭证）等，具体查看其继承关系；</li><li>最后可以<code>调用subject.logout退出</code>，其会自动委托给SecurityManager.logout方法退出。</li></ul><h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><blockquote><ol><li>收集用户身份/凭证，即如用户名/密码；</li><li>调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</li><li>最后调用Subject.logout进行退出操作。</li></ol></blockquote><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><blockquote><ol><li><code>用户名/密码硬编码</code>在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；</li><li><code>用户身份Token</code>可能不仅仅是用户名/密码，也可能<code>还有其他的</code>，如登录时允许用户名/邮箱/手机号同时登录。 </li></ol></blockquote><h1 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h1><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-1.png" alt="跟我学Shiro（二）-身份认证/2-1.png"></p><h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote><ol><li>首先<code>调用Subject.login(token)</code>进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li><li><code>SecurityManager</code>负责真正的身份验证逻辑；它会<code>委托给Authenticator进行身份验证</code>；</li><li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处<code>可以自定义插入自己的实现</code>；</li><li>Authenticator可能会委托给相应的AuthenticationStrategy<code>进行多Realm身份验证</code>，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li><li>Authenticator会<code>把相应的token传入Realm，从Realm获取身份验证信息</code>，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li></ol></blockquote><h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><strong>Realm</strong>：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即<code>安全数据源</code>。</p><p>org.apache.shiro.realm.Realm接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String getName(); //返回一个唯一的Realm名字  </div><div class="line">boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  </div><div class="line">AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;  //根据Token获取认证信息</div></pre></td></tr></table></figure></p><h2 id="单Realm配置"><a href="#单Realm配置" class="headerlink" title="单Realm配置"></a>单Realm配置</h2><h3 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h3><blockquote><p>com.github.gojay001.realm.MyRealm1</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> public class MyRealm1 implements Realm &#123;</div><div class="line">    public String getName() &#123;</div><div class="line">        return &quot;myRealm1&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</div><div class="line">        return authenticationToken instanceof UsernamePasswordToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</div><div class="line">        // 得到用户名</div><div class="line">        String username = (String)authenticationToken.getPrincipal();</div><div class="line">        // 得到密码</div><div class="line">        String password = new String((char[])authenticationToken.getCredentials());</div><div class="line">        if(!&quot;root&quot;.equals(username)) &#123;</div><div class="line">            //用户名错误</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line">        if(!&quot;root&quot;.equals(password)) &#123;</div><div class="line">            //密码错误</div><div class="line">            throw new IncorrectCredentialsException();</div><div class="line">        &#125;</div><div class="line">        //如果身份认证验证成功，返回一个AuthenticationInfo实现；</div><div class="line">        return new SimpleAuthenticationInfo(username, password, getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="ini配置文件指定自定义Realm实现"><a href="#ini配置文件指定自定义Realm实现" class="headerlink" title="ini配置文件指定自定义Realm实现"></a>ini配置文件指定自定义Realm实现</h3><blockquote><p>shiro-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#声明一个realm</div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">#指定securityManager的realms实现</div><div class="line">securityManager.realms=$myRealm1</div></pre></td></tr></table></figure><p>通过$name来引入之前的realm定义。</p><h2 id="多Realm配置"><a href="#多Realm配置" class="headerlink" title="多Realm配置"></a>多Realm配置</h2><h3 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-multi-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#声明一个realm  </div><div class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </div><div class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </div><div class="line">#指定securityManager的realms实现  </div><div class="line">securityManager.realms=$myRealm1,$myRealm2</div></pre></td></tr></table></figure><p>securityManager会按照realms指定的顺序进行身份认证。</p><h2 id="Shiro默认提供的Realm"><a href="#Shiro默认提供的Realm" class="headerlink" title="Shiro默认提供的Realm"></a>Shiro默认提供的Realm</h2><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-2.png" alt="跟我学Shiro（二）-身份认证/2-2.png"></p><p>以后一般继承<code>AuthorizingRealm</code>（授权）即可；其继承了<code>AuthenticatingRealm</code>（即身份验证），而且也间接继承了<code>CachingRealm</code>（带有缓存实现）。<br>其中主要默认实现如下：</p><ul><li><strong>org.apache.shiro.realm.text.IniRealm</strong>：<code>[users]部分</code>指定用户名/密码及其角色；<code>[roles]部分</code>指定角色即权限信息；</li><li><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： <code>user.username=password,role1,role2</code>指定用户名/密码及其角色；<code>role.role1=permission1,permission2</code>指定角色及权限信息；</li><li><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过sql查询相应的信息，如<code>“select password from users where username = ?”</code>获取用户密码，<code>“select role_name from user_roles where username = ?”</code>获取用户角色；<code>“select permission from roles_permissions where role_name = ?”</code>获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</li></ul><h2 id="JDBC-Realm使用"><a href="#JDBC-Realm使用" class="headerlink" title="JDBC Realm使用"></a>JDBC Realm使用</h2><h3 id="数据库及依赖"><a href="#数据库及依赖" class="headerlink" title="数据库及依赖"></a>数据库及依赖</h3><blockquote><p><strong>更新</strong>：alibaba的druid包更新版本。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><p>本文将使用mysql数据库及druid连接池。</p><h3 id="数据库下建表"><a href="#数据库下建表" class="headerlink" title="数据库下建表"></a>数据库下建表</h3><p><code>users</code>（用户名/密码）、<code>user_roles</code>（用户/角色）、<code>roles_permissions</code>（角色/权限）；<br>具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。</p><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote><p>shiro-jdbc-realm.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm  </div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource  </div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro  </div><div class="line">dataSource.username=root  </div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource  </div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure><ol><li><code>变量名=全限定类名</code> 自动创建一个类实例</li><li><code>变量名.属性=值</code> 自动调用相应的setter方法进行赋值</li><li><code>$变量名</code> 引用之前的一个对象实例 </li><li><code>测试代码</code>和之前的没什么区别。</li></ol><h1 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Authenticator</strong>的职责是验证用户帐号，<br>是Shiro API中身份验证核心的入口点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；<br>如果验证失败将抛出相应的AuthenticationException实现。</p><p><strong>SecurityManager</strong>接口继承了Authenticator，另外还有一个<code>ModularRealmAuthenticator实现</code>，其委托给多个Realm进行验证，验证规则通过<code>AuthenticationStrategy接口</code>指定，默认提供的实现：</p><ul><li><strong>FirstSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，<code>只返回第一个Realm</code>身份验证成功的认证信息，其他的忽略；</li><li><strong>AtLeastOneSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，和FirstSuccessfulStrategy不同，<code>返回所有Realm</code>身份验证成功的认证信息；</li><li><strong>AllSuccessfulStrategy</strong>：<code>所有Realm验证成功</code>才算成功，且<code>返回所有Realm</code>身份验证成功的认证信息，如果有一个失败就失败了。<blockquote><p><code>ModularRealmAuthenticator</code>默认使用<code>AtLeastOneSuccessfulStrategy</code>策略。</p></blockquote></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>假设有三个realm：<br>myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；<br>myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；<br>myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root；</p></blockquote><h3 id="ini配置文件-1"><a href="#ini配置文件-1" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote><p>shiro-authenticator-all-success.ini</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#指定securityManager的authenticator实现</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#指定securityManager.authenticator的authenticationStrategy</div><div class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</div><div class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</div><div class="line"></div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">myRealm2=com.github.gojay001.realm.MyRealm2</div><div class="line">myRealm3=com.github.gojay001.realm.MyRealm3</div><div class="line">securityManager.realms=$myRealm1,$myRealm3</div></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote><p>com.github.gojay001.test.AuthenticatorTest</p></blockquote><h4 id="首先通用化登录逻辑"><a href="#首先通用化登录逻辑" class="headerlink" title="首先通用化登录逻辑"></a>首先通用化登录逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void login(String configFile) &#123;  </div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </div><div class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </div><div class="line">            new IniSecurityManagerFactory(configFile);  </div><div class="line">  </div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </div><div class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </div><div class="line">    SecurityUtils.setSecurityManager(securityManager);  </div><div class="line">  </div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);  </div><div class="line">  </div><div class="line">    subject.login(token);  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy成功"><a href="#测试AllSuccessfulStrategy成功" class="headerlink" title="测试AllSuccessfulStrategy成功"></a>测试AllSuccessfulStrategy成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test  </div><div class="line">public void testAllSuccessfulStrategyWithSuccess() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">  </div><div class="line">    //得到一个身份集合，其包含了Realm验证成功的身份信息  </div><div class="line">    PrincipalCollection principalCollection = subject.getPrincipals();  </div><div class="line">    Assert.assertEquals(2, principalCollection.asList().size());  </div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="测试AllSuccessfulStrategy失败"><a href="#测试AllSuccessfulStrategy失败" class="headerlink" title="测试AllSuccessfulStrategy失败"></a>测试AllSuccessfulStrategy失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnknownAccountException.class)  </div><div class="line">public void testAllSuccessfulStrategyWithFail() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p><code>shiro-authenticator-all-fail.ini</code> 与 <code>shiro-authenticator-all-success.ini</code> 不同的配置是使用了 <code>securityManager.realms=$myRealm1,$myRealm2</code> ；即myRealm验证失败。</p><p> 对于 <code>AtLeastOneSuccessfulStrategy</code> 和 <code>FirstSuccessfulStrategy</code> 的区别：唯一不同点一个是<code>返回所有</code>验证成功的Realm的认证信息；另一个是<code>只返回第一个</code>验证成功的Realm的认证信息.<code>示例代码同上</code></p></blockquote><h3 id="自定义AuthenticationStrategy实现"><a href="#自定义AuthenticationStrategy实现" class="headerlink" title="自定义AuthenticationStrategy实现"></a>自定义AuthenticationStrategy实现</h3><p>首先看其API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//在所有Realm验证之前调用  </div><div class="line">AuthenticationInfo beforeAllAttempts(  </div><div class="line">Collection&lt;? extends Realm&gt; realms, AuthenticationToken token)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之前调用  </div><div class="line">AuthenticationInfo beforeAttempt(  </div><div class="line">Realm realm, AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之后调用  </div><div class="line">AuthenticationInfo afterAttempt(  </div><div class="line">Realm realm, AuthenticationToken token,   </div><div class="line">AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)  </div><div class="line">throws AuthenticationException;  </div><div class="line">//在所有Realm之后调用  </div><div class="line">AuthenticationInfo afterAllAttempts(  </div><div class="line">AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;</div></pre></td></tr></table></figure></p><p>因为每个<code>AuthenticationStrategy</code>实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；<br>通过如上接口可以进行如合并/返回第一个验证成功的认证信息。<br>自定义实现时一般<code>继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code> 即可。<code>参考代码同上</code></p><blockquote><p>到此基本的身份验证就结束了。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="Assert过时"><a href="#Assert过时" class="headerlink" title="Assert过时"></a>Assert过时</h3><blockquote><p><strong>Assert in junit.framework has been deprecated</strong><br><strong>解决</strong>：将 <code>import junit.framework.Assert;</code> 改为 <code>import org.junit.Assert;</code> </p></blockquote><h3 id="SLF4J加载失败"><a href="#SLF4J加载失败" class="headerlink" title="SLF4J加载失败"></a>SLF4J加载失败</h3><blockquote><p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”<br><strong>解决</strong>：Maven引入slf4j-nop包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p></blockquote><h3 id="implements不需要-Override"><a href="#implements不需要-Override" class="headerlink" title="implements不需要@Override"></a>implements不需要@Override</h3><h3 id="alibaba的druid版本更新"><a href="#alibaba的druid版本更新" class="headerlink" title="alibaba的druid版本更新"></a>alibaba的druid版本更新</h3><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="用户登录流程"><a href="#用户登录流程" class="headerlink" title="用户登录流程"></a>用户登录流程</h3><ul><li>Subject.login(token)</li><li>SecurityManager</li><li>Authenticator</li><li>AuthenticatorStrategy</li><li>Realm</li></ul><h3 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h3><ul><li>单Realm</li><li>多Realm</li><li>JDBCRealm</li></ul><h3 id="AuthenticatorStrategy"><a href="#AuthenticatorStrategy" class="headerlink" title="AuthenticatorStrategy"></a>AuthenticatorStrategy</h3><ul><li>FirstSuccessfulStrategy</li><li>AtLeastOneSuccessfulStrategy</li><li>AllSuccessfulStrategy</li><li>自定义Strategy</li></ul><blockquote><p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2</a></p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
