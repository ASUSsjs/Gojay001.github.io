<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初识Java虚拟机]]></title>
    <url>%2F2017%2F12%2F09%2F%E5%88%9D%E8%AF%86Java%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[前言对于Java的学习也有一段时间了，却始终会有一些地方容易混淆，归结原因，还是偏底层的东西不太了解。前段时间便学习了关于Java虚拟机相关的内容，主要从阅读 《深入理解Java虚拟机》 进行总结。 首先Java技术体系主要由：Java第三方框架类库、Java API类库、Java程序设计语言、Class类文件格式、Java 虚拟机构成，把Java API类库、Java程序设计语言、Java虚拟机统称为JDK，用于支持Java程序开发的最小运行环境。然后从 Java内存 相关的 内存模型 、 内存分配 、 垃圾回收 、 内存溢出 ； 虚拟机执行子系统 相关的 Class类文件结构 、 类加载机制 、 字节码执行引擎 ； 高效并发 相关的 Java内存模型与线程 、 线程安全与锁优化 几个部分进行了Java虚拟机初步的学习。 Java内存内存模型 程序计数器程序计数器(Program Counter Register) 可以看做当前线程所执行的字节码的行号指示器，每条线程都有一个独立的程序计数器，称为 线程私有 内存。如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，则计数器值为空(Undefined)。 虚拟机栈虚拟机栈(Virtual Machine Stacks) 是 线程私有 ，每个方法在执行的同时都会创建一个栈帧(Stack Frame)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息（具体内容在后面会讲到）。每个方法从调用到执行完成对应一个栈帧从入栈到出栈。 经常把Java内存分为堆内存(Heap)和栈内存(Stack)，这里指的栈就是虚拟机栈。 本地方法栈本地方法栈(Native Method Stack) 与虚拟机栈作用类似，只不过不是为Java方法（也就是字节码）服务，而是为虚拟机使用的Native方法服务。 堆堆(Heap) 是被 所有线程共享 的一块内存区域，在虚拟机启动时创建。用于存放对象实例，几乎所有的对象实例以及数组都在堆上分配内存。Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，也是垃圾收集器管理的主要区域。 方法区方法区(Method Area) 是 各个线程共享 的内存区域。用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 有别名叫Non-Heap(非堆)，也被称为“永久代”。 额外：HotSpot虚拟机对象对象的创建 类加载检查：虚拟机遇到new指令，检查这个指令的参数能否定位到一个类的符号引用；并检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，则先执行相应的类加载过程。 为对象分配内存：把一块确定大小的内存从Java堆中划分出来。由Java堆是否规整有两种划分方式， “指针碰撞” ：中间放置一个指针作为分界点的指示器，分配内存就是指针向空闲空间挪动； “空闲列表” ：维护内存块可用的列表，分配内存就是从列表找出一块足够大的空间。 初始化零值：将分配到的内存空间都初始化为零值，不包含对象头。 必要设置：将对象的对象头信息取出进行必要的设置。 ：执行new指令后会执行方法，把对象按照程序员的意愿进行初始化。 对象的内存布局 对象头：对象头包含两部分信息，“Mark Word”用于存储对象自身的运行时数据；“类型指针”用于存储对象指向它的类元数据的指针。 实例数据：在程序代码中所定义的各种类型的字段内容。 对齐填充：不是必然存在的，只是起着占位符的作用。 内存的访问定位 使用句柄：Java堆划分一块内存作为句柄池，reference存储句柄地址。句柄中包含 对象实例数据 和 类型数据的具体地址。 直接地址访问：Java堆的对象考虑如何放置访问类型数据的相关信息。reference存储的是对象地址。 内存溢出Java堆溢出Java堆用于存储对象实例，不断创建对象，当避免垃圾回收机制，在对象数量达到最大堆的容量限制后就会产生内存溢出异常。 虚拟机栈和本地方法栈溢出 线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常。 虚拟机在扩展栈时无法申请到足够的内存空间，将抛出 OutOfMemoryError 异常。 方法区溢出方法区用于存放Class相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，当运行时产生大量的类填满方法区时会产生内存溢出。 垃圾回收对象是否可回收引用计数算法引用计数算法 是给对象添加一个引用计数器，当一个地方引用时，计数器值加1；当引用失效时，计数器值减1；当计数器值为0时说明对象不可用。 不能解决对象之间相互循环引用的问题。 可达性分析算法可达性分析 是选取 “GC Roots” 对象作为起始点，向下搜索走过的路径称为 引用链 ；当一个对象到GC Roots没有任何引用链的时候则说明对象不可用。 Java语言中可作为引用链的对象包括：虚拟机栈、方法区中类静态属性、方法区常量、本地方法栈Native方法引用的对象。 两次标记在可达性分析算法中不可达的对象还需要经历两次标记才真正回收。 是否有必要执行finalize()方法：当对象 没有覆盖finalize()方法 或者finalize()方法 已经被虚拟机调用过 则视为没有必要执行。 重新引用：如果对象有必要执行finalize()方法，则会将对象放置在F-Queue队列中，由低优先级Finalizer线程执行，在此过程中只要 重新与引用链上一个对象建立关联 则会移除回收队列。 垃圾回收算法标记-清除算法 标记所有需要回收对象。 回收所有被标记对象。 复制算法将内存按容量划分为两块，每次只使用其中一块。 标记回收对象。 将存活对象复制到另一块。 已使用内存空间全部回收。 标记-整理算法 标记回收对象。 将存活对象向一端移动。 回收边界以外内存。 分代收集算法根据对象存活周期将Java堆划分为新生代和老年代，不同年代使用不同的垃圾回收算法。 垃圾收集器 Serial收集器Serial收集器 是负责新生代的收集的单线程收集器。垃圾回收时会暂停其他所有的工作线程，直到收集结束。 ParNew收集器ParNew收集器 是Serial收集器的多线程版本。除了Serial收集器，只有它能与CMS收集器配合工作。 Parallel Scavenge收集器Parallel Scavenge收集器 也是使用复制算法的多线程收集器。目的是达到一个可控制的吞吐量， 吞吐量=运行用户代码时间 / （运行用户代码时间+垃圾回收时间） ，也被称为 “吞吐量优先”收集器。 Serial Old收集器Serial Old收集器 是Serial收集器的老年代版本，使用标记-整理算法的单线程收集器。 Parallel Old收集器Parallel Old 是Parallel Scavenge收集器的老年代版本，使用标记-整理算法的多线程收集器。 CMS收集器CMS收集器 是使用标记-清除算法的多线程收集器，目的是获取最短回收停顿时间。 初始标记(CMS initial mark) 并发标记(CMS concurrent mark) 重新标记(CMS remark) 并发清除(CMS concurrent sweep) G1收集器G1收集器 在后台维护一个优先列表，根据允许的收集时间，优先回收价值（回收所获得的空间大小以及所需时间）最大的Region。 初始标记(Initial Marking) 并发标记(Concurrent Marking) 最终标记(Final Marking) 筛选回收(Live Data Counting and Evacuation) 理解GC日志GC日志是一些人为确定的规则，每个日志格式有收集器决定。通常来看由以下几个部分组成： GC发生时间 、 GC停顿类型 、 GC发生区域 、 GC前后内存使用情况 、 GC所占用时间。 内存分配对象优先在Eden分配大多情况下，对象在新生代Eden区域中分配。Eden空间不足时，虚拟机发起一次Minor GC。Minor GC过程：将Eden区域对象放入Survivor空间，若无法放入则通过分配担保机制提前进入到老年代。 新生代GC(Minor GC)：Minor GC频繁，回收速度快。老年代GC(Major GC/Full GC)：Full GC速度一般比Minor GC慢10倍。 空间分配担保在Minor GC前，虚拟机会先检查老年代连续空间是否大于新生代对象总大小。若成立，则Minor GC安全；若不成立，虚拟机会查看是否允许担保失败。担保：取每一次进入老年代对象的平均值与老年代剩余空间比较，若不足则进行Full GC。 大对象直接进入老年代大对象指需要 大量连续内存空间 的Java对象。当所需空间大于设置值时直接进入老年代分配，目的在于避免在Eden区及两个Survivor区之间发生大量的内存复制。 长期存活的对象进入老年代年龄计数器：对象在Survivor区每过一次Minor GC则年龄加1。当年龄大于设置值(默认为15)则进入老年代。对象年龄动态判断：如果在Survivor空间中， 相同年龄 所有对象大小超过Survivor空间的一半，年龄大于或等于该年龄的对象进入老年代。 虚拟机执行子系统Class类文件结构概述 Class文件是一组以 8个字节为单位 的二进制流，对应着类或接口的定义信息，是实现 平台无关性 和 语言无关性 的基础。 Class文件格式采用 伪结构 存储数据，这种伪结构只有两种数据类型：无符号数(u1、u2、u4、u8代表x个字节的无符号数)，表(由多个无符号数或其他表构成，习惯以_info结尾)。 Class文件格式 魔数：前 4个字节 ，值为：0xCAFEBABE。 Class版本号：紧接着魔数的 4个字节 ，分别为：次版本号、主版本号。 常量池：紧接着Class版本号，常量数量 不固定 ，入口放置一项u2类型的 常量池容量计数器 。主要存放 字面量 (Java中常量)和 符号引用 (类、接口、字段、方法的名称和描述符)。 访问标志：紧接着常量池的 2个字节 ，用于标识一些类或接口层次的 访问信息 。 类索引、父类索引、接口索引：排列着访问标志之后，类索引和父类索引用两个u2类型表示，接口索引是一组u2类型的集合；索引用于确定 全限定名 来确定这个类的 继承关系 。 字段表集合：用于描述接口或者类中声明的 变量信息 。字段信息需要 引用常量池 中的常量来描述，无法固定大小。 方法表集合：与字段表相似，用于 描述方法 定义的标志、名称索引、描述符索引。 属性表集合：Class文件、字段表、方法表都可以携带自己的属性表集合，用于 描述特定信息 。预定义包含Code、Exception、LineNumberTable、LocalVariableTable等属性。 全限定名：把类全名中的”.”替换成了”/“，如com/baidu/www/class/TestClass。简单名称：没有类型和参数修饰的方法或者字段名称，如inc()方法和m字段简称为inc和m。描述符：描述字段的数据类型、方法的参数类型、返回值。 基本类型和void用一个大写字符表示，I。 对象类型用大写字符L加对象全限定名表示，Ljava/lang/String。 数组类型的每一个维度使用一个前置的[字符描述，如[[Ljava/lang/String、[I。 方法：先参数列表，后返回值，如()V、()Ljava/lang/String、([CII[CIII)I。 字节码指令 Java虚拟机的指令由操作码(一个字节长度的数字)和操作数(零至多个代表此操作所需的参数)构成。 字节码与数据类型由于Java虚拟机的操作码长度只有1个字节，指令集将会故意被设计为非完全独立，即并非每种数据类型和每一种操作都有对应的指令。大部分的指令都没有支持boolean、byte、char、short类型的操作，实际上都是使用相应的int类型作为运算类型。 加载和存储指令加载和存储指令 用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。 将局部变量加载到操作数栈：iload等。 将一个数值从操作数栈存储到局部变量表：istore等。 将一个常量加载到操作数栈：bipush、sipush、iconst_m1等。 扩充局部变量表的访问索引指令：wide。 运算指令运算或算数指令 用于对两个操作数栈的值进行某种特定运算，并把结果重新存入到操作数栈顶。都使用Java虚拟机的数据类型，boolean、byte、char、short的运算都会转为int类型。算数指令有：加法(iadd、ladd、fadd、dadd)、减法(sub)、乘法(mul)、除法(div)、求余(rem)、取反(neg)、位移、按位或、按位与、按位异或、局部变量自增、比较。 类型转换指令类型转换指令用于将两种不同的数值类型进行相互转换。 宽化 类型转换无需显式的转换指令。 窄化 必须显示转换：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f。 其他指令其他指令可以查看虚拟机字节码指令，这里不全部列出，主要有：对象创建与访问指令、操作数栈管理指令、控制转移指令、方法调用和返回指令、异常处理指令、同步指令。 虚拟机类加载机制类加载机制指虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的Java类型。 类加载的时机类的生命周期 加载、连接（验证、准备、解析）、初始化、使用、卸载。 对类主动引用有且只有5中情况需要立即对类进行初始化： 遇到new、getstatic、putstatic、invokestatic这4个字节码时，如果类没有过初始化，则需要先触发其初始化。Java代码场景： new实例化对象 、 读取或设置一个类的静态字段 、 调用一个类的静态方法。 使用 java.lang.reflect包 的方法对类进行反射调用时，该类没有过初始化需要触发初始化。 当初始化一个类，其父类没有过初始化需要先初始化父类。 虚拟机启动时，需要先初始化含main()方法的主类。 java.lang.invoke.MethodHandle实例解析句柄对应的类需要初始化。 被动引用所有被动引用类都不会触发初始化。 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 通过数组定义来引用类*，不会触发此类的初始化。 调用类的常量，由于常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用类，不会触发该类的初始化。 接口不要求其父接口都完成了初始化，只有在真正使用父接口的时候(引用接口的常量)才会初始化。 类加载的过程Java虚拟机中类加载全过程：加载、验证、准备、解析、初始化。 加载 通过一个类的全限定名来获取定义此类的二进制流。 将这个字节流按照虚拟机所需的格式存储在方法区中。 在内存中生成一个代表这个类的java.lang.Class对象(HotSpot虚拟机存放在方法区中)，作为方法区这个类的各种数据的访问入口。 验证确保Class文件的字节流中包含的信息符合虚拟机的要求。 文件格式验证：对Class文件格式中魔数、版本号、常量池等进行验证，保证字节流能正常解析并存储到方法区。 元数据验证：对字节码描述的信息该类是否有父类、是否继承final类等进行语义分析，保证符合Java语言规范。 字节码验证：通过数据流和控制流分析，确定程序语义是符合逻辑的。 符号引用验证：对类自身以外(常量池中的各种符号引用)的信息进行匹配性验证。 准备为类变量(static修饰)分配内存并设置初值(数据类型的零值)。 解析虚拟机将常量池内的符号引用替换为直接引用。 符号引用：以一组符号来描述所引用的目标，引用目标并不一定已经加载到内存中。 直接引用：直接引用是直接指向目标的指针、偏移量或者是一个能够间接定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符这几类符号引用进行。 类或接口的解析假设当前代码所处的 类为D ，要把一个从未解析过的 符号引用N 解析为一个 类或接口C 的直接引用： 如果C不是一个数组类型，虚拟机会把代表N的全限定名传递给D的类加载器去加载这个类C；可能会触发其他相关类的加载，如父类或实现的接口。 如果C是一个数组类型，数组的元素类型为对象按照上一点规则加载；数组的元素类型为基本类型则由虚拟机生成一个代表此数组维度和元素的数组对象。 如果以上步骤没有异常，则C在虚拟机中已经成为一个有效的类或接口。 字段解析 解析字段所属的类或接口的符号引用。 与类中匹配目标的简单名称和字段描述符。 按照继承关系从下往上递归搜索接口和父接口。 如果不是java.lang.Object，搜索其父类。 否则，查找失败。 类方法解析 解析方法所属的类或接口的符号引用。 在类中查找简单名称和描述符。 在类的父类中查找简单名称和描述符。 在类实现的接口列表和父接口中匹配。 否则，查找失败。 接口方法解析 解析方法所属的类或接口的符号引用。 在接口中查找简单名称和描述符。 在父接口中查找简单名称和描述符。 否则，查找失败。 初始化开始执行类中定义的Java程序代码(字节码)。初始化阶段时执行类构造器()方法的过程。 ()方法是由编译器自动收集类中的类变量赋值和静态语句块。静态语句块中只能访问到定义在静态语句块之前变量， 之后的变量只能赋值不能访问。 ()方法实例构造器()方法不同，不需要显式调用父类构造器，保证父类()方法在子类()方法前执行。 由于父类先执行()方法，父类定义的静态语句块先于子类，第一个被执行()方法的类是java.lang.Object。 ()方法对呀类或接口不是必需的。 虚拟机会保证一个类的()方法在多线程环境中正确被加锁、同步。 类加载器类加载器是实现让应用程序自己决定如何去获取所需要的类的代码模块。 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性。 双亲委派模型 启动类加载器(Bootstrap ClassLoader)：负责将存放在目录下的类库加载到虚拟机内存中。 扩展类加载器(Extension ClassLoader)：负责加载目录中的类库。 应用程序类加载器(Application ClassLoader)：负责加载用户类路径(ClassPath)指定的类库。 双亲委派模型的工作流程：如果一个类加载器收到类加载的请求，首先将这个请求委派给父类加载器去完成，最终传送到顶层的启动类加载器；当父加载器反馈无法完成这个加载请求，子加载器才会尝试加载。 破坏双亲委派模型 第一次：JDK 1.2发布前，重写loadClass()方法。 第二次：模型自身缺陷，线程上下文类加载器可以实现父类加载器请求子类加载器去完成类加载动作。 第三次：对程序动态性的追求。 字节码执行引擎运行时栈帧结构栈帧(Stack Frame) 是用于支持虚拟机进行方法调用和方法执行的数据结构，存储了局部变量表、操作数栈、动态连接、方法返回地址等信息。每一个方法从调用开始到执行完成对应栈帧在虚拟机从入栈到出栈的过程。 局部变量表局部变量表(Local Variable Table) 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，每个Slot都能存放一个 boolean 、 byte 、 char 、 short 、 int 、 float 、 reference 、 returnAddress 类型的数据。reference类型表示对一个对象的引用，通过引用要做到两点：从此引用中直接或间接地查找到到对象在 Java堆 中的数据存放的起始 地址索引 ；此引用中直接或间接查找到对象所属数据类型在 方法区 中的存储的 类型 信息。虚拟机通过索引定位的方式使用局部变量表。如果执行的实例方法(非static)，局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字this访问该隐含参数。其他参数按照参数表顺序排序，局部变量表的Slot可以重用。如果一个局部变量 定义 了但没有 赋初始值 会导致类加载失败。 操作数栈操作数栈(Operand Stack) 是一个 后入先出(Last In First Out) 栈，每一个元素可以是任意的Java数据类型。在方法执行过程，各种字节码指令往操作数栈中写入和提取内容，也就是入栈/出栈操作。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在每一次运行时期将符号引用转化为直接引用称为动态连接。 返回地址方法在退出后，都需要返回到方法被调用的位置，栈帧保存返回地址信息。 方法调用方法调用的目的是确定被调用方法的版本，即调用哪一个方法。 解析所有的方法调用中的目标方法在Class文件中都是一个常量池中的符号引用。在类加载的解析阶段，将会把一部分符号引用转化为直接引用，解析前提是 “编译期可知，运行期不可变” 。 对应的调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic。 符合条件：静态方法、私有方法、实例构造器、父类方法、final修饰方法。 分派静态分派所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。(方法重载) 静态类型在编译期可知。 实际类型变化的结果在运行期确定。 重载方法匹配优先级以’a’为例： char-&gt;int-&gt;long-&gt;float-&gt;double java.lang.Character java.lang.Serializable、java.lang.Comparable 装箱转型为父类 变长参数 动态分派运行期根据实际类型确定方法执行版本的分派过程称为动态分派。(方法重写) 单分配与多分配方法宗量：方法接受者+方法参数。根据分派基于多少种宗量划分为单分配和多分配。 静态分派：选择目标方法。(静态类型+方法参数) 动态分派：方法接受者的实际类型。 Java是静态多分配、动态单分配的语言。 高效并发Java内存模型与线程Java内存模型 主内存与工作内存Java内存模型的目的是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量的底层细节。 这里的变量与Java编程中所说的变量不同，它包括实例字段、静态字段、构成数组对象的元素，不包括局部变量和方法参数。 Java内存模型规定 所有变量都存储在主内存。 每天线程有自己的工作内存。 工作内存保存主内存的副本拷贝。 线程对变量的所有操作（读取、赋值等）都在工作内存中进行。 主内存对应于Java堆中的对象实例数据部分。工作内存对应虚拟机栈中的部分区域。 内存间交互操作 lock：把一个变量标识为一条线程独占状态。 unlock：释放锁定变量。 read：把变量从主内存读取到工作线程。 load：把read操作读取的变量值放入工作内存变量副本中。 use：把工作内存的变量值传递给执行引擎。 assign：从执行引擎接收变量值到工作线程。 store：把工作线程的变量值传到主内存中。 write：把store操作得到的变量值放入主内存的变量中。 原子性、可见性、有序性 原子性：线程从运行开始会一直到运行结束，不会被方法调度打断或进行线程切换。 可见性：当一个线程修改了共享变量的值，其他线程能够立即得到这个修改。 有序性：禁止指令重排序，在本线程中表现为串行，整体表现为指令重排序。 volatile关键字 保证了可见性和有序性。 Java运算并非原子操作，导致volatile变量的运算在并发下不安全。 需要确保运算结果并不依赖变量的当前值来保证原子性。 synchronized同步块同时保证了原子性、可见性、有序性。 先行发生原则先行发生是Java内存模型中定义的两项操作之间的偏序关系。如果操作A先行于操作B，则操作A产生的影响能够被操作B观察到。 Java内存模型预定义的先行发生关系 程序次序规则：一个线程中，按照程序代码顺序。 管程锁定规则：unlock操作先行于同一个锁的lock操作。 volatile变量规则：volatile变量的写操作先行于后面的读操作。 线程启动规则：Thread对象的start()方法优先。 线程终止规则：Thread.join()方法结束最后。 线程中断规则：interrupt()方法先行于中断事件。 对象终结规则：一个对象的初始化完成先行于finalize()方法。 传递性：A先行于B，B先行于C，则A先行于C。 时间先后顺序与先行发生规则基本没有关系。 Java与线程线程的实现各个线程既可以共享进程资源，又可以独立调度。 实现线程的方式 使用内核线程实现：直接由操作系统内核支持的线程，用内核线程支持 轻量级进程(LWP) 实现。 使用用户线程实现：用户线程(UT) 完全建立在用户空间的线程库，不需要切换到内核态。 混合实现：既存在用户线程，也存在轻量级进程。 Java线程调度线程调度指系统为线程分配处理器的使用权。 协同式调度：线程的执行时间由自己控制，线程自身执行完后主动通知系统切换到另一个线程。 抢占式调度：每个线程由系统分配执行时间，可以设置线程优先级。 状态转换 新建(New)：创建后尚未启动的线程。 运行(Runable)：包括Running和Ready。 无限期等待(Wating)：等待其他线程显式唤醒。 限期等待(Timed Wating)：一定时间后由系统自动唤醒。 阻塞(Blocked)：等待获取一个排它锁，在另一个线程放弃这个锁时发生。 结束(Terminated)：已终止线程。 线程安全与锁优化线程安全线程安全指当多个线程访问一个对象时，调用这个对象的行为都可以像单线程一样得到正确的结果。 共享数据类型 不可变：不可变的对象一定是线程安全的，如String。 绝对线程安全：在多线程环境中需要在方法调用端做额外的同步措施。 相对线程安全：需要保证这个对象单独的操作是线程安全的，如：Vector、HashTable等。 线程兼容：对象本身并不是线程安全的，可以通过在调用端正确使用同步手段保证线程安全，如ArrayList、HashMap等。 线程对立：无论调用端是否采用同步措施，都无法在多线程环境中并发使用。 线程安全的实现 互斥同步：synchronized或java.util.concurrent包中ReentrantLock实现。 非阻塞同步：先进行操作，产生了冲突再采取补偿措施，也称为“乐观锁”。 无同步方案：可重入代码、线程本地存储。 锁优化 自旋锁：不放弃处理器的执行时间，让线程执行一个忙循环（自旋）。 锁消除：对一些代码要求同步却被检测到不可能存在共享数据竞争的锁进行消除。 锁粗化：如果一系列的连续操作都对同一个对象反复加锁和解锁，则将加锁同步范围扩展到整个操作序列的外部。 轻量级锁 偏向锁]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（六）-Realm及相关对象]]></title>
    <url>%2F2017%2F11%2F29%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%85%AD%EF%BC%89-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Realm定义实体及关系用户-角色之间是多对多关系，角色-权限之间是多对多关系；且用户和权限之间通过角色建立关系。在系统中验证时通过权限验证，角色只是权限集合，即所谓的显式角色。 用户实体包括：编号id、用户名username、密码password、盐salt、是否锁定locked； 角色实体包括：、编号id、角色标识符role、描述description、是否可用available； 权限实体包括：编号id、权限标识符permission、描述description、是否可用available。 另外还有两个关系实体：用户-角色实体：用户编号、角色编号，且组合为复合主键）；角色-权限实体：角色编号、权限编号，且组合为复合主键）。 环境准备为了方便数据库操作，使用 org.springframework: spring-jdbc: 4.0.0.RELEASE 依赖。 定义Service及Dao 为了实现的简单性，只实现必须的功能，其他的可以自己实现即可。 PermissionService实现基本的创建/删除权限。1234public interface PermissionService &#123; public Permission createPermission(Permission permission); public void deletePermission(Long permissionId); &#125; RoleService相对于PermissionService多了关联/移除关联角色-权限功能。12345678public interface RoleService &#123; public Role createRole(Role role); public void deleteRole(Long roleId); // 添加角色-权限之间关系 public void correlationPermissions(Long roleId, Long... permissionIds); // 移除角色-权限之间关系 public void uncorrelationPermissions(Long roleId, Long... permissionIds); &#125; UserService使用 findByUsername 、 findRoles 及 findPermissions 来查找用户名对应的帐号、角色及权限信息。 之后的Realm就使用这些方法来查找相关信息。 12345678910111213141516public interface UserService &#123; // 创建账户 public User createUser(User user); // 修改密码 public void changePassword(Long userId, String newPassword); // 添加用户-角色关系 public void correlationRoles(Long userId, Long... roleIds); // 移除用户-角色关系 public void uncorrelationRoles(Long userId, Long... roleIds); // 根据用户名查找用户 public User findByUsername(String username); // 根据用户名查找其角色 public Set&lt;String&gt; findRoles(String username); // 根据用户名查找其权限 public Set&lt;String&gt; findPermissions(String username); &#125; UserServiceImpl在创建账户及修改密码时直接把生成密码操作委托给 PasswordHelper。1234567891011public User createUser(User user) &#123; // 加密密码 passwordUtils.encryptPassword(user); return userDao.createUser(user); &#125; public void changePassword(Long userId, String newPassword) &#123; User user =userDao.findOne(userId); user.setPassword(newPassword); passwordUtils.encryptPassword(user); userDao.updateUser(user); &#125; PasswordUtils之后的CredentialsMatcher需要和此处加密的算法一样。user.getCredentialsSalt()辅助方法返回username+salt。123456789101112131415public class PasswordUtils &#123; private RandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator(); private String algorithmName = &quot;md5&quot;; private final int hashIterations = 2; public void encryptPassword(User user) &#123; user.setSalt(randomNumberGenerator.nextBytes().toHex()); String newPassword = new SimpleHash( algorithmName, user.getPassword(), ByteSource.Util.bytes(user.getCredentialsSalt()), hashIterations).toHex(); user.setPassword(newPassword); &#125; &#125; 为了节省篇幅，对于DAO/Service的接口及实现，具体请参考源码 com.github.gojay001 ；另外参考Service层的测试用例 com.github.gojay001.service.ServiceTest 。 定义RealmRetryLimitHashedCredentialsMatcher com.github.gojay001.credentials 1234567891011121314151617181920212223242526272829303132public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher &#123; private Ehcache passwordRetryCache; public RetryLimitHashedCredentialsMatcher() &#123; CacheManager cacheManager = CacheManager.newInstance(CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;)); passwordRetryCache = cacheManager.getCache(&quot;passwordRetryCache&quot;); &#125; @Override public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; String username = (String)token.getPrincipal(); // retry count + 1 Element element = passwordRetryCache.get(username); if(element == null) &#123; element = new Element(username , new AtomicInteger(0)); passwordRetryCache.put(element); &#125; AtomicInteger retryCount = (AtomicInteger)element.getObjectValue(); if(retryCount.incrementAndGet() &gt; 5) &#123; // if retry count &gt; 5 throw throw new ExcessiveAttemptsException(); &#125; boolean matches = super.doCredentialsMatch(token, info); if(matches) &#123; // clear retry count passwordRetryCache.remove(username); &#125; return matches; &#125;&#125; UserRealm com.github.gojay001.realm 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserRealm extends AuthorizingRealm &#123; private UserService userService = new UserServiceImpl(); @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123; String username = (String)principals.getPrimaryPrincipal(); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.setRoles(userService.findRoles(username)); authorizationInfo.setStringPermissions(userService.findPermissions(username)); return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; String username = (String)token.getPrincipal(); User user = userService.findByUsername(username); //没找到帐号 if(user == null) &#123; throw new UnknownAccountException(); &#125; //帐号锁定 if(Boolean.TRUE.equals(user.getLocked())) &#123; throw new LockedAccountException(); &#125; // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现 return new SimpleAuthenticationInfo( user.getUsername(), user.getPassword(), // salt=username+salt ByteSource.Util.bytes(user.getCredentialsSalt()), //realm name getName() ); &#125;&#125; UserRealm父类AuthorizingRealm将获取Subject相关信息分成两步：获取身份验证信息 doGetAuthenticationInfo 及授权信息 doGetAuthorizationInfo ； doGetAuthenticationInfo：首先根据传入的用户名获取User信息；在组装SimpleAuthenticationInfo信息时，需要传入：身份信息用户名、凭据密文密码、盐username+salt， CredentialsMatcher 使用盐加密传入的明文密码和此处的密文密码进行匹配。 doGetAuthorizationInfo：PrincipalCollection 是一个身份集合，因为我们现在就一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的用户名即可；然后根据用户名调用UserService接口获取角色及权限信息。 AuthenticationTokenAuthenticationToken用于收集用户提交的身份 用户名 及凭据 密码 ：1234public interface AuthenticationToken extends Serializable &#123; Object getPrincipal(); Object getCredentials(); &#125; RememberMeAuthenticationToken：提供了 boolean isRememberMe() 记住我的功能； HostAuthenticationToken：提供了 String getHost() 方法用于获取用户主机的功能。 Shiro提供了一个直接拿来用的UsernamePasswordToken，用于实现用户名/密码Token组。实现了 RememberMeAuthenticationToken 和 HostAuthenticationToken ，可以实现记住我及主机验证的支持。 AuthenticationInfoAuthenticationInfo有两个作用： 如果Realm是 AuthenticatingRealm 子类，则提供给 AuthenticatingRealm 内部使用的 CredentialsMatcher 进行凭据验证；（如果没有继承它需要在自己的Realm中自己实现验证）。 提供给 SecurityManager 来创建 Subject （提供身份信息）。 MergableAuthenticationInfo用于提供在多Realm时合并AuthenticationInfo的功能，主要合并Principal。比如 HashedCredentialsMatcher ，在验证时会判断 AuthenticationInfo 是否是SaltedAuthenticationInfo子类，来获取盐信息。Account相当于我们之前的 User ， SimpleAccount 是其一个实现。其他情况一般返回SimpleAuthenticationInfo即可。 PrincipalCollection因为我们可以在Shiro中同时配置多个Realm，所以身份信息可能就有多个；因此其提供了PrincipalCollection用于聚合这些身份信息：123456789101112131415161718public interface PrincipalCollection extends Iterable, Serializable &#123; // 得到主要的身份 Object getPrimaryPrincipal(); // 根据身份类型获取第一个 &lt;T&gt; T oneByType(Class&lt;T&gt; type); // 根据身份类型获取一组 &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type); // 转换为List List asList(); // 转换为Set Set asSet(); // 根据Realm名字获取 Collection fromRealm(String realmName); // 获取所有身份验证通过的Realm名字 Set&lt;String&gt; getRealmNames(); // 判断是否为空 boolean isEmpty(); &#125; getPrimaryPrincipal：如果只有一个Principal那么直接返回即可，如果有多个Principal，则返回第一个（因为内部使用Map存储，所以可以认为是返回任意一个）；oneByType/byType：根据凭据的类型返回相应的Principal；fromRealm根据Realm名字（每个Principal都与一个Realm关联）获取相应的Principal。 MutablePrincipalCollection是一个可变的PrincipalCollection接口，即提供了如下可变方法：12345678910public interface MutablePrincipalCollection extends PrincipalCollection &#123; // 添加Realm-Principal的关联 void add(Object principal, String realmName); // 添加一组Realm-Principal的关联 void addAll(Collection principals, String realmName); // 添加PrincipalCollection void addAll(PrincipalCollection principals); // 清空 void clear();&#125; AuthorizationInfoAuthorizationInfo用于聚合授权信息的：12345678public interface AuthorizationInfo extends Serializable &#123; // 获取角色字符串信息 Collection&lt;String&gt; getRoles(); // 获取权限字符串信息 Collection&lt;String&gt; getStringPermissions(); // 获取Permission对象信息 Collection&lt;Permission&gt; getObjectPermissions(); &#125; 当我们使用 AuthorizingRealm 时，如果身份验证成功，在进行授权时就通过 doGetAuthorizationInfo 方法获取角色/权限信息用于授权验证。 Shiro提供了一个实现 SimpleAuthorizationInfo ，大多数时候使用这个即可。 SubjectSubject是Shiro的核心对象，基本所有身份验证、授权都是通过Subject完成。 身份信息获取1234// Primary PrincipalObject getPrincipal(); // PrincipalCollectionPrincipalCollection getPrincipals(); 身份验证123void login(AuthenticationToken token) throws AuthenticationException; boolean isAuthenticated(); boolean isRemembered(); 角色授权验证123456boolean hasRole(String roleIdentifier); boolean[] hasRoles(List&lt;String&gt; roleIdentifiers); boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers); void checkRole(String roleIdentifier) throws AuthorizationException; void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException; void checkRoles(String... roleIdentifiers) throws AuthorizationException; 权限授权验证12345678910boolean isPermitted(String permission); boolean isPermitted(Permission permission); boolean[] isPermitted(String... permissions); boolean[] isPermitted(List&lt;Permission&gt; permissions); boolean isPermittedAll(String... permissions); boolean isPermittedAll(Collection&lt;Permission&gt; permissions); void checkPermission(String permission) throws AuthorizationException; void checkPermission(Permission permission) throws AuthorizationException; void checkPermissions(String... permissions) throws AuthorizationException; void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException; 会话123// 相当于getSession(true)Session getSession(); Session getSession(boolean create); 如果 create=false 如果没有会话将返回null；而 create=true 如果没有会话会强制创建一个。 退出1void logout(); RunAs1234void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException; boolean isRunAs(); PrincipalCollection getPreviousPrincipals(); PrincipalCollection releaseRunAs(); RunAs即实现允许A假设为B身份进行访问： 通过调用 subject.runAs(b) 进行访问；接着调用 subject.getPrincipals 将获取到B的身份；此时调用 isRunAs 将返回true，而a的身份需要通过 subject.getPreviousPrincipals 获取；如果不需要RunAs了调用 subject.releaseRunAs 即可。 多线程1234&lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException; void execute(Runnable runnable); &lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable); Runnable associateWith(Runnable runnable); 在多线程执行中需要传播到相应的线程才能获取到相应的Subject。最简单的办法就是通过 execute(runnable/callable实例) 直接调用；或者通过 associateWith(runnable/callable实例) 得到一个包装后的实例；它们都是通过：把当前线程的Subject绑定过去；在线程执行结束后自动释放。 Subject自己不会实现相应的身份验证/授权逻辑，而是通过DelegatingSubject委托给SecurityManager实现。 如果想自定义创建，可以通过：1new Subject.Builder().principals(身份).authenticated(true/false).buildSubject() Subject一般流程 身份验证（login） 授权（hasRole*/isPermitted*或checkRole*/checkPermission*） 将相应的数据存储到会话（Session） 切换身份（RunAs）/多线程身份传播 退出 必须的功能就是1、2、5。到目前为止我们就可以使用Shiro进行应用程序的安全控制了，但是还是缺少如对Web验证、Java方法验证等的一些简化实现。 总结Realm Permission Role User User-Role Role-Permission AuthenticationToken Principal Credentials RemeberMeAuthenticationToken HostAuthenticationToken UsernamePasswordToken AuthenticationInfo 提供身份信息 提供凭据验证 SimpleAuthenticationInfo PrincipalCollection Principal MutablePrincipalCollection PrincipalMap AuthorizationInfo Roles StringPermissions ObjectPermissions SimpleAuthorizationInfo Subject 身份获取 身份验证 角色授权 权限授权 会话 退出 RunAs 多线程 参考代码： https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter6]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
        <tag>Realm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（五）-编码、加密]]></title>
    <url>%2F2017%2F11%2F29%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[在涉及到密码存储问题上，应该加密/生成密码摘要存储，而不是存储明文密码。 编码/解码Shiro提供了 base64 和 16进制字符串 编码/解码的API支持，方便一些编码解码操作。Shiro内部的一些数据的存储/表示都使用了base64和16进制字符串。1234String str = &quot;hello&quot;; String base64Encoded = Base64.encodeToString(str.getBytes()); String str2 = Base64.decodeToString(base64Encoded); Assert.assertEquals(str, str2); 通过如上方式可以进行base64编码/解码操作。1234String str = &quot;hello&quot;; String base64Encoded = Hex.encodeToString(str.getBytes()); String str2 = new String(Hex.decode(base64Encoded.getBytes())); Assert.assertEquals(str, str2); 通过如上方式可以进行16进制字符串编码/解码操作。 还有一个可能经常用到的类CodecSupport，提供了toBytes(str, &quot;utf-8&quot;) / toString(bytes, &quot;utf-8&quot;)用于在byte数组/String之间转换。 散列（Hash）算法散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如MD5、SHA等。 一般进行散列时最好提供一个salt（盐），如用户名和ID（即盐）；这样散列的对象是“密码+用户名+ID”，这样生成的散列值相对来说更难破解。 MD5123String str = &quot;hello&quot;; String salt = &quot;123&quot;; String md5 = new Md5Hash(str, salt).toString();//还可以转换为 toBase64()/toHex() 如上代码使用MD5算法通过盐“123”生成MD5散列。另外散列时还可以指定散列次数，如2次表示：md5(md5(str))：new Md5Hash(str, salt, 2).toString()。 SHA123String str = &quot;hello&quot;; String salt = &quot;123&quot;; String sha1 = new Sha256Hash(str, salt).toString(); 使用SHA256算法生成相应的散列数据，另外还有如SHA1、SHA512算法。 通用的散列支持1234String str = &quot;hello&quot;; String salt = &quot;123&quot;; //内部使用MessageDigest String simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString(); 通过调用 SimpleHash 时指定散列算法，其内部使用了Java的 MessageDigest 实现。 为了方便使用，Shiro提供了 HashService ，默认提供了 DefaultHashService 实现。12345678910111213141516// 默认算法SHA-512DefaultHashService hashService = new DefaultHashService(); hashService.setHashAlgorithmName(&quot;SHA-512&quot;);// 私盐，默认无hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); // 是否生成公盐，默认falsehashService.setGeneratePublicSalt(true);// 用于生成公盐。默认就这个hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator());// 生成Hash值的迭代次数hashService.setHashIterations(1); HashRequest request = new HashRequest.Builder() .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;)) .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build(); String hex = hashService.computeHash(request).toHex(); 首先创建一个 DefaultHashService ，默认使用SHA-512算法； 可以通过 hashAlgorithmName 属性修改算法； 可以通过 privateSalt 设置一个私盐，其在散列时自动与用户传入的公盐混合产生一个新盐； 可以通过 generatePublicSalt 属性在用户没有传入公盐的情况下是否生成公盐； 可以设置 randomNumberGenerator 用于生成公盐； 可以设置 hashIterations 属性来修改默认加密迭代次数； 需要构建一个 HashRequest ，传入算法、数据、公盐、迭代次数。 SecureRandomNumberGenerator用于生成一个随机数：1234SecureRandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator(); randomNumberGenerator.setSeed(&quot;123&quot;.getBytes()); String hex = randomNumberGenerator.nextBytes().toHex(); 加密/解密Shiro提供对称式加密/解密算法的支持，如AES、Blowfish等。当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。 AES算法实现1234567891011121314AesCipherService aesCipherService = new AesCipherService();// 设置key长度aesCipherService.setKeySize(128); //生成key Key key = aesCipherService.generateNewKey(); String text = &quot;hello&quot;; //加密 String encrptText = aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex(); //解密 String text2 = new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes()); Assert.assertEquals(text, text2); PasswordService/CredentialsMatcherShiro提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。1234public interface PasswordService &#123; // 输入明文密码得到密文密码 String encryptPassword(Object plaintextPassword) throws IllegalArgumentException; &#125; 1234public interface CredentialsMatcher &#123; // 匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密） boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info); &#125; Shiro默认提供了PasswordService实现DefaultPasswordService；CredentialsMatcher实现PasswordMatcher及HashedCredentialsMatcher（更强大）。 DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务定义Realm com.github.gojay001.relam.MyRealm 1234567891011121314public class MyRealm extends AuthorizingRealm &#123; private PasswordService passwordService; public void setPasswordService(PasswordService passwordService) &#123; this.passwordService = passwordService; &#125; // 省略doGetAuthorizationInfo，具体看代码 @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; return new SimpleAuthenticationInfo( &quot;root&quot;, passwordService.encryptPassword(&quot;root&quot;), getName()); &#125; &#125; 为了方便，直接注入一个passwordService来加密密码；实际使用时需要在Service层使用passwordService加密密码并存储到数据库。 INI配置 shiro-passwordservice.ini 12345678910111213141516[main] passwordService=org.apache.shiro.authc.credential.DefaultPasswordService hashService=org.apache.shiro.crypto.hash.DefaultHashService passwordService.hashService=$hashService hashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat passwordService.hashFormat=$hashFormat hashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory passwordService.hashFormatFactory=$hashFormatFactory passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcher passwordMatcher.passwordService=$passwordService myRealm=com.github.gojay001.realm.MyRealm myRealm.passwordService=$passwordService myRealm.credentialsMatcher=$passwordMatcher securityManager.realms=$myRealm passwordService使用DefaultPasswordService，如果有必要也可以自定义； hashService定义散列密码使用的HashService，默认使用DefaultHashService（默认SHA-256算法）； hashFormat用于对散列出的值进行格式化，默认使用Shiro1CryptFormat，另外提供了Base64Format和HexFormat，对于有salt的密码请自定义实现ParsableHashFormat然后把salt格式化到散列值中； hashFormatFactory用于根据散列值得到散列的密码和salt；因为如果使用如SHA算法，那么会生成一个salt，此salt需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用DefaultHashFormatFactory； passwordMatcher使用PasswordMatcher，其是一个CredentialsMatcher实现； 将credentialsMatcher赋值给myRealm，myRealm间接继承了AuthenticatingRealm，其在调用getAuthenticationInfo方法获取到AuthenticationInfo信息后，会使用credentialsMatcher来验证凭据是否匹配，如果不匹配将抛出IncorrectCredentialsException异常。 测试用例参考： com.github.gojay001.test.PasswordTest ，包含JdbcRealm测试用例。缺点：salt保存在散列值中，没有实现如密码重试次数限制。 HashedCredentialsMatcher实现密码验证服务Shiro提供了CredentialsMatcher的散列实现HashedCredentialsMatcher，和之前的PasswordMatcher不同的是，它只用于密码验证，且可以提供自己的盐，而不是随机生成盐，且生成密码散列值的算法需要自己写，因为能提供自己的盐。 生成密码散列值此处我们使用MD5算法，“密码+盐（用户名+随机数）”的方式生成散列值：123456789String algorithmName = &quot;md5&quot;; String username = &quot;root&quot;; String password = &quot;root&quot;; String salt1 = username; String salt2 = new SecureRandomNumberGenerator().nextBytes().toHex(); int hashIterations = 2; SimpleHash hash = new SimpleHash(algorithmName, password, salt1 + salt2, hashIterations); String encodedPassword = hash.toHex(); 如果要写用户模块，需要在新增用户/重置密码时使用如上算法保存密码，将生成的密码及salt2存入数据库。因为我们的散列算法是：md5(密码+username+salt2)。 生成Realm自定义Realm com.github.gojay001.realm.MyRealm2 123456789101112protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; // 用户名及salt1 String username = &quot;liu&quot;; // 加密后的密码 String password = &quot;202cb962ac59075b964b07152d234b70&quot;; String salt2 = &quot;202cb962ac59075b964b07152d234b70&quot;; SimpleAuthenticationInfo ai = new SimpleAuthenticationInfo(username, password, getName()); // 盐是用户名+随机数 ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); return ai; &#125; 此处就是把步骤1中生成的相应数据组装为 SimpleAuthenticationInfo ，通过 SimpleAuthenticationInfo 的 credentialsSalt 设置盐， HashedCredentialsMatcher 会自动识别这个盐。 JdbcRealm需要修改获取用户信息（包括盐）的sql： “select password, password_salt from users where username = ?” ；而我们的盐是由 username+password_salt 组成，所以需要通过如下ini配置（shiro-jdbc-hashedCredentialsMatcher.ini）修改：123jdbcRealm.saltStyle=COLUMN jdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ? jdbcRealm.credentialsMatcher=$credentialsMatcher saltStyle表示使用密码+盐的机制，authenticationQuery第一列是密码，第二列是盐； 通过 authenticationQuery 指定密码及盐查询SQL。 INI配置 shiro-hashedCredentialsMatcher.ini 12345678[main] credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher credentialsMatcher.hashAlgorithmName=md5 credentialsMatcher.hashIterations=2 credentialsMatcher.storedCredentialsHexEncoded=true myRealm=com.github.gojay001.realm.MyRealm2 myRealm.credentialsMatcher=$credentialsMatcher securityManager.realms=$myRealm 通过 credentialsMatcher.hashAlgorithmName=md5 指定散列算法为md5，需要和生成密码时的一样； credentialsMatcher.hashIterations=2 ，散列迭代次数，需要和生成密码时的意义； credentialsMatcher.storedCredentialsHexEncoded=true 表示是否存储散列后的密码为16进制，需要和生成密码时的一样，默认是base64； 此处最需要注意的就是 HashedCredentialsMatcher 的算法需要和生成密码时的算法一样。另外HashedCredentialsMatcher会自动根据 AuthenticationInfo 的类型是否是 SaltedAuthenticationInfo 来获取credentialsSalt盐。 密码重试次数限制如在1个小时内密码最多重试5次，如果尝试次数超过5次就锁定1小时，1小时后可再次重试，如果还是重试失败，可以锁定如1天，以此类推，防止密码被暴力破解。我们通过继承HashedCredentialsMatcher，且使用Ehcache记录重试次数和超时时间。 com.github.gojay001.credentials.RetryLimitHashedCredentialsMatcher 123456789101112131415161718192021public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; String username = (String)token.getPrincipal(); //retry count + 1 Element element = passwordRetryCache.get(username); if(element == null) &#123; element = new Element(username , new AtomicInteger(0)); passwordRetryCache.put(element); &#125; AtomicInteger retryCount = (AtomicInteger)element.getObjectValue(); if(retryCount.incrementAndGet() &gt; 5) &#123; //if retry count &gt; 5 throw throw new ExcessiveAttemptsException(); &#125; boolean matches = super.doCredentialsMatch(token, info); if(matches) &#123; //clear retry count passwordRetryCache.remove(username); &#125; return matches; &#125; 如上代码逻辑比较简单，即如果密码输入正确，清除cache中的记录；否则cache中的重试次数+1，如果超出5次那么抛出异常表示超出重试次数了。 总结编码/解码 Base64 Hex Hash() 加密/解密 对称式加密/解密 加密/验证PasswordService DefaultPasswordService CredentialsMatcher PasswordMatcher HashedCredentialsMatcher DefaultPasswordService配合PasswordMatcherRealm 自定义Realm JdbcRealm ini配置 passwordService hashService hashFormat hashFormatFactory passwordMatcher myRealm HashedCredentialsMatcher生成Realm 使用MD5算法 ini配置 credentialsMatcher hashAlgorithmName hashIterations myRealm 添加密码重试次数限制 记录重试次数 参考代码： https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter5]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>编码</tag>
        <tag>Shiro</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（四）-INI配置]]></title>
    <url>%2F2017%2F11%2F28%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[SecurityManagerShiro是从根对象 SecurityManager 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 SecurityUtils 让我们绑定它为全局的，方便后续操作。 因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。 纯Java代码写法 com.github.gojay001.test.NonConfigurationCreateTest 123456789101112131415161718192021222324252627282930313233DefaultSecurityManager securityManager = new DefaultSecurityManager();//设置authenticatorModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());securityManager.setAuthenticator(authenticator);//设置authorizerModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();authorizer.setPermissionResolver(new WildcardPermissionResolver());securityManager.setAuthorizer(authorizer);//设置RealmDruidDataSource ds = new DruidDataSource();ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);ds.setUrl(&quot;jdbc:mysql://localhost:3306/shiro&quot;);ds.setUsername(&quot;root&quot;);ds.setPassword(&quot;root&quot;);JdbcRealm jdbcRealm = new JdbcRealm();jdbcRealm.setDataSource(ds);jdbcRealm.setPermissionsLookupEnabled(true);securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));//将SecurityManager设置到SecurityUtils 方便全局使用SecurityUtils.setSecurityManager(securityManager);Subject subject = SecurityUtils.getSubject();UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);subject.login(token);Assert.assertTrue(subject.isAuthenticated()); 等价的INI配置shiro-config.ini：123456789101112131415161718192021222324252627[main]#覆盖默认的securityManager#securityManager=org.apache.shiro.mgt.DefaultSecurityManager#authenticatorauthenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorauthenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategyauthenticator.authenticationStrategy=$authenticationStrategysecurityManager.authenticator=$authenticator#authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizerpermissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverauthorizer.permissionResolver=$permissionResolversecurityManager.authorizer=$authorizer#realmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=rootjdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truesecurityManager.realms=$jdbcRealm 对象名=全限定类名 相对于调用public无参构造器创建对象对象名.属性名=值 相当于调用setter方法设置常量值对象名.属性名=$对象引用 相当于调用setter方法设置对象引用 com.github.gojay001.test.ConfigurationCreateTest：1234567891011121314Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;);SecurityManager securityManager = factory.getInstance();//将SecurityManager设置到SecurityUtils 方便全局使用SecurityUtils.setSecurityManager(securityManager);Subject subject = SecurityUtils.getSubject();UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);subject.login(token);Assert.assertTrue(subject.isAuthenticated()); 如上代码是从Shiro INI配置中获取相应的securityManager实例： 默认情况先创建一个名字为 securityManager ，类型为 org.apache.shiro.mgt.DefaultSecurityManager 的默认的 SecurityManager ，如果想自定义，只需要在ini配置文件中指定“securityManager=SecurityManager实现类”即可，名字必须为securityManager，它是起始的根； IniSecurityManagerFactory 是创建 securityManager 的工厂，其需要一个ini配置文件路径，其支持classpath:（类路径）、file:（文件系统）、url:（网络）三种路径格式，默认是文件系统； 接着获取SecuriyManager实例，后续步骤和之前的一样。 如上可以看出Shiro INI配置方式本身提供了一个简单的IoC/DI机制方便在配置文件配置，但是是从 securityManager 这个根对象开始导航。 INI配置ini配置文件类似于Java中的 properties（key=value） ，不过提供了将key/value分类的特性，key是每个部分不重复即可，而不是整个配置文件。如下是INI配置分类：123456789101112131415161718[main] #提供了对根对象securityManager及其依赖的配置 securityManager=org.apache.shiro.mgt.DefaultSecurityManager ………… securityManager.realms=$jdbcRealm [users] #提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2 username=password,role1,role2 [roles] #提供了角色及权限之间关系的配置，角色=权限1，权限2 role1=permission1,permission2 [urls] #用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器 /index.html = anon /admin/** = authc, roles[admin], perms[&quot;permission1&quot;] [main]部分提供了对根对象 securityManager 及其依赖对象的配置。 创建对象1securityManager=org.apache.shiro.mgt.DefaultSecurityManager 其构造器必须是public空参构造器，通过反射创建相应的实例。 常量值setter注入12dataSource.driverClassName=com.mysql.jdbc.Driver jdbcRealm.permissionsLookupEnabled=true 会自动调用 jdbcRealm.setPermissionsLookupEnabled(true) ，对于这种常量值会自动类型转换。 对象引用setter注入1234authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy authenticator.authenticationStrategy=$authenticationStrategy securityManager.authenticator=$authenticator 会自动通过 securityManager.setAuthenticator(authenticator) 注入引用依赖。 嵌套属性setter注入1securityManager.authenticator.authenticationStrategy=$authenticationStrategy 支持这种嵌套方式的setter注入。 byte数组setter注入1234#base64 byte[] authenticator.bytes=aGVsbG8= #hex byte[] authenticator.bytes=0x68656c6c6f 默认需要使用Base64进行编码，也可以使用0x十六进制。 Array/Set/List setter注入12authenticator.array=1,2,3 authenticator.set=$jdbcRealm,$jdbcRealm 多个之间通过“，”分割。 Map setter注入1authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc 格式是： map=key：value，key：value ，可以注入常量及引用值，常量的话都看作字符串（即使有泛型也不会自动造型）。 实例化/注入顺序12345realm=Realm1 realm=Realm12 authenticator.bytes=aGVsbG8= authenticator.bytes=0x68656c6c6f 后边的覆盖前边的注入。 [users]部分配置用户名/密码及其角色，格式：用户名=密码，角色1，角色2，角色部分可省略。如：123[users]root=root,role1,role2gojay=test 密码一般生成其摘要/加密存储。 [roles]部分配置角色及权限之间的关系，格式：角色=权限1，权限2；如：123[roles] role1=user:create,user:update role2=* 如果只有角色没有对应的权限，可以不配roles。 [urls]部分配置url及相应的拦截器之间的关系，格式：url=拦截器[参数]，拦截器[参数]，如：12[urls] /admin/** = authc, roles[admin], perms[&quot;permission1&quot;] 参考代码： https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter4]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（三）-授权]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[简介授权：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 主体：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。 资源：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。 权限：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。 角色：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。 隐式角色：即直接通过角色来验证用户有没有操作权限。 显式角色：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。 了解更多：搜索“RBAC”和“RBAC新解”分别了解“基于角色的访问控制”和“基于资源的访问控制”。 授权方式 Shiro支持三种方式的授权。 编程式通过写if/else授权代码块完成：123456Subject subject = SecurityUtils.getSubject(); if(subject.hasRole(“admin”)) &#123; //有权限 &#125; else &#123; //无权限 &#125; 注解式通过在执行的Java方法上放置相应的注解完成：1234@RequiresRoles(&quot;admin&quot;) public void hello() &#123; //有权限 &#125; 没有权限将抛出相应的异常。 JSP/GSP标签在JSP/GSP页面通过相应的标签完成：123&lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!— 有权限 —&gt; &lt;/shiro:hasRole&gt; 授权基于角色的访问控制（隐式角色）在ini配置文件配置用户拥有的角色 shiro-role.ini 123[users]root=root,role1,role2gojay=test,role1 规则：“用户名=密码,角色1，角色2”，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息；也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证。 测试用例 com.github.gojay001.test.RoleTest 12345678910111213@Testpublic void testHasRole() &#123; login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有角色：role1 Assert.assertTrue(subject().hasRole(&quot;role1&quot;)); // 判断拥有角色：role1 and role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;))); // 判断拥有角色：role1 and role2 and !role3 boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;)); Assert.assertEquals(true, result[0]); Assert.assertEquals(true, result[1]); Assert.assertEquals(false, result[2]);&#125; Shiro提供了hasRole/hasAllRoles用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。 12345678@Test(expected = UnauthorizedException.class)public void testCheckRole() &#123; login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 断言拥有角色：role1 subject().checkRole(&quot;role1&quot;); // 断言拥有角色：role1 and role3 失败抛出异常 subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);&#125; Shiro提供的checkRole/checkRoles和hasRole/hasAllRoles不同的地方是它在判断为假的情况下会抛出UnauthorizedException异常。 基于角色的访问控制（即隐式角色）的缺点：如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把所有相关的地方进行删除；这就是粗粒度造成的问题。 基于资源的访问控制（显式角色）在ini配置文件配置用户拥有的角色及角色-权限关系 shiro-permission.ini 123456[users]root=root,role1,role2gojay=test,role1[roles]role1=user:create,user:updaterole2=user:create,user:delete 规则：“用户名=密码，角色1，角色2”“角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。 测试用例 com.github.gojay001.test.PermissionTest 12345678910@Testpublic void testIsPermitted() &#123; login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有权限：user:create Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;)); // 判断拥有权限：user:update and user:delete Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;)); // 判断没有权限：user:view Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));&#125; Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或所有权限，也没有提供如isPermittedAny用于判断拥有某一个权限的接口。 12345678910@Test(expected = UnauthorizedException.class)public void testCheckPermission() &#123; login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 断言拥有权限：user:create subject().checkPermission(&quot;user:create&quot;); // 断言拥有权限：user:delete and user:update subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;); // 断言拥有权限：user:view 失败抛出异常 subject().checkPermissions(&quot;user:view&quot;);&#125; checkPermissions失败的情况下会抛出UnauthorizedException异常。 基于资源的访问控制（显式角色），也可以叫基于权限的访问控制，这种方式的一般规则是“资源标识符：操作”，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。 Permission字符串通配符权限规则：“资源标识符：操作：对象实例ID” 即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“:”表示资源/操作/实例的分割；“,”表示操作的分割；“*”表示任意资源/操作/实例。 单个资源单个权限1subject().checkPermissions(&quot;system:user:update&quot;); 用户拥有资源“system:user”的“update”权限。 单个资源多个权限ini配置文件：1role41=system:user:update,system:user:delete 通过判断：1subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;); 可以简写为：&quot;system:user:update,delete&quot; 用户拥有资源“system:user”的“update”和“delete”权限。 单个资源全部权限ini配置：1role51=&quot;system:user:create,update,delete,view&quot; 通过判断：1subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;); 可以简写为：system:user:* 用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。 所有资源全部权限ini配置：1role61=*:view 通过判断：1subject().checkPermissions(&quot;user:view&quot;); 用户拥有所有资源的“view”所有权限。 实例级别的权限单个实例单个权限ini配置：1role71=user:view:1 通过判断：1subject().checkPermissions(&quot;user:view:1&quot;); 对资源user的1实例拥有view权限。 单个实例多个权限ini配置：1role72=&quot;user:update,delete:1&quot; 通过判断：12subject().checkPermissions(&quot;user:delete,update:1&quot;); subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;); 对资源user的1实例拥有update、delete权限。 单个实例所有权限ini配置：1role73=user:*:1 通过判断：1subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;); 对资源user的1实例拥有所有权限。 所有实例单个权限ini配置：1role74=user:auth:* 通过判断：1subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;); 对资源user的1实例拥有所有权限。 所有实例所有权限ini配置：1role75=user:*:* 通过判断：1subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;); 对资源user的1实例拥有所有权限。 Shiro对权限字符串缺失部分的处理 如user:view 等价于 user:view:*；organization 等价于 organization:* 或者 organization:*:*。可以这么理解，这种方式实现了前缀匹配。 如user:* 可以匹配 user:delete；user:delete 可以匹配 user:delete:1；user:*:1 可以匹配 user:view:1；user 可以匹配 user:view 或 user:view:1等。即*可以匹配所有，不加*可以进行前缀匹配； 如*:view 不能匹配 system:user:view；需要使用 *:*:view；即后缀匹配必须指定前缀（多个冒号就需要多个*来匹配）。 WildcardPermission如下两种方式是等价的：12subject().checkPermission(&quot;menu:view:1&quot;); subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;)); 因此没什么必要的话使用字符串更方便。 性能问题通配符匹配方式比字符串匹配来说是更复杂的，因此需要花费更长时间，但是一般系统的权限不会太多，且可以配合缓存来提供其性能，如果这样性能还达不到要求我们可以实现位操作算法实现性能更好的权限匹配。另外实例级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如在sql查询时加上权限字符串之类的方式在查询时就完成了权限匹配。 授权流程 流程如下： 首先调用Subject.isPermitted*/hasRole*接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer； Authorizer是真正的授权者；如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例； 在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限； Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败。 ModularRealmAuthorizer进行多Realm匹配流程： 首先检查相应的Realm是否实现了Authorizer； 如果实现了Authorizer，那么接着调用其相应的isPermitted*/hasRole*接口进行匹配； 如果有一个Realm匹配那么将返回true，否则返回false。 如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是： 如果调用hasRole*，则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可； 如果调用如isPermitted(“user:view”)，首先通过PermissionResolver将权限字符串转换成相应的Permission实例，默认使用WildcardPermissionResolver，即转换为通配符的WildcardPermission； 通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo. getStringPermissions()得到字符串集合并通过PermissionResolver解析为Permission实例；然后获取用户的角色，并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）； 接着调用Permission. implies(Permission p)逐个与传入的权限比较，如果有匹配的则返回true，否则false。 AuthorizerAuthorizer的职责是进行授权（访问控制），提供了相应的角色/权限判断接口。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例。RolePermissionResolver用于根据角色解析相应的权限集合。 可以通过如下ini配置更改Authorizer实现： 12authorizer=org.apache.shiro.authz.ModularRealmAuthorizer securityManager.authorizer=$authorizer 设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如： 12permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver authorizer.permissionResolver=$permissionResolver 设置ModularRealmAuthorizer的rolePermissionResolver，其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如： 12rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver authorizer.rolePermissionResolver=$rolePermissionResolver 示例ini配置 shiro-jdbc-authorizer.ini 123456789101112131415161718192021222324[main]#自定义authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer#自定义permissionResolver#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.gojay001.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver#自定义rolePermissionResolverrolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer#自定义realm 一定要放在securityManager.authorizer赋值之后#因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolverjdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=rootjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truesecurityManager.realms=$jdbcRealm 不能使用IniSecurityManagerFactory创建的IniRealm，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。 定义BitAndWildPermissionResolver及BitPermission BitPermission用于实现位移方式的权限，如规则是：权限字符串格式：+资源字符串+权限位+实例ID；以+开头中间通过+分割；权限：0 表示所有权限；1 新增（二进制：0001）、2 修改（二进制：0010）、4 删除（二进制：0100）、8 查看（二进制：1000）；如 +user+10 表示对资源user拥有修改/查看权限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BitPermission implements Permission &#123; private String resourceIdentify; private int permissionBit; private String instanceId; public BitPermission(String permissionString) &#123; String[] array = permissionString.split(&quot;\\+&quot;); if (array.length &gt; 1) &#123; resourceIdentify = array[1]; &#125; if (StringUtils.isEmpty(resourceIdentify)) &#123; resourceIdentify = &quot;*&quot;; &#125; if (array.length &gt; 2) &#123; permissionBit = Integer.valueOf(array[2]); &#125; if (array.length &gt; 3) &#123; instanceId = array[3]; &#125; if (StringUtils.isEmpty(instanceId)) &#123; instanceId = &quot;*&quot;; &#125; &#125; public boolean implies(Permission permission) &#123; if(!(permission instanceof BitPermission)) &#123; return false; &#125; BitPermission other = (BitPermission) permission; if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123; return false; &#125; if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123; return false; &#125; if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123; return false; &#125; return true; &#125; @Override public String toString() &#123; return &quot;BitPermission&#123;&quot; + &quot;resourceIdentify=&apos;&quot; + resourceIdentify + &apos;\&apos;&apos; + &quot;, permissionBit=&quot; + permissionBit + &quot;, instanceId=&apos;&quot; + instanceId + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; Permission接口提供了boolean implies(Permission p)方法用于判断权限匹配的；123456789public class BitAndWildPermissionResolver implements PermissionResolver &#123; @Override public Permission resolvePermission(String permissionString) &#123; if(permissionString.startsWith(&quot;+&quot;)) &#123; return new BitPermission(permissionString); &#125; return new WildcardPermission(permissionString); &#125; &#125; BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。 定义MyRolePermissionResolverRolePermissionResolver用于根据角色字符串来解析得到权限集合。123456789public class MyRolePermissionResolver implements RolePermissionResolver &#123; @Override public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123; if(&quot;role1&quot;.equals(roleString)) &#123; return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;)); &#125; return null; &#125; &#125; 自定义Realm使用JdbcRealm，需要做的操作如下： 执行sql/shiro-init-data.sql 插入相关的权限数据； 使用shiro-jdbc-authorizer.ini配置文件，需要设置jdbcRealm.permissionsLookupEnabled为true来开启权限查询。 这里也可以自定义实现Realm，可参考com.github.gojay001.realm.MyRealm 测试用例123456789101112131415@Testpublic void testIsPermitted2() &#123; login(&quot;classpath:shiro-jdbc-authorizer.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有权限：user:create Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;)); Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;)); // 通过二进制位的方式表示权限 Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));// 新增权限 Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));// 查看权限 Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));// 新增及查看 Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));// 没有删除权限 Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));// 通过MyRolePermissionResolver解析得到的权限&#125; 总结授权流程 Subject.isPermitted*/hasRole* SecurityManager Authorizer PermissionResolver/RolePermissionResolver/Permission Realm Realm user role permission Security Authorizer PermissionResolver RolePermissionResolver Realm Subject hasRole/hasAllRoles checkRole/checkRoles isPermitted/isPermittedAll checkPermission/checkPermissions 参考代码：https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
        <tag>授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（二）-身份认证]]></title>
    <url>%2F2017%2F11%2F22%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[简介身份验证：在应用中能证明他就是他本人。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份。 principals：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名/密码/手机号。 credentials：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。 最常见的 principals 和 credentials 组合就是用户名/密码了。另外两个相关的概念是之前提到的 Subject 及 Realm，分别是主体及验证主体的数据源。 环境准备使用Maven构建准备环境依赖：添加 junit、common-logging 及 shiro-core 依赖； 更新：加入slf4j-nop依赖包。 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 登录/退出准备一些用户身份/凭据 shiro.ini 123[users]gojay=testroot=root 此处使用ini配置文件，通过[user]指定两个主体。 测试用例 com.github.gojay001.test.LoginLogoutTest更新：注意类过时。 12345678910111213141516171819202122232425@Testpublic void testLoginLogout() &#123; //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2、得到SecurityManager实例 并绑定给SecurityUtils SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;); try &#123; //4、登录，即身份验证 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份验证失败 &#125; Assert.assertEquals(true, subject.isAuthenticated()); //6、退出 subject.logout();&#125; 首先通过new IniSecurityManagerFactory并指定一个ini配置文件来创建一个SecurityManager工厂； 接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可； 通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token，如用户名/密码； 调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录； 如果身份验证失败捕获AuthenticationException或其子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体查看其继承关系； 最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。 总结步骤 收集用户身份/凭证，即如用户名/密码； 调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功； 最后调用Subject.logout进行退出操作。 存在问题 用户名/密码硬编码在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储； 用户身份Token可能不仅仅是用户名/密码，也可能还有其他的，如登录时允许用户名/邮箱/手机号同时登录。 身份认证流程 流程如下： 首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置； SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。 RealmRealm：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即安全数据源。 org.apache.shiro.realm.Realm接口如下：123String getName(); //返回一个唯一的Realm名字 boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //根据Token获取认证信息 单Realm配置自定义Realm实现 com.github.gojay001.realm.MyRealm1 1234567891011121314151617181920212223242526 public class MyRealm1 implements Realm &#123; public String getName() &#123; return &quot;myRealm1&quot;; &#125; public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; // 得到用户名 String username = (String)authenticationToken.getPrincipal(); // 得到密码 String password = new String((char[])authenticationToken.getCredentials()); if(!&quot;root&quot;.equals(username)) &#123; //用户名错误 throw new UnknownAccountException(); &#125; if(!&quot;root&quot;.equals(password)) &#123; //密码错误 throw new IncorrectCredentialsException(); &#125; //如果身份认证验证成功，返回一个AuthenticationInfo实现； return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; ini配置文件指定自定义Realm实现 shiro-realm.ini 1234#声明一个realmmyRealm1=com.github.gojay001.realm.MyRealm1#指定securityManager的realms实现securityManager.realms=$myRealm1 通过$name来引入之前的realm定义。 多Realm配置ini配置文件 shiro-multi-realm.ini 12345#声明一个realm myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1 myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2 #指定securityManager的realms实现 securityManager.realms=$myRealm1,$myRealm2 securityManager会按照realms指定的顺序进行身份认证。 Shiro默认提供的Realm 以后一般继承AuthorizingRealm（授权）即可；其继承了AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）。其中主要默认实现如下： org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息； org.apache.shiro.realm.text.PropertiesRealm： user.username=password,role1,role2指定用户名/密码及其角色；role.role1=permission1,permission2指定角色及权限信息； org.apache.shiro.realm.jdbc.JdbcRealm：通过sql查询相应的信息，如“select password from users where username = ?”获取用户密码，“select role_name from user_roles where username = ?”获取用户角色；“select permission from roles_permissions where role_name = ?”获取角色对应的权限信息；也可以调用相应的api进行自定义sql； JDBC Realm使用数据库及依赖 更新：alibaba的druid包更新版本。 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt; 本文将使用mysql数据库及druid连接池。 数据库下建表users（用户名/密码）、user_roles（用户/角色）、roles_permissions（角色/权限）；具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。 ini配置 shiro-jdbc-realm.ini 12345678jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql://localhost:3306/shiro dataSource.username=root dataSource.password=rootjdbcRealm.dataSource=$dataSource securityManager.realms=$jdbcRealm 变量名=全限定类名 自动创建一个类实例 变量名.属性=值 自动调用相应的setter方法进行赋值 $变量名 引用之前的一个对象实例 测试代码和之前的没什么区别。 Authenticator及AuthenticationStrategy原理Authenticator的职责是验证用户帐号，是Shiro API中身份验证核心的入口点：1public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; 如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。 SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现： FirstSuccessfulStrategy：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略； AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息； AllSuccessfulStrategy：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。 ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。 示例 假设有三个realm：myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root； ini配置文件 shiro-authenticator-all-success.ini 12345678910111213[main]#指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator#指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.github.gojay001.realm.MyRealm1myRealm2=com.github.gojay001.realm.MyRealm2myRealm3=com.github.gojay001.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3 测试代码 com.github.gojay001.test.AuthenticatorTest 首先通用化登录逻辑123456789101112131415private void login(String configFile) &#123; //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory(configFile); //2、得到SecurityManager实例 并绑定给SecurityUtils org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;); subject.login(token); &#125; 测试AllSuccessfulStrategy成功123456789@Test public void testAllSuccessfulStrategyWithSuccess() &#123; login(&quot;classpath:shiro-authenticator-all-success.ini&quot;); Subject subject = SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection = subject.getPrincipals(); Assert.assertEquals(2, principalCollection.asList().size()); &#125; 测试AllSuccessfulStrategy失败12345@Test(expected = UnknownAccountException.class) public void testAllSuccessfulStrategyWithFail() &#123; login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;); Subject subject = SecurityUtils.getSubject(); &#125; shiro-authenticator-all-fail.ini 与 shiro-authenticator-all-success.ini 不同的配置是使用了 securityManager.realms=$myRealm1,$myRealm2 ；即myRealm验证失败。 对于 AtLeastOneSuccessfulStrategy 和 FirstSuccessfulStrategy 的区别：唯一不同点一个是返回所有验证成功的Realm的认证信息；另一个是只返回第一个验证成功的Realm的认证信息.示例代码同上 自定义AuthenticationStrategy实现首先看其API：1234567891011121314151617//在所有Realm验证之前调用 AuthenticationInfo beforeAllAttempts( Collection&lt;? extends Realm&gt; realms, AuthenticationToken token) throws AuthenticationException; //在每个Realm之前调用 AuthenticationInfo beforeAttempt( Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException; //在每个Realm之后调用 AuthenticationInfo afterAttempt( Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException; //在所有Realm之后调用 AuthenticationInfo afterAllAttempts( AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException; 因为每个AuthenticationStrategy实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；通过如上接口可以进行如合并/返回第一个验证成功的认证信息。自定义实现时一般继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy 即可。参考代码同上 到此基本的身份验证就结束了。 总结问题描述Assert过时 Assert in junit.framework has been deprecated解决：将 import junit.framework.Assert; 改为 import org.junit.Assert; SLF4J加载失败 SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”解决：Maven引入slf4j-nop包：12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.6&lt;/version&gt;&lt;/dependency&gt; implements不需要@Overridealibaba的druid版本更新重点用户登录流程 Subject.login(token) SecurityManager Authenticator AuthenticatorStrategy Realm Realm 单Realm 多Realm JDBCRealm AuthenticatorStrategy FirstSuccessfulStrategy AtLeastOneSuccessfulStrategy AllSuccessfulStrategy 自定义Strategy 参考代码：https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
        <tag>身份认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（一）-Shiro简介]]></title>
    <url>%2F2017%2F11%2F19%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介认识 Apache Shiro是Java的一个安全框架。 对比Spring Security小而简单。 可同时用在JavaSE、JavaEE环境中。 主要完成认证、授权、加密、会话管理、与Web集成、缓存等。 功能 Authentication：身份认证/登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限； Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 Shiro不会去维护用户、维护权限；这些需要自己设计提供，然后通过相应的接口注入给Shiro。 架构从外部看Shiro： Subject：主体；代表了与当前应用交互的用户，如网络爬虫、机器人等；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面，SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互，且它管理着所有 Subject；它是 Shiro 的核心，负责与其他组件进行交互，可以把它看成Spring NVC中的 DispatcherServlet 前端控制器； Realm：域；Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 可以看出：Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。 从内部看Shiro： Subject：主体；可以看到主体可以是任何可以与应用交互的“用户”； SecurityManager ：安全管理器；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject，且负责进行认证和授权、及会话、缓存的管理，是Shiro的心脏； Authenticator：认证器；负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略Authentication Strategy，即什么情况下算用户认证通过了； Authrizer：授权器；用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的，由用户提供；Shiro 不知道用户/权限存储在哪及以何种格式存储，所以我们一般在应用中都需要实现自己的 Realm； SessionManager：Session需要有人去管理它的生命周期，这个组件就是SessionManager；Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：数据访问对象DAO，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到Memcached中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器；来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能； Cryptography：密码模块;Shiro 提高了一些常见的加密组件用于如密码加密/解密的。 到此 Shiro 架构及其组件就认识完了。]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web路径问题解析]]></title>
    <url>%2F2017%2F11%2F19%2FJava-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基本概念的理解 绝对路径：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：C:\xyz\test.txt；http://www.test.com/index.html； 相对路径：相对与某个基准目录的路径，例如：&quot;/&quot;代表Web应用的根目录，&quot;./&quot;代表当前目录,&quot;../&quot;代表上级目录。 另外关于URI，URL,URN等内容，请参考RFC相关文档标准。 关于JSP/Servlet中的相对路径和绝对路径服务器端的地址 服务器端的相对地址指的是相对于你的web应用的地址，这个地址是在服务器端解析的（不同于html和javascript中的相对地址，他们是由客户端浏览器解析的）；在jsp和servlet中的相对地址应该是相对于你的web应用，即相对于http://192.168.0.1/webapp/的。 用到的地方： forward：servlet中的request.getRequestDispatcher(address);这个address是在服务器端解析的。request.getRequestDispatcher(“/pages/a.jsp”)的绝对路径地址：http://192.168.0.1/webapp/pages/a.jsp； sendRedirect：在jsp中&lt;%response.sendRedirect(&quot;/user/a.jsp&quot;);%&gt;。 客户端的地址 所有的html页面中的相对地址都是相对于服务器根目录http://192.168.0.1/的，而不是根目录下的该Web应用的目录：http://192.168.0.1/webapp/。 HTML中的form表单的action属性的地址应该是相对于服务器根目录http://192.168.0.1/；如果提交到a.jsp为：action＝&quot;/webapp/user/a.jsp&quot;或action=&quot;&lt;%=request.getContextPath()%&gt;&quot;/user/a.jsp； Javascript也是在客户端解析的，所以其相对路径和form表单一样。 因此，一般情况下，在JSP/HTML页面等引用的CSS、Javascript、Action等属性前面最好都加上&lt;%=request.getContextPath()%&gt;,以确保所引用的文件都属于Web应用中的目录。另外，应该尽量避免使用类似&quot;.&quot;,&quot;./&quot;,&quot;../&quot;等类似的相对该文件位置的相对路径，这样当文件移动时，很容易出问题。 站点根目录和css路径问题 当在jsp中引入css时，如果其相对路径相对于当前jsp文件的，而在一个和这个jsp的路径不一样的servlet中forward这个jsp时，就会发现这个css样式根本没有起作用。这是因为在servlet中转发时css的路径就是相对于这个servlet的相对路径，而非jsp的路径了。所以这时候不能在jsp中用这样的路径：&lt;link href=&quot;one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;或者&lt;link href=&quot;../../one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;。这个时候要用站点根目录，就是相对于http://192.168.0.1/的目录，以&quot;/&quot;开头。因此上述错误应更正为href=”/test/one.css” 类似的站点根目录的相对目录。 获得JSP/Servlet中当前应用的相对路径和绝对路径JSP中获得当前应用的相对路径和绝对路径 根目录所对应的绝对路径:request.getRequestURI(); 文件的绝对路径:application.getRealPath(request.getRequestURI()); 当前web应用的绝对路径:application.getRealPath(&quot;/&quot;); 请求文件的上层目录:new File(application.getRealPath(request.getRequestURI())).getParent(); Servlet中获得当前应用的相对路径和绝对路径 根目录所对应的绝对路径:request.getServletPath(); 文件的绝对路径:request.getSession().getServletContext(). getRealPath(request.getRequestURI()); 当前web应用的绝对路径:servletConfig.getServletContext().getRealPath(&quot;/&quot;); ServletContext对象获得几种方式：javax.servlet.http.HttpSession.getServletContext();javax.servlet.jsp.PageContext.getServletContext();javax.servlet.ServletConfig.getServletContext(); JAVA的Class中获得相对路径，绝对路径单独的Java类中获得绝对路径 根据java.io.File的Doc文挡，可知: 默认情况下new File(&quot;/&quot;)代表的目录为：System.getProperty(&quot;user.dir&quot;);程序获得执行类的当前路径: 123456789101112import java.io.File;public class FileTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;)); System.out.println(FileTest.class.getClassLoader().getResource(&quot;&quot;)); System.out.println(ClassLoader.getSystemResource(&quot;&quot;)); System.out.println(FileTest.class.getResource(&quot;&quot;)); System.out.println(FileTest.class.getResource(&quot;/&quot;));//Class文件所在路径 System.out.println(new File(&quot;/&quot;).getAbsolutePath()); System.out.println(System.getProperty(&quot;user.dir&quot;)); &#125;&#125; 服务器中的Java类获得当前路径Weblogic WebApplication的系统文件根目录是你的weblogic安装所在根目录。例如：如果你的weblogic安装在c:\bea\weblogic700.....那么，你的文件根路径就是c:\所以，有两种方式能够让你访问你的服务器端的文件: 使用绝对路径：比如将你的参数文件放在c:\yourconfig\yourconf.properties，直接使用new FileInputStream(&quot;yourconfig/yourconf.properties&quot;); 使用相对路径：相对路径的根目录就是你的webapplication的根路径，即WEB-INF的上一级目录，将你的参数文件放在yourwebapp\yourconfig\yourconf.properties，这样使用：new FileInputStream(&quot;./yourconfig/yourconf.properties&quot;); Tomcat 在类中输出System.getProperty(&quot;user.dir&quot;);显示的是%Tomcat_Home%/bin 如何读相对路径哪? 在Java文件中getResource或getResourceAsStream均可。例：getClass().getResourceAsStream(filePath);filePath可以是”/filename”,这里的/代表web发布根路径下WEB-INF/classes。 参考文档：java路径问题]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>路径问题</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web编码问题详解]]></title>
    <url>%2F2017%2F11%2F15%2Fweb%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言最近搭建spring mvc项目时又再次遇到了编码问题，仔细想想，虽然以前用JSP+Servlet的时候解决了中文乱码的问题，但是都没有仔细分析过每个流程。于是今天在这里整理一下,web应用中常见的与编码相关配置： 项目配置 首先配置好项目里的编码，这里主要有三个地方需要注意： 页面乱码 页面乱码相对简单，只需要设置相关字符集编码即可。 JSP页面1&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; pageEncoding：该页面编码格式；charset：页面解码格式。 HTML页面1&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt; 传值乱码 页面到controller传值乱码需要在web.xml配置字符编码过滤器。 直接应用spring中字符编码过滤器1234567891011121314151617&lt;!--字符编码--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 字符编码拦截器作用： 分析源码发现作用相当于servlet中：request.setCharacterEncoding(“UTF-8”);response.setCharacterEncoding(“UTF-8”); spring自带过滤器主要针对POST请求，对GET请求无效： 对于GET请求的参数乱码，解决方法是采用数据还原：String userName= request.getParameter(“userName”);userName=new String(userName.getBytes(“iso8859-1”),”UTF-8”); &lt;url-pattern&gt;中匹配说明： /：不会匹配到/*.jsp，但会匹配/login等路径类型的url；/*：会匹配/login、*.jsp、*.html等路径； 根据源码可自己编写字符编码过滤器1234567891011121314151617181920public class CharacterEncodingFilter implements Filter &#123; private String encoding = null; private FilterConfig filterConfig = null; @Override public void init(FilterConfig config) throws ServletException &#123; this.filterConfig = config; this.encoding = config.getInitParameter(&quot;encoding&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; if (encoding != null) &#123; request.setCharacterEncoding(encoding); response.setContentType(&quot;text/html;charset=&quot; + encoding); &#125; chain.doFilter(request, response); &#125;&#125; 存入数据库乱码 需要在数据库配置文件设置参数。 1url=jdbc:mysql://gojay001.mysql.rds.aliyuncs.com:3306/trade?useUnicode=true&amp;characterEncoding=utf8 环境配置 按照上述确认了项目内的字符编码后，在实际运行环境中可能还是会出现乱码的情况，比如发布到云服务器上。这时候就需要配置相关的环境，主要是数据库和tomcat的配置。 Tomcat配置 在tomcat的conf/server.xml中配置Get请求默认编码： 123456&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot; /&gt; 数据库配置 参考：CentOS安装MySQL中文乱码问题解决1、原因：安装mysql之后默认的字符编码为latin1;2、查看：show variables like &#39;%char%&#39;;3、修改为下面内容后重启mysql：vi /etc/my.cf;12345678910111213141516171819202122[mysqld]character_set_server=utf8lower_case_table_names=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqlsymbolic-links=0sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysqld_safe]default-character-set = utf8log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid[client]default-character-set = utf8[mysql.server]default-character-set = utf8[mysql]default-character-set = utf8 其他问题HTML文件仍然显示乱码：将编码格式保存为UTF-8包含BOM 这次总结编码也就是因为遇到这个问题，一直以为是项目配置或者服务器的问题，困扰了几天后才发现这个原因。至于为什么需要带BOM，网上的评论也很多，这里也确实解决了我出现的问题。 静态资源访问：1、在web.xml中配置：12345678910111213141516171819202122232425&lt;!--解决静态资源访问--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、路径说明：/page/index.html:根目录下的page文件夹；../page/index.html:当前路径的上一级的page文件夹；page/index.html:当前路径的page文件夹。 以上目前我所遇到并解决的问题，可能还有其他相关我不了解的配置，以后学习了也会继续补充上来。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云搭建java Web环境]]></title>
    <url>%2F2017%2F11%2F06%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、前言 最近重新在阿里云上配置了服务器和数据库，今天正好整理一下配置过程并且结合以前在CentOS下搭建java Web的流程，写在这里，以免以后忘记了不知所措。下面进入主题： 二、配置阿里云 阿里云有学生优惠9.9一个月的云服务器，可以直接购买配置，选择CentOS。我在活动期间购买时花了9.9买了.xin域名和域名解析1年，还送了阿里云一整套6个月：服务器、数据库、OSS等等。我目前只在云服务器下搭建java Web环境并发布项目，然后连接的云数据库。服务器和数据库的配置都比较简单，阿里云上也有官方文档可以查看，按着步骤一步步配置下来就行了。 三、工具准备 我采用的是在Windows下开发，然后将项目发布在云服务器上。所以，首先需要在Windows下准备几个工具。 1、SecureCRTSecureCRT用于连接云服务器，能够在Windows下直接操作服务器。 安装SecureCRT： 下载SecureCRT及注册机安装打开注册机生成key输入注册信息 因为安装SercureCRT比较简单，这里就不过多介绍，在这里附上一个详细的安装步骤。 连接： 输入ip、username、password建立session；设置session选项；（输出日志文件文件可以保存命令）其他一些个性化配置可以参考。 2、FileZilla FTP ClientFileZilla用于从Windows上传文件到服务器。 下载、安装FileZilla直接官网下载安装 建立连接输入sftp://ip，username，password（端口若无修改可以不填） 四、安装java Web环境 1、安装JDK并配置环境变量查看当前系统是否安装过JDK：rpm -qa|grep java（某些系统默认安装了JDK1.7） 如果有JDK，卸载：12yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-4ojpp.155yum -y remove java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 上传并解压安装包：12cd /usr/localmkdir jdk_home tomcat_home soft 通过Filezilla上传tar.gz压缩包：12cd softtar -xvf jdk-8u144-linux-x64.tar.gz -C /usr/local/jdk_home 配置JDK环境变量： 打开文件：vi /etc/profile 将下列内容追加到末尾： #set java environment JAVA_HOME=/usr/local/jdk_home/jdk1.8 CLASSPATH=.:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 使文件生效：source /etc/profile 查看java版本：java-version 2、安装MySQL并配置mysql的安装 yum install mysqlyum install mysql-develyum install mysql-server（会出错） CentOS 7将MySQL从默认的程序列表中移除，用mariadb代替了。 官网下载安装mysql-server wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 安装成功后重启mysql服务service mysqld restart 初次安装mysql，root账号没有密码mysql -u root设置密码：set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;root&#39;); 安装完后mariadb自动被替换了，将不再生效rpm -qa |grep mariadb 配置mysql 编码：打开mysql配置文件：vi /etc/my.cnf在最后追加编码配置： 12[mysql] default-character-set =utf8 远程连接设置： 把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户：mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;root&#39;;如果是新用户而不是root，则要先新建用户:mysql&gt; create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;; 测试mysql启动停止service mysqld start/stop mysql的安装就到这里了，附上一个[详细说明](http://www.cnblogs.com/starof/p/4680083.html)。 3、安装Tomcat并配置解析Tomact 解压：tar -xvf apache-tomcat-9.0.0.M26.tar.gz -C /usr/local/tomcat_home；重命名：mv apache-tomcat-9.0…. tomcat9 配置环境变量 vi /etc/profile在文件最后追加配置： #tomcat evn CATALINA_HOME=/usr/local/tomcat_home/tomcat9 export CATALINA_HOME 配置tomcat的catalina.sh文件 cd $CATALINA_HOME/binvi catalina.sh找到 # OS specific support，然后在这行下面添加以下配置：CATALINA_HOME=/usr/local/tomcat_home/tomcat9JAVA_HOME=/usr/local/jdk_home/jdk1.8 安装tomcat服务12cd $CATALINA_HOME/bincp catalina.sh /etc/init.d/tomcat 测试tomcat的启动和停用12service tomcat startservice tomcat stop 防火墙配置到这里Tomcat环境就已经搭建完成了，附上[参考文档](http://www.jianshu.com/p/b71296e8b9a7)。 五、更多配置 这里只是简单地在阿里云的云服务器上搭建了java Web环境，其他的一些配置就需要以后有需求或者遇到困难的时候解决。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2017%2F10%2F30%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基本语法 在HTML区块标签间的Markdown格式语法将不会被处理。 &lt; 和 &amp; 特殊字符自动转换。 段落由一个或多个连续的文本行组成，它的前后要有一个以上的空行。 （空行的定义是显示上看起来像是空的，便会被视为空行） 两个以上的空格可实现 &lt;br\&gt; 标签。 二、区块元素（一）标题设置 效果：让字体变大，和word的标题意思一样。 在Markdown当中设置标题，有两种方式：-在文字下方添加 = 和 - ，他们分别表示一级标题和二级标题。-在文字开头加上 #，通过 # 数量表示几级标题。 （一共只有1-6级标题，1级标题字体最大） （二）区块引用 先断好行，然后在每行（或第一行）的最前面加上 &gt; 。 区块引用可以嵌套。 （三）列表 无序列表：在文字开头添加(*,+,-)实现无序列表。（和文字之间添加空格） 有序列表：使用数字后面跟上句号。（和文字之间添加空格） （四）分割线 在空白行下方添加 --- 横线。 三、区段元素（一）链接Markdown中有两种方式实现链接，分别为内联方式和引用方式。 内联方式：This is an [example link](http://example.com/). 引用方式：I get from [Google][1] than from [Yahoo][2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; （二）强调 斜体：文字两端使用1个“*”或者“_”夹起来。 粗体：文字两端使用2个“*”或者“_”夹起来。 （三）代码实现方式有两种： 简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的） 大片文字需要实现代码框。使用Tab或四个空格。 （四）图片 内联方式：![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式：![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 四、其它（一）表格 用|表示表格纵向边界，表头和表内容用-隔开。 —-:为右对齐 :—-为左对齐 :—:居中对齐 —–默认左对齐。 （二）删除线 使用~~表示删除线。 注意：~~和被删除的文字之间不能有空格。 （三）脚注（之间必须空一行）hello[^hello][^hello]: hi]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
