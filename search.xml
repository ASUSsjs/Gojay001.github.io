<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跟我学Shiro（三）-授权]]></title>
    <url>%2F2017%2F11%2F23%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[简介授权：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：主体（Subject）、资源（Resource）、权限（Permission）、角色（Role）。 主体：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。 资源：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。 权限：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。 角色：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。 隐式角色：即直接通过角色来验证用户有没有操作权限。 显式角色：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。 了解更多：搜索“RBAC”和“RBAC新解”分别了解“基于角色的访问控制”和“基于资源的访问控制”。 授权方式 Shiro支持三种方式的授权。 编程式通过写if/else授权代码块完成：123456Subject subject = SecurityUtils.getSubject(); if(subject.hasRole(“admin”)) &#123; //有权限 &#125; else &#123; //无权限 &#125; 注解式通过在执行的Java方法上放置相应的注解完成：1234@RequiresRoles(&quot;admin&quot;) public void hello() &#123; //有权限 &#125; 没有权限将抛出相应的异常。 JSP/GSP标签在JSP/GSP页面通过相应的标签完成：123&lt;shiro:hasRole name=&quot;admin&quot;&gt; &lt;!— 有权限 —&gt; &lt;/shiro:hasRole&gt; 授权基于角色的访问控制（隐式角色）在ini配置文件配置用户拥有的角色 shiro-role.ini 123[users]root=root,role1,role2gojay=test,role1 规则：“用户名=密码,角色1，角色2”，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息；也就是说Shiro不负责维护用户-角色信息，需要应用提供，Shiro只是提供相应的接口方便验证。 测试用例 com.github.gojay001.test.RoleTest 12345678910111213@Testpublic void testHasRole() &#123; login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有角色：role1 Assert.assertTrue(subject().hasRole(&quot;role1&quot;)); // 判断拥有角色：role1 and role2 Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;))); // 判断拥有角色：role1 and role2 and !role3 boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;)); Assert.assertEquals(true, result[0]); Assert.assertEquals(true, result[1]); Assert.assertEquals(false, result[2]);&#125; Shiro提供了hasRole/hasAllRoles用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。 12345678@Test(expected = UnauthorizedException.class)public void testCheckRole() &#123; login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 断言拥有角色：role1 subject().checkRole(&quot;role1&quot;); // 断言拥有角色：role1 and role3 失败抛出异常 subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);&#125; Shiro提供的checkRole/checkRoles和hasRole/hasAllRoles不同的地方是它在判断为假的情况下会抛出UnauthorizedException异常。 基于角色的访问控制（即隐式角色）的缺点：如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把所有相关的地方进行删除；这就是粗粒度造成的问题。 基于资源的访问控制（显式角色）在ini配置文件配置用户拥有的角色及角色-权限关系 shiro-permission.ini 123456[users]root=root,role1,role2gojay=test,role1[roles]role1=user:create,user:updaterole2=user:create,user:delete 规则：“用户名=密码，角色1，角色2”“角色=权限1，权限2”，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。 测试用例 com.github.gojay001.test.PermissionTest 12345678910@Testpublic void testIsPermitted() &#123; login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有权限：user:create Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;)); // 判断拥有权限：user:update and user:delete Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;)); // 判断没有权限：user:view Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));&#125; Shiro提供了isPermitted和isPermittedAll用于判断用户是否拥有某个权限或所有权限，也没有提供如isPermittedAny用于判断拥有某一个权限的接口。 12345678910@Test(expected = UnauthorizedException.class)public void testCheckPermission() &#123; login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 断言拥有权限：user:create subject().checkPermission(&quot;user:create&quot;); // 断言拥有权限：user:delete and user:update subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;); // 断言拥有权限：user:view 失败抛出异常 subject().checkPermissions(&quot;user:view&quot;);&#125; checkPermissions失败的情况下会抛出UnauthorizedException异常。 基于资源的访问控制（显式角色），也可以叫基于权限的访问控制，这种方式的一般规则是“资源标识符：操作”，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。 Permission字符串通配符权限规则：“资源标识符：操作：对象实例ID” 即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，“:”表示资源/操作/实例的分割；“,”表示操作的分割；“*”表示任意资源/操作/实例。 单个资源单个权限1subject().checkPermissions(&quot;system:user:update&quot;); 用户拥有资源“system:user”的“update”权限。 单个资源多个权限ini配置文件：1role41=system:user:update,system:user:delete 通过判断：1subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;); 可以简写为：&quot;system:user:update,delete&quot; 用户拥有资源“system:user”的“update”和“delete”权限。 单个资源全部权限ini配置：1role51=&quot;system:user:create,update,delete,view&quot; 通过判断：1subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;); 可以简写为：system:user:* 用户拥有资源“system:user”的“create”、“update”、“delete”和“view”所有权限。 所有资源全部权限ini配置：1role61=*:view 通过判断：1subject().checkPermissions(&quot;user:view&quot;); 用户拥有所有资源的“view”所有权限。 实例级别的权限单个实例单个权限ini配置：1role71=user:view:1 通过判断：1subject().checkPermissions(&quot;user:view:1&quot;); 对资源user的1实例拥有view权限。 单个实例多个权限ini配置：1role72=&quot;user:update,delete:1&quot; 通过判断：12subject().checkPermissions(&quot;user:delete,update:1&quot;); subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;); 对资源user的1实例拥有update、delete权限。 单个实例所有权限ini配置：1role73=user:*:1 通过判断：1subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;); 对资源user的1实例拥有所有权限。 所有实例单个权限ini配置：1role74=user:auth:* 通过判断：1subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;); 对资源user的1实例拥有所有权限。 所有实例所有权限ini配置：1role75=user:*:* 通过判断：1subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;); 对资源user的1实例拥有所有权限。 Shiro对权限字符串缺失部分的处理 如user:view 等价于 user:view:*；organization 等价于 organization:* 或者 organization:*:*。可以这么理解，这种方式实现了前缀匹配。 如user:* 可以匹配 user:delete；user:delete 可以匹配 user:delete:1；user:*:1 可以匹配 user:view:1；user 可以匹配 user:view 或 user:view:1等。即*可以匹配所有，不加*可以进行前缀匹配； 如*:view 不能匹配 system:user:view；需要使用 *:*:view；即后缀匹配必须指定前缀（多个冒号就需要多个*来匹配）。 WildcardPermission如下两种方式是等价的：12subject().checkPermission(&quot;menu:view:1&quot;); subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;)); 因此没什么必要的话使用字符串更方便。 性能问题通配符匹配方式比字符串匹配来说是更复杂的，因此需要花费更长时间，但是一般系统的权限不会太多，且可以配合缓存来提供其性能，如果这样性能还达不到要求我们可以实现位操作算法实现性能更好的权限匹配。另外实例级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如在sql查询时加上权限字符串之类的方式在查询时就完成了权限匹配。 授权流程 流程如下： 首先调用Subject.isPermitted*/hasRole*接口，其会委托给SecurityManager，而SecurityManager接着会委托给Authorizer； Authorizer是真正的授权者；如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver把字符串转换成相应的Permission实例； 在进行授权之前，其会调用相应的Realm获取Subject相应的角色/权限用于匹配传入的角色/权限； Authorizer会判断Realm的角色/权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted/hasRole会返回true，否则返回false表示授权失败。 ModularRealmAuthorizer进行多Realm匹配流程： 首先检查相应的Realm是否实现了Authorizer； 如果实现了Authorizer，那么接着调用其相应的isPermitted*/hasRole*接口进行匹配； 如果有一个Realm匹配那么将返回true，否则返回false。 如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是： 如果调用hasRole*，则直接获取AuthorizationInfo.getRoles()与传入的角色比较即可； 如果调用如isPermitted(“user:view”)，首先通过PermissionResolver将权限字符串转换成相应的Permission实例，默认使用WildcardPermissionResolver，即转换为通配符的WildcardPermission； 通过AuthorizationInfo.getObjectPermissions()得到Permission实例集合；通过AuthorizationInfo. getStringPermissions()得到字符串集合并通过PermissionResolver解析为Permission实例；然后获取用户的角色，并通过RolePermissionResolver解析角色对应的权限集合（默认没有实现，可以自己提供）； 接着调用Permission. implies(Permission p)逐个与传入的权限比较，如果有匹配的则返回true，否则false。 AuthorizerAuthorizer的职责是进行授权（访问控制），提供了相应的角色/权限判断接口。SecurityManager继承了Authorizer接口，且提供了ModularRealmAuthorizer用于多Realm时的授权匹配。PermissionResolver用于解析权限字符串到Permission实例。RolePermissionResolver用于根据角色解析相应的权限集合。 可以通过如下ini配置更改Authorizer实现： 12authorizer=org.apache.shiro.authz.ModularRealmAuthorizer securityManager.authorizer=$authorizer 设置ModularRealmAuthorizer的permissionResolver，其会自动设置到相应的Realm上（其实现了PermissionResolverAware接口），如： 12permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver authorizer.permissionResolver=$permissionResolver 设置ModularRealmAuthorizer的rolePermissionResolver，其会自动设置到相应的Realm上（其实现了RolePermissionResolverAware接口），如： 12rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver authorizer.rolePermissionResolver=$rolePermissionResolver 示例ini配置 shiro-jdbc-authorizer.ini 123456789101112131415161718192021222324[main]#自定义authorizerauthorizer=org.apache.shiro.authz.ModularRealmAuthorizer#自定义permissionResolver#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolverpermissionResolver=com.github.gojay001.permission.BitAndWildPermissionResolverauthorizer.permissionResolver=$permissionResolver#自定义rolePermissionResolverrolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolverauthorizer.rolePermissionResolver=$rolePermissionResolversecurityManager.authorizer=$authorizer#自定义realm 一定要放在securityManager.authorizer赋值之后#因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolverjdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealmdataSource=com.alibaba.druid.pool.DruidDataSourcedataSource.driverClassName=com.mysql.jdbc.DriverdataSource.url=jdbc:mysql://localhost:3306/shirodataSource.username=rootdataSource.password=rootjdbcRealm.dataSource=$dataSourcejdbcRealm.permissionsLookupEnabled=truesecurityManager.realms=$jdbcRealm 不能使用IniSecurityManagerFactory创建的IniRealm，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。 定义BitAndWildPermissionResolver及BitPermission BitPermission用于实现位移方式的权限，如规则是：权限字符串格式：+资源字符串+权限位+实例ID；以+开头中间通过+分割；权限：0 表示所有权限；1 新增（二进制：0001）、2 修改（二进制：0010）、4 删除（二进制：0100）、8 查看（二进制：1000）；如 +user+10 表示对资源user拥有修改/查看权限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class BitPermission implements Permission &#123; private String resourceIdentify; private int permissionBit; private String instanceId; public BitPermission(String permissionString) &#123; String[] array = permissionString.split(&quot;\\+&quot;); if (array.length &gt; 1) &#123; resourceIdentify = array[1]; &#125; if (StringUtils.isEmpty(resourceIdentify)) &#123; resourceIdentify = &quot;*&quot;; &#125; if (array.length &gt; 2) &#123; permissionBit = Integer.valueOf(array[2]); &#125; if (array.length &gt; 3) &#123; instanceId = array[3]; &#125; if (StringUtils.isEmpty(instanceId)) &#123; instanceId = &quot;*&quot;; &#125; &#125; public boolean implies(Permission permission) &#123; if(!(permission instanceof BitPermission)) &#123; return false; &#125; BitPermission other = (BitPermission) permission; if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123; return false; &#125; if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123; return false; &#125; if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123; return false; &#125; return true; &#125; @Override public String toString() &#123; return &quot;BitPermission&#123;&quot; + &quot;resourceIdentify=&apos;&quot; + resourceIdentify + &apos;\&apos;&apos; + &quot;, permissionBit=&quot; + permissionBit + &quot;, instanceId=&apos;&quot; + instanceId + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; Permission接口提供了boolean implies(Permission p)方法用于判断权限匹配的；123456789public class BitAndWildPermissionResolver implements PermissionResolver &#123; @Override public Permission resolvePermission(String permissionString) &#123; if(permissionString.startsWith(&quot;+&quot;)) &#123; return new BitPermission(permissionString); &#125; return new WildcardPermission(permissionString); &#125; &#125; BitAndWildPermissionResolver实现了PermissionResolver接口，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。 定义MyRolePermissionResolverRolePermissionResolver用于根据角色字符串来解析得到权限集合。123456789public class MyRolePermissionResolver implements RolePermissionResolver &#123; @Override public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123; if(&quot;role1&quot;.equals(roleString)) &#123; return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;)); &#125; return null; &#125; &#125; 自定义Realm使用JdbcRealm，需要做的操作如下： 执行sql/shiro-init-data.sql 插入相关的权限数据； 使用shiro-jdbc-authorizer.ini配置文件，需要设置jdbcRealm.permissionsLookupEnabled为true来开启权限查询。 这里也可以自定义实现Realm，可参考com.github.gojay001.realm.MyRealm 测试用例123456789101112131415@Testpublic void testIsPermitted2() &#123; login(&quot;classpath:shiro-jdbc-authorizer.ini&quot;, &quot;root&quot;, &quot;root&quot;); // 判断拥有权限：user:create Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;)); Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;)); // 通过二进制位的方式表示权限 Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));// 新增权限 Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));// 查看权限 Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));// 新增及查看 Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));// 没有删除权限 Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));// 通过MyRolePermissionResolver解析得到的权限&#125; 总结授权流程 Subject.isPermitted*/hasRole* SecurityManager Authorizer PermissionResolver/RolePermissionResolver/Permission Realm Realm user role permission Security Authorizer PermissionResolver RolePermissionResolver Realm Subject hasRole/hasAllRoles checkRole/checkRoles isPermitted/isPermittedAll checkPermission/checkPermissions 参考代码：https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
        <tag>授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（二）-身份认证]]></title>
    <url>%2F2017%2F11%2F22%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[简介身份验证：在应用中能证明他就是他本人。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。在 shiro 中，用户需要提供 principals （身份）和 credentials（证明）给 shiro，从而应用能验证用户身份。 principals：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但只有一个 Primary principals，一般是用户名/密码/手机号。 credentials：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。 最常见的 principals 和 credentials 组合就是用户名/密码了。另外两个相关的概念是之前提到的 Subject 及 Realm，分别是主体及验证主体的数据源。 环境准备使用Maven构建准备环境依赖：添加 junit、common-logging 及 shiro-core 依赖； 更新：加入slf4j-nop依赖包。 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 登录/退出准备一些用户身份/凭据 shiro.ini 123[users]gojay=testroot=root 此处使用ini配置文件，通过[user]指定两个主体。 测试用例 com.github.gojay001.test.LoginLogoutTest更新：注意类过时。 12345678910111213141516171819202122232425@Testpublic void testLoginLogout() &#123; //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;); //2、得到SecurityManager实例 并绑定给SecurityUtils SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;); try &#123; //4、登录，即身份验证 subject.login(token); &#125; catch (AuthenticationException e) &#123; //5、身份验证失败 &#125; Assert.assertEquals(true, subject.isAuthenticated()); //6、退出 subject.logout();&#125; 首先通过new IniSecurityManagerFactory并指定一个ini配置文件来创建一个SecurityManager工厂； 接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可； 通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token，如用户名/密码； 调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录； 如果身份验证失败捕获AuthenticationException或其子类，常见的如： DisabledAccountException（禁用的帐号）、LockedAccountException（锁定的帐号）、UnknownAccountException（错误的帐号）、ExcessiveAttemptsException（登录失败次数过多）、IncorrectCredentialsException （错误的凭证）、ExpiredCredentialsException（过期的凭证）等，具体查看其继承关系； 最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。 总结步骤 收集用户身份/凭证，即如用户名/密码； 调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功； 最后调用Subject.logout进行退出操作。 存在问题 用户名/密码硬编码在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储； 用户身份Token可能不仅仅是用户名/密码，也可能还有其他的，如登录时允许用户名/邮箱/手机号同时登录。 身份认证流程 流程如下： 首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置； SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证； Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现； Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证； Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。 RealmRealm：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即安全数据源。 org.apache.shiro.realm.Realm接口如下：123String getName(); //返回一个唯一的Realm名字 boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //根据Token获取认证信息 单Realm配置自定义Realm实现 com.github.gojay001.realm.MyRealm1 1234567891011121314151617181920212223242526 public class MyRealm1 implements Realm &#123; public String getName() &#123; return &quot;myRealm1&quot;; &#125; public boolean supports(AuthenticationToken authenticationToken) &#123; return authenticationToken instanceof UsernamePasswordToken; &#125; public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; // 得到用户名 String username = (String)authenticationToken.getPrincipal(); // 得到密码 String password = new String((char[])authenticationToken.getCredentials()); if(!&quot;root&quot;.equals(username)) &#123; //用户名错误 throw new UnknownAccountException(); &#125; if(!&quot;root&quot;.equals(password)) &#123; //密码错误 throw new IncorrectCredentialsException(); &#125; //如果身份认证验证成功，返回一个AuthenticationInfo实现； return new SimpleAuthenticationInfo(username, password, getName()); &#125;&#125; ini配置文件指定自定义Realm实现 shiro-realm.ini 1234#声明一个realmmyRealm1=com.github.gojay001.realm.MyRealm1#指定securityManager的realms实现securityManager.realms=$myRealm1 通过$name来引入之前的realm定义。 多Realm配置ini配置文件 shiro-multi-realm.ini 12345#声明一个realm myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1 myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2 #指定securityManager的realms实现 securityManager.realms=$myRealm1,$myRealm2 securityManager会按照realms指定的顺序进行身份认证。 Shiro默认提供的Realm 以后一般继承AuthorizingRealm（授权）即可；其继承了AuthenticatingRealm（即身份验证），而且也间接继承了CachingRealm（带有缓存实现）。其中主要默认实现如下： org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息； org.apache.shiro.realm.text.PropertiesRealm： user.username=password,role1,role2指定用户名/密码及其角色；role.role1=permission1,permission2指定角色及权限信息； org.apache.shiro.realm.jdbc.JdbcRealm：通过sql查询相应的信息，如“select password from users where username = ?”获取用户密码，“select role_name from user_roles where username = ?”获取用户角色；“select permission from roles_permissions where role_name = ?”获取角色对应的权限信息；也可以调用相应的api进行自定义sql； JDBC Realm使用数据库及依赖 更新：alibaba的druid包更新版本。 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt; 本文将使用mysql数据库及druid连接池。 数据库下建表users（用户名/密码）、user_roles（用户/角色）、roles_permissions（角色/权限）；具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。 ini配置 shiro-jdbc-realm.ini 12345678jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm dataSource=com.alibaba.druid.pool.DruidDataSource dataSource.driverClassName=com.mysql.jdbc.Driver dataSource.url=jdbc:mysql://localhost:3306/shiro dataSource.username=root dataSource.password=rootjdbcRealm.dataSource=$dataSource securityManager.realms=$jdbcRealm 变量名=全限定类名 自动创建一个类实例 变量名.属性=值 自动调用相应的setter方法进行赋值 $变量名 引用之前的一个对象实例 测试代码和之前的没什么区别。 Authenticator及AuthenticationStrategy原理Authenticator的职责是验证用户帐号，是Shiro API中身份验证核心的入口点：1public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException; 如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；如果验证失败将抛出相应的AuthenticationException实现。 SecurityManager接口继承了Authenticator，另外还有一个ModularRealmAuthenticator实现，其委托给多个Realm进行验证，验证规则通过AuthenticationStrategy接口指定，默认提供的实现： FirstSuccessfulStrategy：只要有一个Realm验证成功即可，只返回第一个Realm身份验证成功的认证信息，其他的忽略； AtLeastOneSuccessfulStrategy：只要有一个Realm验证成功即可，和FirstSuccessfulStrategy不同，返回所有Realm身份验证成功的认证信息； AllSuccessfulStrategy：所有Realm验证成功才算成功，且返回所有Realm身份验证成功的认证信息，如果有一个失败就失败了。 ModularRealmAuthenticator默认使用AtLeastOneSuccessfulStrategy策略。 示例 假设有三个realm：myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root； ini配置文件 shiro-authenticator-all-success.ini 12345678910111213[main]#指定securityManager的authenticator实现authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticatorsecurityManager.authenticator=$authenticator#指定securityManager.authenticator的authenticationStrategyallSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategysecurityManager.authenticator.authenticationStrategy=$allSuccessfulStrategymyRealm1=com.github.gojay001.realm.MyRealm1myRealm2=com.github.gojay001.realm.MyRealm2myRealm3=com.github.gojay001.realm.MyRealm3securityManager.realms=$myRealm1,$myRealm3 测试代码 com.github.gojay001.test.AuthenticatorTest 首先通用化登录逻辑123456789101112131415private void login(String configFile) &#123; //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory = new IniSecurityManagerFactory(configFile); //2、得到SecurityManager实例 并绑定给SecurityUtils org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance(); SecurityUtils.setSecurityManager(securityManager); //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证） Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;); subject.login(token); &#125; 测试AllSuccessfulStrategy成功123456789@Test public void testAllSuccessfulStrategyWithSuccess() &#123; login(&quot;classpath:shiro-authenticator-all-success.ini&quot;); Subject subject = SecurityUtils.getSubject(); //得到一个身份集合，其包含了Realm验证成功的身份信息 PrincipalCollection principalCollection = subject.getPrincipals(); Assert.assertEquals(2, principalCollection.asList().size()); &#125; 测试AllSuccessfulStrategy失败12345@Test(expected = UnknownAccountException.class) public void testAllSuccessfulStrategyWithFail() &#123; login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;); Subject subject = SecurityUtils.getSubject(); &#125; shiro-authenticator-all-fail.ini 与 shiro-authenticator-all-success.ini 不同的配置是使用了 securityManager.realms=$myRealm1,$myRealm2 ；即myRealm验证失败。 对于 AtLeastOneSuccessfulStrategy 和 FirstSuccessfulStrategy 的区别：唯一不同点一个是返回所有验证成功的Realm的认证信息；另一个是只返回第一个验证成功的Realm的认证信息.示例代码同上 自定义AuthenticationStrategy实现首先看其API：1234567891011121314151617//在所有Realm验证之前调用 AuthenticationInfo beforeAllAttempts( Collection&lt;? extends Realm&gt; realms, AuthenticationToken token) throws AuthenticationException; //在每个Realm之前调用 AuthenticationInfo beforeAttempt( Realm realm, AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException; //在每个Realm之后调用 AuthenticationInfo afterAttempt( Realm realm, AuthenticationToken token, AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t) throws AuthenticationException; //在所有Realm之后调用 AuthenticationInfo afterAllAttempts( AuthenticationToken token, AuthenticationInfo aggregate) throws AuthenticationException; 因为每个AuthenticationStrategy实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；通过如上接口可以进行如合并/返回第一个验证成功的认证信息。自定义实现时一般继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy 即可。参考代码同上 到此基本的身份验证就结束了。 总结问题描述Assert过时 Assert in junit.framework has been deprecated解决：将 import junit.framework.Assert; 改为 import org.junit.Assert; SLF4J加载失败 SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”解决：Maven引入slf4j-nop包：12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.6&lt;/version&gt;&lt;/dependency&gt; implements不需要@Overridealibaba的druid版本更新重点用户登录流程 Subject.login(token) SecurityManager Authenticator AuthenticatorStrategy Realm Realm 单Realm 多Realm JDBCRealm AuthenticatorStrategy FirstSuccessfulStrategy AtLeastOneSuccessfulStrategy AllSuccessfulStrategy 自定义Strategy 参考代码：https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
        <tag>身份认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟我学Shiro（一）-Shiro简介]]></title>
    <url>%2F2017%2F11%2F19%2F%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[简介认识 Apache Shiro是Java的一个安全框架。 对比Spring Security小而简单。 可同时用在JavaSE、JavaEE环境中。 主要完成认证、授权、加密、会话管理、与Web集成、缓存等。 功能 Authentication：身份认证/登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限； Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 Shiro不会去维护用户、维护权限；这些需要自己设计提供，然后通过相应的接口注入给Shiro。 架构从外部看Shiro： Subject：主体；代表了与当前应用交互的用户，如网络爬虫、机器人等；所有 Subject 都绑定到 SecurityManager，与 Subject 的所有交互都会委托给 SecurityManager；可以把 Subject 认为是一个门面，SecurityManager 才是实际的执行者； SecurityManager：安全管理器；即所有与安全有关的操作都会与 SecurityManager 交互，且它管理着所有 Subject；它是 Shiro 的核心，负责与其他组件进行交互，可以把它看成Spring NVC中的 DispatcherServlet 前端控制器； Realm：域；Shiro 从 Realm 获取安全数据（如用户、角色、权限），就是说 SecurityManager 要验证用户身份，那么它需要从 Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从 Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 DataSource，即安全数据源。 最简单的一个 Shiro 应用： 应用代码通过 Subject 来进行认证和授权，而 Subject 又委托给 SecurityManager； 我们需要给 Shiro 的 SecurityManager 注入 Realm，从而让 SecurityManager 能得到合法的用户及其权限进行判断。 可以看出：Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。 从内部看Shiro： Subject：主体；可以看到主体可以是任何可以与应用交互的“用户”； SecurityManager ：安全管理器；所有具体的交互都通过 SecurityManager 进行控制；它管理着所有 Subject，且负责进行认证和授权、及会话、缓存的管理，是Shiro的心脏； Authenticator：认证器；负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略Authentication Strategy，即什么情况下算用户认证通过了； Authrizer：授权器；用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能； Realm：可以有 1 个或多个 Realm，可以认为是安全实体数据源，即用于获取安全实体的，由用户提供；Shiro 不知道用户/权限存储在哪及以何种格式存储，所以我们一般在应用中都需要实现自己的 Realm； SessionManager：Session需要有人去管理它的生命周期，这个组件就是SessionManager；Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）； SessionDAO：数据访问对象DAO，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如JDBC写到数据库；比如想把 Session 放到Memcached中，可以实现自己的 Memcached SessionDAO；另外 SessionDAO 中可以使用 Cache 进行缓存，以提高性能； CacheManager：缓存控制器；来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能； Cryptography：密码模块;Shiro 提高了一些常见的加密组件用于如密码加密/解密的。 到此 Shiro 架构及其组件就认识完了。]]></content>
      <categories>
        <category>Shiro</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web路径问题解析]]></title>
    <url>%2F2017%2F11%2F19%2FJava-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基本概念的理解 绝对路径：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：C:\xyz\test.txt；http://www.test.com/index.html； 相对路径：相对与某个基准目录的路径，例如：&quot;/&quot;代表Web应用的根目录，&quot;./&quot;代表当前目录,&quot;../&quot;代表上级目录。 另外关于URI，URL,URN等内容，请参考RFC相关文档标准。 关于JSP/Servlet中的相对路径和绝对路径服务器端的地址 服务器端的相对地址指的是相对于你的web应用的地址，这个地址是在服务器端解析的（不同于html和javascript中的相对地址，他们是由客户端浏览器解析的）；在jsp和servlet中的相对地址应该是相对于你的web应用，即相对于http://192.168.0.1/webapp/的。 用到的地方： forward：servlet中的request.getRequestDispatcher(address);这个address是在服务器端解析的。request.getRequestDispatcher(“/pages/a.jsp”)的绝对路径地址：http://192.168.0.1/webapp/pages/a.jsp； sendRedirect：在jsp中&lt;%response.sendRedirect(&quot;/user/a.jsp&quot;);%&gt;。 客户端的地址 所有的html页面中的相对地址都是相对于服务器根目录http://192.168.0.1/的，而不是根目录下的该Web应用的目录：http://192.168.0.1/webapp/。 HTML中的form表单的action属性的地址应该是相对于服务器根目录http://192.168.0.1/；如果提交到a.jsp为：action＝&quot;/webapp/user/a.jsp&quot;或action=&quot;&lt;%=request.getContextPath()%&gt;&quot;/user/a.jsp； Javascript也是在客户端解析的，所以其相对路径和form表单一样。 因此，一般情况下，在JSP/HTML页面等引用的CSS、Javascript、Action等属性前面最好都加上&lt;%=request.getContextPath()%&gt;,以确保所引用的文件都属于Web应用中的目录。另外，应该尽量避免使用类似&quot;.&quot;,&quot;./&quot;,&quot;../&quot;等类似的相对该文件位置的相对路径，这样当文件移动时，很容易出问题。 站点根目录和css路径问题 当在jsp中引入css时，如果其相对路径相对于当前jsp文件的，而在一个和这个jsp的路径不一样的servlet中forward这个jsp时，就会发现这个css样式根本没有起作用。这是因为在servlet中转发时css的路径就是相对于这个servlet的相对路径，而非jsp的路径了。所以这时候不能在jsp中用这样的路径：&lt;link href=&quot;one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;或者&lt;link href=&quot;../../one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;。这个时候要用站点根目录，就是相对于http://192.168.0.1/的目录，以&quot;/&quot;开头。因此上述错误应更正为href=”/test/one.css” 类似的站点根目录的相对目录。 获得JSP/Servlet中当前应用的相对路径和绝对路径JSP中获得当前应用的相对路径和绝对路径 根目录所对应的绝对路径:request.getRequestURI(); 文件的绝对路径:application.getRealPath(request.getRequestURI()); 当前web应用的绝对路径:application.getRealPath(&quot;/&quot;); 请求文件的上层目录:new File(application.getRealPath(request.getRequestURI())).getParent(); Servlet中获得当前应用的相对路径和绝对路径 根目录所对应的绝对路径:request.getServletPath(); 文件的绝对路径:request.getSession().getServletContext(). getRealPath(request.getRequestURI()); 当前web应用的绝对路径:servletConfig.getServletContext().getRealPath(&quot;/&quot;); ServletContext对象获得几种方式：javax.servlet.http.HttpSession.getServletContext();javax.servlet.jsp.PageContext.getServletContext();javax.servlet.ServletConfig.getServletContext(); JAVA的Class中获得相对路径，绝对路径单独的Java类中获得绝对路径 根据java.io.File的Doc文挡，可知: 默认情况下new File(&quot;/&quot;)代表的目录为：System.getProperty(&quot;user.dir&quot;);程序获得执行类的当前路径: 123456789101112import java.io.File;public class FileTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;)); System.out.println(FileTest.class.getClassLoader().getResource(&quot;&quot;)); System.out.println(ClassLoader.getSystemResource(&quot;&quot;)); System.out.println(FileTest.class.getResource(&quot;&quot;)); System.out.println(FileTest.class.getResource(&quot;/&quot;));//Class文件所在路径 System.out.println(new File(&quot;/&quot;).getAbsolutePath()); System.out.println(System.getProperty(&quot;user.dir&quot;)); &#125;&#125; 服务器中的Java类获得当前路径Weblogic WebApplication的系统文件根目录是你的weblogic安装所在根目录。例如：如果你的weblogic安装在c:\bea\weblogic700.....那么，你的文件根路径就是c:\所以，有两种方式能够让你访问你的服务器端的文件: 使用绝对路径：比如将你的参数文件放在c:\yourconfig\yourconf.properties，直接使用new FileInputStream(&quot;yourconfig/yourconf.properties&quot;); 使用相对路径：相对路径的根目录就是你的webapplication的根路径，即WEB-INF的上一级目录，将你的参数文件放在yourwebapp\yourconfig\yourconf.properties，这样使用：new FileInputStream(&quot;./yourconfig/yourconf.properties&quot;); Tomcat 在类中输出System.getProperty(&quot;user.dir&quot;);显示的是%Tomcat_Home%/bin 如何读相对路径哪? 在Java文件中getResource或getResourceAsStream均可。例：getClass().getResourceAsStream(filePath);filePath可以是”/filename”,这里的/代表web发布根路径下WEB-INF/classes。 参考文档：java路径问题]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>路径问题</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web编码问题详解]]></title>
    <url>%2F2017%2F11%2F15%2Fweb%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言最近搭建spring mvc项目时又再次遇到了编码问题，仔细想想，虽然以前用JSP+Servlet的时候解决了中文乱码的问题，但是都没有仔细分析过每个流程。于是今天在这里整理一下,web应用中常见的与编码相关配置： 项目配置 首先配置好项目里的编码，这里主要有三个地方需要注意： 页面乱码 页面乱码相对简单，只需要设置相关字符集编码即可。 JSP页面1&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; pageEncoding：该页面编码格式；charset：页面解码格式。 HTML页面1&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt; 传值乱码 页面到controller传值乱码需要在web.xml配置字符编码过滤器。 直接应用spring中字符编码过滤器1234567891011121314151617&lt;!--字符编码--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 字符编码拦截器作用： 分析源码发现作用相当于servlet中：request.setCharacterEncoding(“UTF-8”);response.setCharacterEncoding(“UTF-8”); spring自带过滤器主要针对POST请求，对GET请求无效： 对于GET请求的参数乱码，解决方法是采用数据还原：String userName= request.getParameter(“userName”);userName=new String(userName.getBytes(“iso8859-1”),”UTF-8”); &lt;url-pattern&gt;中匹配说明： /：不会匹配到/*.jsp，但会匹配/login等路径类型的url；/*：会匹配/login、*.jsp、*.html等路径； 根据源码可自己编写字符编码过滤器1234567891011121314151617181920public class CharacterEncodingFilter implements Filter &#123; private String encoding = null; private FilterConfig filterConfig = null; @Override public void init(FilterConfig config) throws ServletException &#123; this.filterConfig = config; this.encoding = config.getInitParameter(&quot;encoding&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; if (encoding != null) &#123; request.setCharacterEncoding(encoding); response.setContentType(&quot;text/html;charset=&quot; + encoding); &#125; chain.doFilter(request, response); &#125;&#125; 存入数据库乱码 需要在数据库配置文件设置参数。 1url=jdbc:mysql://gojay001.mysql.rds.aliyuncs.com:3306/trade?useUnicode=true&amp;characterEncoding=utf8 环境配置 按照上述确认了项目内的字符编码后，在实际运行环境中可能还是会出现乱码的情况，比如发布到云服务器上。这时候就需要配置相关的环境，主要是数据库和tomcat的配置。 Tomcat配置 在tomcat的conf/server.xml中配置Get请求默认编码： 123456&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot; /&gt; 数据库配置 参考：CentOS安装MySQL中文乱码问题解决1、原因：安装mysql之后默认的字符编码为latin1;2、查看：show variables like &#39;%char%&#39;;3、修改为下面内容后重启mysql：vi /etc/my.cf;12345678910111213141516171819202122[mysqld]character_set_server=utf8lower_case_table_names=1datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqlsymbolic-links=0sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [mysqld_safe]default-character-set = utf8log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid[client]default-character-set = utf8[mysql.server]default-character-set = utf8[mysql]default-character-set = utf8 其他问题HTML文件仍然显示乱码：将编码格式保存为UTF-8包含BOM 这次总结编码也就是因为遇到这个问题，一直以为是项目配置或者服务器的问题，困扰了几天后才发现这个原因。至于为什么需要带BOM，网上的评论也很多，这里也确实解决了我出现的问题。 静态资源访问：1、在web.xml中配置：12345678910111213141516171819202122232425&lt;!--解决静态资源访问--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2、路径说明：/page/index.html:根目录下的page文件夹；../page/index.html:当前路径的上一级的page文件夹；page/index.html:当前路径的page文件夹。 以上目前我所遇到并解决的问题，可能还有其他相关我不了解的配置，以后学习了也会继续补充上来。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云搭建java Web环境]]></title>
    <url>%2F2017%2F11%2F06%2F%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、前言 最近重新在阿里云上配置了服务器和数据库，今天正好整理一下配置过程并且结合以前在CentOS下搭建java Web的流程，写在这里，以免以后忘记了不知所措。下面进入主题： 二、配置阿里云 阿里云有学生优惠9.9一个月的云服务器，可以直接购买配置，选择CentOS。我在活动期间购买时花了9.9买了.xin域名和域名解析1年，还送了阿里云一整套6个月：服务器、数据库、OSS等等。我目前只在云服务器下搭建java Web环境并发布项目，然后连接的云数据库。服务器和数据库的配置都比较简单，阿里云上也有官方文档可以查看，按着步骤一步步配置下来就行了。 三、工具准备 我采用的是在Windows下开发，然后将项目发布在云服务器上。所以，首先需要在Windows下准备几个工具。 1、SecureCRTSecureCRT用于连接云服务器，能够在Windows下直接操作服务器。 安装SecureCRT： 下载SecureCRT及注册机安装打开注册机生成key输入注册信息 因为安装SercureCRT比较简单，这里就不过多介绍，在这里附上一个详细的安装步骤。 连接： 输入ip、username、password建立session；设置session选项；（输出日志文件文件可以保存命令）其他一些个性化配置可以参考。 2、FileZilla FTP ClientFileZilla用于从Windows上传文件到服务器。 下载、安装FileZilla直接官网下载安装 建立连接输入sftp://ip，username，password（端口若无修改可以不填） 四、安装java Web环境 1、安装JDK并配置环境变量查看当前系统是否安装过JDK：rpm -qa|grep java（某些系统默认安装了JDK1.7） 如果有JDK，卸载：12yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-4ojpp.155yum -y remove java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5 上传并解压安装包：12cd /usr/localmkdir jdk_home tomcat_home soft 通过Filezilla上传tar.gz压缩包：12cd softtar -xvf jdk-8u144-linux-x64.tar.gz -C /usr/local/jdk_home 配置JDK环境变量： 打开文件：vi /etc/profile 将下列内容追加到末尾： #set java environment JAVA_HOME=/usr/local/jdk_home/jdk1.8 CLASSPATH=.:$JAVA_HOME/lib/tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 使文件生效：source /etc/profile 查看java版本：java-version 2、安装MySQL并配置mysql的安装 yum install mysqlyum install mysql-develyum install mysql-server（会出错） CentOS 7将MySQL从默认的程序列表中移除，用mariadb代替了。 官网下载安装mysql-server wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpmrpm -ivh mysql-community-release-el7-5.noarch.rpmyum install mysql-community-server 安装成功后重启mysql服务service mysqld restart 初次安装mysql，root账号没有密码mysql -u root设置密码：set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;root&#39;); 安装完后mariadb自动被替换了，将不再生效rpm -qa |grep mariadb 配置mysql 编码：打开mysql配置文件：vi /etc/my.cnf在最后追加编码配置： 12[mysql] default-character-set =utf8 远程连接设置： 把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户：mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;root&#39;;如果是新用户而不是root，则要先新建用户:mysql&gt; create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;; 测试mysql启动停止service mysqld start/stop mysql的安装就到这里了，附上一个[详细说明](http://www.cnblogs.com/starof/p/4680083.html)。 3、安装Tomcat并配置解析Tomact 解压：tar -xvf apache-tomcat-9.0.0.M26.tar.gz -C /usr/local/tomcat_home；重命名：mv apache-tomcat-9.0…. tomcat9 配置环境变量 vi /etc/profile在文件最后追加配置： #tomcat evn CATALINA_HOME=/usr/local/tomcat_home/tomcat9 export CATALINA_HOME 配置tomcat的catalina.sh文件 cd $CATALINA_HOME/binvi catalina.sh找到 # OS specific support，然后在这行下面添加以下配置：CATALINA_HOME=/usr/local/tomcat_home/tomcat9JAVA_HOME=/usr/local/jdk_home/jdk1.8 安装tomcat服务12cd $CATALINA_HOME/bincp catalina.sh /etc/init.d/tomcat 测试tomcat的启动和停用12service tomcat startservice tomcat stop 防火墙配置到这里Tomcat环境就已经搭建完成了，附上[参考文档](http://www.jianshu.com/p/b71296e8b9a7)。 五、更多配置 这里只是简单地在阿里云的云服务器上搭建了java Web环境，其他的一些配置就需要以后有需求或者遇到困难的时候解决。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本语法]]></title>
    <url>%2F2017%2F10%2F30%2FMarkdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、基本语法 在HTML区块标签间的Markdown格式语法将不会被处理。 &lt; 和 &amp; 特殊字符自动转换。 段落由一个或多个连续的文本行组成，它的前后要有一个以上的空行。 （空行的定义是显示上看起来像是空的，便会被视为空行） 两个以上的空格可实现 &lt;br\&gt; 标签。 二、区块元素（一）标题设置 效果：让字体变大，和word的标题意思一样。 在Markdown当中设置标题，有两种方式：-在文字下方添加 = 和 - ，他们分别表示一级标题和二级标题。-在文字开头加上 #，通过 # 数量表示几级标题。 （一共只有1-6级标题，1级标题字体最大） （二）区块引用 先断好行，然后在每行（或第一行）的最前面加上 &gt; 。 区块引用可以嵌套。 （三）列表 无序列表：在文字开头添加(*,+,-)实现无序列表。（和文字之间添加空格） 有序列表：使用数字后面跟上句号。（和文字之间添加空格） （四）分割线 在空白行下方添加 --- 横线。 三、区段元素（一）链接Markdown中有两种方式实现链接，分别为内联方式和引用方式。 内联方式：This is an [example link](http://example.com/). 引用方式：I get from [Google][1] than from [Yahoo][2] or [MSN][3].[1]: http://google.com/ &quot;Google&quot;[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;[3]: http://search.msn.com/ &quot;MSN Search&quot; （二）强调 斜体：文字两端使用1个“*”或者“_”夹起来。 粗体：文字两端使用2个“*”或者“_”夹起来。 （三）代码实现方式有两种： 简单文字出现一个代码框。使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的） 大片文字需要实现代码框。使用Tab或四个空格。 （四）图片 内联方式：![alt text](/path/to/img.jpg &quot;Title&quot;) 引用方式：![alt text][id][id]: /path/to/img.jpg &quot;Title&quot; 四、其它（一）表格 用|表示表格纵向边界，表头和表内容用-隔开。 —-:为右对齐 :—-为左对齐 :—:居中对齐 —–默认左对齐。 （二）删除线 使用~~表示删除线。 注意：~~和被删除的文字之间不能有空格。 （三）脚注（之间必须空一行）hello[^hello][^hello]: hi]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
