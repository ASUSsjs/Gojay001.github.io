<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[记某滴一面——Java后端开发]]></title>
      <url>/2018/02/01/%E8%AE%B0%E6%9F%90%E6%BB%B4%E4%B8%80%E9%9D%A2%E2%80%94%E2%80%94Java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>在大三上的期末时间段，偶然得知某滴信息安全部的后端开发实习岗位。由于厂牌和待遇的吸引，便抱着试一试的心态投了简历。下面就一面的提问进行技术总结，答案仅为个人理解，问题没有详细解释只提出大概要点。<br><a id="more"></a></p>
<h1 id="面试细节"><a href="#面试细节" class="headerlink" title="面试细节"></a>面试细节</h1><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>首先是介绍自己，包括求职岗位，个人情况（比如学校、年级、专业等），技术学习情况（技术栈、技术能力、项目等）。</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul>
<li>项目架构</li>
<li>细节处理及实现</li>
</ul>
<p>由于在简历的项目经历必不可少，首先就选了一个项目进行细节剖析。这个就是把自己的实现思路表达出来，毕竟自己写的项目对所运用到的东西心里也有点数。针对这次面试，面试官对安全方面可能看得比较重，所以从头到尾一直在挖这边的细节。</p>
<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="String、StringBuffered"><a href="#String、StringBuffered" class="headerlink" title="String、StringBuffered"></a>String、StringBuffered</h3><ul>
<li>二者区别</li>
<li>存储在JVM哪里</li>
</ul>
<blockquote>
<p>可变，线程安全；<br>存储在常量池。</p>
</blockquote>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><ul>
<li>Class文件编码</li>
<li>谈谈遇到过的乱码问题及如何解决</li>
<li>UTF-8和UTF-16区别</li>
</ul>
<blockquote>
<p>Class文件采用Unicode编码(UTF-16)；<br>乱码问题： <strong>页面乱码</strong>（HTML、JSP）， <strong>传值乱码</strong>（配置过滤器）， <strong>数据库乱码</strong>（检查Tomcat、Mysql配置）<br>其他相关： <code>http://www.qianxingzhem.com/post-1499.html</code></p>
</blockquote>
<h3 id="abstract、interface"><a href="#abstract、interface" class="headerlink" title="abstract、interface"></a>abstract、interface</h3><ul>
<li>两者区别</li>
</ul>
<blockquote>
<p>多继承实现，全部抽象；</p>
</blockquote>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><blockquote>
<p>这个暂时不太了解，下面贴出关于新特性的官方说明和博客链接：<br>官方说明： <code>http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html</code><br>博客： <code>http://blog.csdn.net/qiubabin/article/details/70256683</code></p>
</blockquote>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>简述集合以及底层实现</li>
<li>HashMap、HashTable，如何改进</li>
<li>ArrayList、LinkedList，区别</li>
<li>HashMap、TreeMap、LinkedHashMap，区别</li>
</ul>
<blockquote>
<p>线程安全、效率；<br>数组查询，链表增删；<br><strong>HashMap</strong>：允许一条记录键为空，多条记录值为空，不同步；<br><strong>HashTable</strong>：不允许键值为空，同步，效率低；<br><strong>LinkedHashMap</strong>：保存记录的插入顺序；<br><strong>TreeMap</strong>：可以根据键排序。<br>参考： <code>http://blog.csdn.net/xin_jmail/article/details/25975085</code></p>
</blockquote>
<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><blockquote>
<p>(1)全盘负责(2)父类委托(3)缓存机制<br>参考： <code>https://www.cnblogs.com/ityouknow/p/5603287.html</code></p>
</blockquote>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul>
<li>内存模型</li>
<li>数据存储位置（如int i=0;）</li>
<li>GC（判断GC root，GC分区）</li>
</ul>
<blockquote>
<p>JVM相关： <code>http://blog.gojay.xin/2017/12/09/初识Java虚拟机/</code></p>
</blockquote>
<h2 id="专业相关"><a href="#专业相关" class="headerlink" title="专业相关"></a>专业相关</h2><ul>
<li><strong>如何保证信息没有被更改</strong></li>
<li><strong>认证、授权</strong></li>
<li><strong>数据加密</strong></li>
</ul>
<h2 id="后端相关"><a href="#后端相关" class="headerlink" title="后端相关"></a>后端相关</h2><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><blockquote>
<p>容器加载类<br>实例化<br>init()<br>service()<br>destroy()</p>
</blockquote>
<h3 id="GET、POST"><a href="#GET、POST" class="headerlink" title="GET、POST"></a>GET、POST</h3><ul>
<li>二者区别</li>
</ul>
<blockquote>
<p>body，参数，安全性。</p>
</blockquote>
<h3 id="cookie、session"><a href="#cookie、session" class="headerlink" title="cookie、session"></a>cookie、session</h3><ul>
<li>二者区别</li>
<li>两台服务器负载均衡处理session</li>
</ul>
<blockquote>
<p>客户端（浏览器）、服务器；<br>session保持、复制、共享；</p>
</blockquote>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li>Stack特性</li>
<li>用stack实现时间复杂度为O(1)的getMin()方法</li>
</ul>
<blockquote>
<p>后进先出；<br>使用辅助栈<code>http://blog.csdn.net/sheepmu/article/details/38459165</code></p>
</blockquote>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>事务及特性</li>
</ul>
<blockquote>
<p><strong>ACID</strong> <code>https://www.cnblogs.com/nobounds/p/5409472.html</code></p>
</blockquote>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>后面就根据简历上面写的东西对其他方面提了一些问题，比如看过哪些技术书籍，平时怎么学习以及解决问题等等。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这次面试整体来说，主要是简历上写了哪些就问的相关技术点，熟悉、掌握、了解都基本会提到一点。感触较大的是什么问题他都能够一直往深处挖，到最后确实不知道或者自己看情况直接说不了解。由于这次招人比较紧急，要求不算太高，所以也就放得比较宽，没有太严格。我也是匆忙投简历，加上当天考英语六级，基本上就没怎么准备。后期会结合自身再改改简历，最重要的还是提升自己，针对技术方面还是需要稳扎稳打，夯实基础。过了几天换了一个人打电话来约二面的时候再次提到了入职和任职时间，最终因为没有协调好时间就没有进行二面。虽然有点遗憾，但是我也更加了解自己现在的水平，以及正式入职所需要具备的能力。这也算是一个转折点吧，最终我决定了考研，技术方面自然也会落下不少，技术博客最近一年也不会怎么更了吧，包括这一篇本应该一个多月前更的也拖到了现在。最后的最后，祝自己考研顺利吧，不忘初心，方能始终。</p>
]]></content>
      
        <categories>
            
            <category> Interview </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初识Java虚拟机]]></title>
      <url>/2017/12/09/%E5%88%9D%E8%AF%86Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于Java的学习也有一段时间了，却始终会有一些地方容易混淆，归结原因，还是偏底层的东西不太了解。前段时间便学习了关于Java虚拟机相关的内容，主要从阅读  <em>《深入理解Java虚拟机》</em> 进行总结。</p>
<p>首先<strong>Java技术体系</strong>主要由：<strong>Java第三方框架类库</strong>、<strong>Java API类库</strong>、<strong>Java程序设计语言</strong>、<strong>Class类文件格式</strong>、<strong>Java 虚拟机</strong>构成，把Java API类库、Java程序设计语言、Java虚拟机统称为JDK，用于支持Java程序开发的最小运行环境。<br>然后从 <strong>Java内存</strong> 相关的 <code>内存模型</code> 、 <code>内存分配</code> 、 <code>垃圾回收</code> 、 <code>内存溢出</code> ； <strong>虚拟机执行子系统</strong> 相关的 <code>Class类文件结构</code> 、 <code>类加载机制</code> 、 <code>字节码执行引擎</code> ； <strong>高效并发</strong> 相关的 <code>Java内存模型与线程</code> 、 <code>线程安全与锁优化</code> 几个部分进行了<strong>Java虚拟机</strong>初步的学习。</p>
<a id="more"></a>
<h1 id="Java内存"><a href="#Java内存" class="headerlink" title="Java内存"></a>Java内存</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p><img src="/2017/12/09/初识Java虚拟机/1.png" alt="初识Java虚拟机/1.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><code>程序计数器(Program Counter Register)</code> 可以看做当前线程<strong>所执行的字节码的行号指示器</strong>，每条线程都有一个独立的程序计数器，称为 <code>线程私有</code> 内存。<br>如果线程正在执行一个<strong>Java方法</strong>，计数器记录的是正在执行的虚拟机<strong>字节码指令的地址</strong>；如果执行的是<strong>Native方法</strong>，则计数器值为<strong>空(Undefined)</strong>。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><code>虚拟机栈(Virtual Machine Stacks)</code> 是 <code>线程私有</code> ，每个<strong>方法在执行</strong>的同时都会创建一个<strong>栈帧(Stack Frame)</strong>，用于存储<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息（具体内容在后面会讲到）。每个<strong>方法从调用到执行完成</strong>对应一个<strong>栈帧从入栈到出栈</strong>。  </p>
<blockquote>
<p>经常把Java内存分为堆内存(Heap)和栈内存(Stack)，这里指的栈就是虚拟机栈。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p><code>本地方法栈(Native Method Stack)</code> 与虚拟机栈作用类似，只不过不是为Java方法（也就是字节码）服务，而是为虚拟机使用的<strong>Native方法</strong>服务。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><code>堆(Heap)</code> 是被 <code>所有线程共享</code> 的一块内存区域，在<strong>虚拟机启动时创建</strong>。用于<strong>存放对象实例</strong>，几乎所有的<code>对象实例</code>以及<code>数组</code>都在堆上分配内存。<br>Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，也是<strong>垃圾收集器管理的主要区域</strong>。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><code>方法区(Method Area)</code> 是 <code>各个线程共享</code> 的内存区域。用于存储已经被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码</code>等数据。</p>
<blockquote>
<p>有别名叫Non-Heap(非堆)，也被称为“永久代”。</p>
</blockquote>
<h3 id="额外：HotSpot虚拟机对象"><a href="#额外：HotSpot虚拟机对象" class="headerlink" title="额外：HotSpot虚拟机对象"></a>额外：HotSpot虚拟机对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ul>
<li><strong>类加载检查</strong>：虚拟机遇到new指令，检查这个指令的参数能否定位到一个类的符号引用；并检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，则先执行相应的类加载过程。</li>
<li><strong>为对象分配内存</strong>：把一块确定大小的内存从Java堆中划分出来。由Java堆是否规整有两种划分方式， <code>“指针碰撞”</code> ：中间放置一个指针作为分界点的指示器，分配内存就是指针向空闲空间挪动； <code>“空闲列表”</code> ：维护内存块可用的列表，分配内存就是从列表找出一块足够大的空间。</li>
<li><strong>初始化零值</strong>：将分配到的内存空间都初始化为零值，不包含对象头。</li>
<li><strong>必要设置</strong>：将对象的对象头信息取出进行必要的设置。</li>
<li><strong><init></init></strong>：执行new指令后会执行<init>方法，把对象按照程序员的意愿进行初始化。</init></li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ul>
<li><strong>对象头</strong>：对象头包含两部分信息，<code>“Mark Word”</code>用于存储对象自身的运行时数据；<code>“类型指针”</code>用于存储对象指向它的类元数据的指针。</li>
<li><strong>实例数据</strong>：在程序代码中所定义的各种类型的字段内容。</li>
<li><strong>对齐填充</strong>：不是必然存在的，只是起着占位符的作用。</li>
</ul>
<h4 id="内存的访问定位"><a href="#内存的访问定位" class="headerlink" title="内存的访问定位"></a>内存的访问定位</h4><ul>
<li><strong>使用句柄</strong>：Java堆划分一块内存作为句柄池，reference存储<strong>句柄地址</strong>。句柄中包含 <code>对象实例数据</code> 和 <code>类型数据的具体地址</code>。</li>
<li><strong>直接地址访问</strong>：Java堆的对象考虑如何放置访问类型数据的相关信息。reference存储的是<strong>对象地址</strong>。</li>
</ul>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><h3 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h3><p>Java堆用于存储对象实例，不断创建对象，当避免垃圾回收机制，在对象数量达到最大堆的容量限制后就会产生内存溢出异常。</p>
<h3 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h3><ul>
<li>线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 <code>StackOverflowError</code> 异常。</li>
<li>虚拟机在扩展栈时无法申请到足够的内存空间，将抛出 <code>OutOfMemoryError</code> 异常。</li>
</ul>
<h3 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h3><p>方法区用于存放Class相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等，当运行时产生大量的类填满方法区时会产生内存溢出。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="对象是否可回收"><a href="#对象是否可回收" class="headerlink" title="对象是否可回收"></a>对象是否可回收</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p><code>引用计数算法</code> 是给对象添加一个<strong>引用计数器</strong>，当一个地方引用时，计数器值加1；当引用失效时，计数器值减1；当计数器值为0时说明对象不可用。</p>
<blockquote>
<p>不能解决对象之间相互循环引用的问题。</p>
</blockquote>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><code>可达性分析</code> 是选取 <strong>“GC Roots”</strong> 对象作为起始点，向下搜索走过的路径称为 <code>引用链</code> ；当一个对象到GC Roots没有任何引用链的时候则说明对象不可用。</p>
<blockquote>
<p>Java语言中可作为引用链的对象包括：虚拟机栈、方法区中类静态属性、方法区常量、本地方法栈Native方法引用的对象。</p>
</blockquote>
<h4 id="两次标记"><a href="#两次标记" class="headerlink" title="两次标记"></a>两次标记</h4><p>在可达性分析算法中不可达的对象还需要经历两次标记才真正回收。</p>
<ul>
<li><strong>是否有必要执行finalize()方法</strong>：当对象 <code>没有覆盖finalize()方法</code> 或者finalize()方法 <code>已经被虚拟机调用过</code> 则视为没有必要执行。</li>
<li><strong>重新引用</strong>：如果对象有必要执行finalize()方法，则会将对象放置在F-Queue队列中，由低优先级Finalizer线程执行，在此过程中只要 <code>重新与引用链上一个对象建立关联</code> 则会移除回收队列。</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><ul>
<li><strong>标记</strong>所有需要回收对象。</li>
<li><strong>回收</strong>所有被标记对象。</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>将内存按容量划分为两块，每次只使用其中一块。</p>
<ul>
<li><strong>标记</strong>回收对象。</li>
<li>将存活对象<strong>复制</strong>到另一块。</li>
<li>已使用内存空间全部<strong>回收</strong>。</li>
</ul>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><ul>
<li><strong>标记</strong>回收对象。</li>
<li>将存活对象向一端<strong>移动</strong>。</li>
<li><strong>回收</strong>边界以外内存。</li>
</ul>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期将Java堆划分为<strong>新生代</strong>和<strong>老年代</strong>，不同年代使用不同的垃圾回收算法。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="/2017/12/09/初识Java虚拟机/2.png" alt="初识Java虚拟机/2.png"></p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><code>Serial收集器</code> 是负责<strong>新生代</strong>的收集的<strong>单线程</strong>收集器。垃圾回收时会<code>暂停其他所有的工作线程</code>，直到收集结束。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><code>ParNew收集器</code> 是Serial收集器的<strong>多线程</strong>版本。除了Serial收集器，只有它能与CMS收集器配合工作。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p><code>Parallel Scavenge收集器</code> 也是使用<strong>复制算法</strong>的<strong>多线程</strong>收集器。目的是达到一个可控制的吞吐量， <code>吞吐量=运行用户代码时间 / （运行用户代码时间+垃圾回收时间）</code> ，也被称为 <code>“吞吐量优先”收集器</code>。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><code>Serial Old收集器</code> 是Serial收集器的<strong>老年代</strong>版本，使用<strong>标记-整理</strong>算法的<strong>单线程</strong>收集器。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><code>Parallel Old</code> 是Parallel Scavenge收集器的<strong>老年代</strong>版本，使用<strong>标记-整理</strong>算法的<strong>多线程</strong>收集器。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><code>CMS收集器</code> 是使用<strong>标记-清除</strong>算法的<strong>多线程</strong>收集器，目的是获取最短回收停顿时间。</p>
<ul>
<li>初始标记(CMS initial mark)</li>
<li>并发标记(CMS concurrent mark)</li>
<li>重新标记(CMS remark)</li>
<li>并发清除(CMS concurrent sweep)</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><code>G1收集器</code> 在后台维护一个优先列表，根据允许的收集时间，优先回收价值（回收所获得的空间大小以及所需时间）最大的Region。</p>
<ul>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking)</li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ul>
<h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><p>GC日志是一些人为确定的规则，每个日志格式有收集器决定。通常来看由以下几个部分组成： <code>GC发生时间</code> 、 <code>GC停顿类型</code> 、 <code>GC发生区域</code> 、 <code>GC前后内存使用情况</code> 、 <code>GC所占用时间</code>。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多情况下，对象在<strong>新生代Eden区域</strong>中分配。Eden空间不足时，虚拟机发起一次<strong>Minor GC</strong>。Minor GC过程：将Eden区域对象放入<strong>Survivor空间</strong>，若无法放入则通过分配担保机制提前进入到<strong>老年代</strong>。</p>
<blockquote>
<p>新生代GC(Minor GC)：Minor GC频繁，回收速度快。<br>老年代GC(Major GC/Full GC)：Full GC速度一般比Minor GC慢10倍。</p>
</blockquote>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在Minor GC前，虚拟机会先检查<strong>老年代连续空间</strong>是否大于<strong>新生代对象总大小</strong>。若成立，则Minor GC安全；若不成立，虚拟机会查看是否允许担保失败。<br><strong>担保</strong>：取每一次进入老年代对象的<strong>平均值</strong>与<strong>老年代剩余空间</strong>比较，若不足则进行Full GC。</p>
<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p><strong>大对象</strong>指需要 <code>大量连续内存空间</code> 的Java对象。当所需空间大于设置值时直接进入老年代分配，目的在于避免在Eden区及两个Survivor区之间发生大量的内存复制。</p>
<h3 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h3><p><strong>年龄计数器</strong>：对象在Survivor区每过一次Minor GC则年龄加1。当年龄大于设置值(默认为15)则进入老年代。<br><strong>对象年龄动态判断</strong>：如果在Survivor空间中， <code>相同年龄</code> 所有对象大小<strong>超过Survivor空间的一半</strong>，年龄大于或等于该年龄的对象进入老年代。</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>Class文件</strong>是一组以 <code>8个字节为单位</code> 的<strong>二进制流</strong>，对应着类或接口的定义信息，是实现 <code>平台无关性</code> 和 <code>语言无关性</code> 的基础。  </li>
<li><strong>Class文件格式</strong>采用 <code>伪结构</code> 存储数据，这种伪结构只有两种数据类型：<strong>无符号数</strong>(u1、u2、u4、u8代表x个字节的无符号数)，<strong>表</strong>(由多个无符号数或其他表构成，习惯以_info结尾)。</li>
</ul>
<h3 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h3><ul>
<li><strong>魔数</strong>：前 <code>4个字节</code> ，值为：0xCAFEBABE。</li>
<li><strong>Class版本号</strong>：紧接着魔数的 <code>4个字节</code> ，分别为：次版本号、主版本号。</li>
<li><strong>常量池</strong>：紧接着Class版本号，常量数量 <code>不固定</code> ，入口放置一项u2类型的 <code>常量池容量计数器</code> 。主要存放 <code>字面量</code> (Java中常量)和 <code>符号引用</code> (类、接口、字段、方法的名称和描述符)。</li>
<li><strong>访问标志</strong>：紧接着常量池的 <code>2个字节</code> ，用于标识一些类或接口层次的 <code>访问信息</code> 。</li>
<li><strong>类索引、父类索引、接口索引</strong>：排列着访问标志之后，类索引和父类索引用两个u2类型表示，接口索引是一组u2类型的集合；索引用于确定 <code>全限定名</code> 来确定这个类的 <code>继承关系</code> 。</li>
<li><strong>字段表集合</strong>：用于描述接口或者类中声明的 <code>变量信息</code> 。字段信息需要 <code>引用常量池</code> 中的常量来描述，无法固定大小。</li>
<li><strong>方法表集合</strong>：与字段表相似，用于 <code>描述方法</code> 定义的标志、名称索引、描述符索引。</li>
<li><strong>属性表集合</strong>：Class文件、字段表、方法表都可以携带自己的属性表集合，用于 <code>描述特定信息</code> 。预定义包含Code、Exception、LineNumberTable、LocalVariableTable等属性。</li>
</ul>
<blockquote>
<p><strong>全限定名</strong>：把<strong>类全名</strong>中的”.”替换成了”/“，如com/baidu/www/class/TestClass。<br><strong>简单名称</strong>：没有类型和参数修饰的<strong>方法或者字段名称</strong>，如inc()方法和m字段简称为inc和m。<br><strong>描述符</strong>：描述<strong>字段的数据类型</strong>、<strong>方法的参数类型</strong>、<strong>返回值</strong>。</p>
<ul>
<li><strong>基本类型</strong>和<strong>void</strong>用一个大写字符表示，I。</li>
<li><strong>对象类型</strong>用大写字符L加对象全限定名表示，Ljava/lang/String。</li>
<li><strong>数组类型</strong>的每一个维度使用一个前置的[字符描述，如[[Ljava/lang/String、[I。</li>
<li><strong>方法</strong>：先参数列表，后返回值，如()V、()Ljava/lang/String、([CII[CIII)I。</li>
</ul>
</blockquote>
<h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><blockquote>
<p>Java虚拟机的<strong>指令</strong>由<strong>操作码</strong>(一个字节长度的数字)和<strong>操作数</strong>(零至多个代表此操作所需的参数)构成。</p>
</blockquote>
<h4 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h4><p>由于Java虚拟机的<strong>操作码长度</strong>只有1个字节，指令集将会故意被设计为<strong>非完全独立</strong>，即并非每种数据类型和每一种操作都有对应的指令。<br>大部分的指令都没有支持<strong>boolean</strong>、<strong>byte</strong>、<strong>char</strong>、<strong>short</strong>类型的操作，实际上都是使用相应的<strong>int类型</strong>作为运算类型。</p>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p><code>加载和存储指令</code> 用于将数据在栈帧中的<strong>局部变量表</strong>和<strong>操作数栈</strong>之间来回<strong>传输</strong>。</p>
<ul>
<li><strong>将局部变量加载到操作数栈</strong>：iload等。</li>
<li><strong>将一个数值从操作数栈存储到局部变量表</strong>：istore等。</li>
<li><strong>将一个常量加载到操作数栈</strong>：bipush、sipush、iconst_m1等。</li>
<li><strong>扩充局部变量表的访问索引指令</strong>：wide。</li>
</ul>
<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p><code>运算或算数指令</code> 用于对两个操作数栈的值<strong>进行某种特定运算</strong>，并把结果重新存入到<strong>操作数栈顶</strong>。都使用Java虚拟机的数据类型，boolean、byte、char、short的运算都会转为int类型。<br><strong>算数指令</strong>有：<strong>加法</strong>(iadd、ladd、fadd、dadd)、<strong>减法</strong>(sub)、<strong>乘法</strong>(mul)、<strong>除法</strong>(div)、<strong>求余</strong>(rem)、<strong>取反</strong>(neg)、<strong>位移</strong>、<strong>按位或</strong>、<strong>按位与</strong>、<strong>按位异或</strong>、<strong>局部变量自增</strong>、<strong>比较</strong>。</p>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令用于将两种不同的数值<strong>类型进行相互转换</strong>。 <code>宽化</code> 类型转换无需显式的转换指令。 <code>窄化</code> 必须显示转换：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f。</p>
<h4 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h4><p>其他指令可以查看虚拟机字节码指令，这里不全部列出，主要有：<strong>对象创建与访问指令</strong>、<strong>操作数栈管理指令</strong>、<strong>控制转移指令</strong>、<strong>方法调用和返回指令</strong>、<strong>异常处理指令</strong>、<strong>同步指令</strong>。</p>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><p><strong>类加载机制</strong>指虚拟机把<strong>描述类的数据</strong>从<strong>Class文件</strong>加载到<strong>内存</strong>，并对数据进行校验、转换解析、初始化，最终形成可以被虚拟机直接使用的<strong>Java类型</strong>。</p>
<h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><ul>
<li>加载、连接（验证、准备、解析）、初始化、使用、卸载。</li>
</ul>
<h4 id="对类主动引用"><a href="#对类主动引用" class="headerlink" title="对类主动引用"></a>对类主动引用</h4><p>有且只有5中情况需要立即对类进行<strong>初始化</strong>：</p>
<ul>
<li>遇到<strong>new</strong>、<strong>getstatic</strong>、<strong>putstatic</strong>、<strong>invokestatic</strong>这4个字节码时，如果类没有过初始化，则需要先触发其初始化。Java代码场景： <code>new实例化对象</code> 、 <code>读取或设置一个类的静态字段</code> 、 <code>调用一个类的静态方法</code>。</li>
<li>使用 <code>java.lang.reflect包</code> 的方法对类进行<strong>反射调用</strong>时，该类没有过初始化需要触发初始化。</li>
<li>当<strong>初始化一个类</strong>，其<strong>父类</strong>没有过初始化需要先初始化父类。</li>
<li><strong>虚拟机启动</strong>时，需要先初始化含main()方法的<strong>主类</strong>。</li>
<li>java.lang.invoke.MethodHandle实例<strong>解析句柄对应的类</strong>需要初始化。</li>
</ul>
<h4 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h4><p>所有被动引用类都不会触发初始化。</p>
<ul>
<li>通过<strong>子类引用父类的静态字段</strong>，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>通过<strong>数组定义来引用类</strong>，不会触发此类的初始化。</li>
<li><strong>调用类的常量</strong>，由于常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用类，不会触发该类的初始化。</li>
</ul>
<blockquote>
<p>接口不要求其父接口都完成了初始化，只有在真正使用父接口的时候(引用接口的常量)才会初始化。</p>
</blockquote>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>Java虚拟机中类加载全过程：加载、验证、准备、解析、初始化。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li>通过一个<strong>类的全限定名</strong>来获取定义此<strong>类的二进制流</strong>。</li>
<li>将这个字节流按照虚拟机所需的格式<strong>存储在方法区中</strong>。</li>
<li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>(HotSpot虚拟机存放在方法区中)，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保Class文件的字节流中包含的信息符合虚拟机的要求。</p>
<ul>
<li><strong>文件格式验证</strong>：对<strong>Class文件格式</strong>中魔数、版本号、常量池等进行验证，保证字节流能正常<strong>解析并存储</strong>到方法区。</li>
<li><strong>元数据验证</strong>：对<strong>字节码描述的信息</strong>该类是否有父类、是否继承final类等进行语义分析，保证符合Java语言规范。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定<strong>程序语义</strong>是符合逻辑的。</li>
<li><strong>符号引用验证</strong>：对类自身以外(<strong>常量池中的各种符号引用</strong>)的信息进行匹配性验证。</li>
</ul>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>为<strong>类变量</strong>(static修饰)<strong>分配内存</strong>并<strong>设置初值</strong>(数据类型的零值)。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>虚拟机将常量池内的符号引用替换为直接引用。</p>
<blockquote>
<ul>
<li>符号引用：以一组符号来描述所引用的目标，引用目标并不一定已经加载到内存中。</li>
<li>直接引用：直接引用是直接指向目标的指针、偏移量或者是一个能够间接定位到目标的句柄。</li>
</ul>
</blockquote>
<p>解析动作主要针对<strong>类或接口</strong>、<strong>字段</strong>、<strong>类方法</strong>、<strong>接口方法</strong>、<strong>方法类型</strong>、<strong>方法句柄</strong>、<strong>调用点限定符</strong>这几类符号引用进行。</p>
<h5 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h5><p>假设当前代码所处的 <code>类为D</code> ，要把一个从未解析过的 <code>符号引用N</code> 解析为一个 <code>类或接口C</code> 的直接引用：</p>
<ul>
<li>如果<strong>C不是一个数组类型</strong>，虚拟机会把代表<strong>N的全限定名</strong>传递给<strong>D的类加载器</strong>去加载这个类C；可能会触发其他相关类的加载，如父类或实现的接口。</li>
<li>如果<strong>C是一个数组类型</strong>，数组的元素类型为<strong>对象</strong>按照上一点规则加载；数组的元素类型为<strong>基本类型</strong>则由虚拟机生成一个代表此数组维度和元素的数组对象。</li>
<li>如果以上步骤没有异常，则C在虚拟机中已经成为一个有效的类或接口。</li>
</ul>
<h5 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h5><ul>
<li>解析字段<strong>所属的类或接口</strong>的符号引用。</li>
<li>与<strong>类中</strong>匹配目标的<strong>简单名称</strong>和<strong>字段描述符</strong>。</li>
<li>按照继承关系从下往上递归搜索<strong>接口和父接口</strong>。</li>
<li>如果不是java.lang.Object，搜索其<strong>父类</strong>。</li>
<li>否则，查找失败。</li>
</ul>
<h5 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h5><ul>
<li>解析方法<strong>所属的类或接口</strong>的符号引用。</li>
<li>在<strong>类中</strong>查找简单名称和描述符。</li>
<li>在<strong>类的父类</strong>中查找简单名称和描述符。</li>
<li>在<strong>类实现的接口列表和父接口</strong>中匹配。</li>
<li>否则，查找失败。</li>
</ul>
<h5 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h5><ul>
<li>解析方法<strong>所属的类或接口</strong>的符号引用。</li>
<li>在<strong>接口中</strong>查找简单名称和描述符。</li>
<li>在<strong>父接口</strong>中查找简单名称和描述符。</li>
<li>否则，查找失败。</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>开始执行类中定义的Java程序代码(字节码)。初始化阶段<strong>执行类构造器</strong> <code>&lt;clinit&gt;()方法</code> 的过程。</p>
<ul>
<li><code>&lt;clinit&gt;()方法</code> 是由编译器自动收集类中的<strong>类变量赋值</strong>和<strong>静态语句块</strong>。静态语句块中只能访问到定义在静态语句块之前变量， <code>之后的变量只能赋值不能访问</code>。</li>
<li><code>&lt;clinit&gt;()方法</code> 实例构造器 <code>&lt;init&gt;()方法</code> 不同，<strong>不需要显式调用父类构造器</strong>，<strong>保证父类 <code>&lt;clinit&gt;()方法</code> 在子类 <code>&lt;clinit&gt;()方法</code> 前执行</strong>。</li>
<li>由于父类先执行 <code>&lt;clinit&gt;()方法</code> ，父类定义的<strong>静态语句块</strong>先于子类，第一个被执行 <code>&lt;clinit&gt;()方法</code> 的类是<strong>java.lang.Object</strong>。</li>
<li><code>&lt;clinit&gt;()方法</code> 对呀类或接口<strong>不是必需</strong>的。</li>
<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()方法</code> 在多线程环境中正确被<strong>加锁、同步</strong>。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>类加载器</strong>是实现让<strong>应用程序</strong>自己决定如何去<strong>获取所需要的类</strong>的代码模块。</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一起确立其在Java虚拟机中的唯一性。</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><ul>
<li><strong>启动类加载器(Bootstrap ClassLoader)</strong>：负责将存放在<strong><java_home\lib></java_home\lib></strong>目录下的类库加载到虚拟机内存中。</li>
<li><strong>扩展类加载器(Extension ClassLoader)</strong>：负责加载<strong><java_home\lib\ext></java_home\lib\ext></strong>目录中的类库。</li>
<li><strong>应用程序类加载器(Application ClassLoader)</strong>：负责加载<strong>用户类路径(ClassPath)</strong>指定的类库。</li>
</ul>
<p>双亲委派模型的工作流程：如果一个类加载器<strong>收到类加载的请求</strong>，首先将这个请求委派给<strong>父类加载器</strong>去完成，最终传送到<strong>顶层的启动类加载器</strong>；当父加载器反馈无法完成这个加载请求，<strong>子加载器</strong>才会尝试加载。</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><ul>
<li>第一次：JDK 1.2发布前，重写loadClass()方法。</li>
<li>第二次：模型自身缺陷，线程上下文类加载器可以实现父类加载器请求子类加载器去完成类加载动作。</li>
<li>第三次：对程序动态性的追求。</li>
</ul>
<h2 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p><code>栈帧(Stack Frame)</code> 是用于支持虚拟机进行方法调用和方法执行的数据结构，存储了<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态连接</strong>、<strong>方法返回地址</strong>等信息。每一个<strong>方法</strong>从调用开始到执行完成对应栈帧在虚拟机从<strong>入栈到出栈</strong>的过程。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p><code>局部变量表(Local Variable Table)</code> 是一组变量值存储空间，用于存放<strong>方法参数</strong>和方法内部定义的<strong>局部变量</strong>。<br>局部变量表的容量以变量槽(Variable Slot)为最小单位，每个<strong>Slot</strong>都能存放一个 <code>boolean</code> 、 <code>byte</code> 、 <code>char</code> 、 <code>short</code> 、 <code>int</code> 、 <code>float</code> 、 <code>reference</code> 、 <code>returnAddress</code> 类型的数据。<br><strong>reference类型</strong>表示对一个<strong>对象的引用</strong>，通过引用要做到两点：从此引用中直接或间接地查找到到对象在 <code>Java堆</code> 中的数据存放的起始 <code>地址索引</code> ；此引用中直接或间接查找到对象所属数据类型在 <code>方法区</code> 中的存储的 <code>类型</code> 信息。<br>虚拟机通过<strong>索引定位</strong>的方式使用局部变量表。如果执行的<strong>实例方法</strong>(非static)，局部变量表的第0位索引的Slot默认是用于传递方法<strong>所属对象实例的引用</strong>，在方法中可以通过<strong>关键字this</strong>访问该隐含参数。其他参数按照参数表顺序排序，局部变量表的Slot可以重用。<br>如果一个局部变量 <code>定义</code> 了但没有 <code>赋初始值</code> 会导致类加载失败。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p><code>操作数栈(Operand Stack)</code> 是一个 <code>后入先出(Last In First Out)</code> 栈，每一个元素可以是任意的Java数据类型。<br>在方法执行过程，各种字节码指令往操作数栈中写入和提取内容，也就是<strong>入栈/出栈</strong>操作。</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。在每一次<strong>运行时期</strong>将<strong>符号引用</strong>转化为<strong>直接引用</strong>称为动态连接。</p>
<h4 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h4><p>方法在退出后，都需要返回到<strong>方法被调用的位置</strong>，栈帧保存返回地址信息。</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用的目的是确定被调用方法的版本，即<strong>调用哪一个方法</strong>。</p>
<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><p>所有的方法调用中的目标方法在Class文件中都是一个<strong>常量池中的符号引用</strong>。在类加载的解析阶段，将会把一部分<strong>符号引用转化为直接引用</strong>，解析前提是 <strong>“编译期可知，运行期不可变”</strong> 。</p>
<ul>
<li>对应的调用字节码指令：invokestatic、invokespecial、invokevirtual、invokeinterface、invokedynamic。</li>
<li>符合条件：<strong>静态方法</strong>、<strong>私有方法</strong>、<strong>实例构造器</strong>、<strong>父类方法</strong>、<strong>final修饰方法</strong>。</li>
</ul>
<h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><h5 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h5><p>所有<strong>依赖静态类型</strong>来定位方法执行版本的分派动作称为静态分派。(<strong>方法重载</strong>)</p>
<blockquote>
<ul>
<li>静态类型在编译期可知。</li>
<li>实际类型变化的结果在运行期确定。</li>
</ul>
</blockquote>
<h6 id="重载方法匹配优先级"><a href="#重载方法匹配优先级" class="headerlink" title="重载方法匹配优先级"></a>重载方法匹配优先级</h6><p>以’a’为例：</p>
<ul>
<li>char-&gt;int-&gt;long-&gt;float-&gt;double</li>
<li>java.lang.Character</li>
<li>java.lang.Serializable、java.lang.Comparable<character></character></li>
<li>装箱转型为父类</li>
<li>变长参数</li>
</ul>
<h5 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h5><p>运行期根据<strong>实际类型</strong>确定方法执行版本的分派过程称为动态分派。(<strong>方法重写</strong>)</p>
<h5 id="单分配与多分配"><a href="#单分配与多分配" class="headerlink" title="单分配与多分配"></a>单分配与多分配</h5><p><strong>方法宗量：方法接受者+方法参数</strong>。根据分派基于多少种宗量划分为单分配和多分配。</p>
<ul>
<li>静态分派：选择目标方法。(静态类型+方法参数)</li>
<li>动态分派：方法接受者的实际类型。</li>
</ul>
<blockquote>
<p>Java是静态多分配、动态单分配的语言。</p>
</blockquote>
<h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="/2017/12/09/初识Java虚拟机/3.png" alt="初识Java虚拟机/3.png"></p>
<h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p><strong>Java内存模型</strong>的目的是定义程序中各个变量的访问规则，即在虚拟机中将<strong>变量存储到内存</strong>和从<strong>内存中取出变量</strong>的底层细节。</p>
<blockquote>
<p>这里的<strong>变量</strong>与Java编程中所说的变量不同，它包括<strong>实例字段</strong>、<strong>静态字段</strong>、<strong>构成数组对象的元素</strong>，不包括局部变量和方法参数。</p>
</blockquote>
<h5 id="Java内存模型规定"><a href="#Java内存模型规定" class="headerlink" title="Java内存模型规定"></a>Java内存模型规定</h5><ul>
<li>所有变量都<strong>存储在主内存</strong>。</li>
<li>每天线程有自己的<strong>工作内存</strong>。</li>
<li><strong>工作内存</strong>保存主内存的<strong>副本拷贝</strong>。</li>
<li>线程对变量的所有<strong>操作</strong>（读取、赋值等）都在<strong>工作内存</strong>中进行。</li>
</ul>
<blockquote>
<p><strong>主内存</strong>对应于<strong>Java堆</strong>中的对象实例数据部分。<br><strong>工作内存</strong>对应<strong>虚拟机栈</strong>中的部分区域。</p>
</blockquote>
<h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><ul>
<li><strong>lock</strong>：把一个变量标识为一条线程独占状态。</li>
<li><strong>unlock</strong>：释放锁定变量。</li>
<li><strong>read</strong>：把变量从主内存读取到工作线程。</li>
<li><strong>load</strong>：把read操作读取的变量值放入工作内存变量副本中。</li>
<li><strong>use</strong>：把工作内存的变量值传递给执行引擎。</li>
<li><strong>assign</strong>：从执行引擎接收变量值到工作线程。</li>
<li><strong>store</strong>：把工作线程的变量值传到主内存中。</li>
<li><strong>write</strong>：把store操作得到的变量值放入主内存的变量中。</li>
</ul>
<h4 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h4><ul>
<li><strong>原子性</strong>：线程从运行开始会一直到运行结束，不会被方法调度打断或进行线程切换。</li>
<li><strong>可见性</strong>：当一个线程修改了共享变量的值，其他线程能够立即得到这个修改。</li>
<li><strong>有序性</strong>：禁止指令重排序，在本线程中表现为串行，整体表现为指令重排序。</li>
</ul>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><ul>
<li>保证了<strong>可见性</strong>和<strong>有序性</strong>。  </li>
<li>Java运算并非原子操作，导致volatile变量的运算在并发下不安全。</li>
<li>需要确保运算结果并不依赖变量的当前值来<strong>保证原子性</strong>。</li>
</ul>
<blockquote>
<p><strong>synchronized同步块</strong>同时保证了原子性、可见性、有序性。</p>
</blockquote>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系。如果操作A先行于操作B，则操作A产生的影响能够被操作B观察到。  </p>
<h5 id="Java内存模型预定义的先行发生关系"><a href="#Java内存模型预定义的先行发生关系" class="headerlink" title="Java内存模型预定义的先行发生关系"></a>Java内存模型预定义的先行发生关系</h5><ul>
<li><strong>程序次序规则</strong>：一个线程中，按照程序代码顺序。</li>
<li><strong>管程锁定规则</strong>：unlock操作先行于同一个锁的lock操作。</li>
<li><strong>volatile变量规则</strong>：volatile变量的写操作先行于后面的读操作。</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法优先。</li>
<li><strong>线程终止规则</strong>：Thread.join()方法结束最后。</li>
<li><strong>线程中断规则</strong>：interrupt()方法先行于中断事件。</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行于finalize()方法。</li>
<li><strong>传递性</strong>：A先行于B，B先行于C，则A先行于C。</li>
</ul>
<blockquote>
<p>时间先后顺序与先行发生规则基本没有关系。</p>
</blockquote>
<h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>各个<strong>线程</strong>既可以<strong>共享进程资源</strong>，又可以<strong>独立调度</strong>。</p>
<h5 id="实现线程的方式"><a href="#实现线程的方式" class="headerlink" title="实现线程的方式"></a>实现线程的方式</h5><ul>
<li>使用内核线程实现：直接由操作系统内核支持的线程，用内核线程支持 <strong>轻量级进程(LWP)</strong> 实现。</li>
<li>使用用户线程实现：<strong>用户线程(UT)</strong> 完全建立在用户空间的线程库，不需要切换到内核态。</li>
<li>混合实现：既存在<strong>用户线程</strong>，也存在<strong>轻量级进程</strong>。</li>
</ul>
<h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><p><strong>线程调度</strong>指系统为线程<strong>分配处理器的使用权</strong>。</p>
<ul>
<li><strong>协同式调度</strong>：线程的执行时间由<strong>自己控制</strong>，线程自身执行完后<strong>主动通知</strong>系统切换到另一个线程。</li>
<li>抢占式调度：每个线程由<strong>系统分配</strong>执行时间，可以设置<strong>线程优先级</strong>。</li>
</ul>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><ul>
<li><strong>新建(New)</strong>：创建后尚未启动的线程。</li>
<li><strong>运行(Runable)</strong>：包括Running和Ready。</li>
<li><strong>无限期等待(Wating)</strong>：等待其他线程显式唤醒。</li>
<li><strong>限期等待(Timed Wating)</strong>：一定时间后由系统自动唤醒。</li>
<li><strong>阻塞(Blocked)</strong>：等待获取一个排它锁，在另一个线程放弃这个锁时发生。</li>
<li><strong>结束(Terminated)</strong>：已终止线程。</li>
</ul>
<h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全指当<strong>多个线程访问一个对象</strong>时，调用这个对象的行为都可以<strong>像单线程</strong>一样得到正确的结果。</p>
<h4 id="共享数据类型"><a href="#共享数据类型" class="headerlink" title="共享数据类型"></a>共享数据类型</h4><ul>
<li><strong>不可变</strong>：不可变的对象一定是线程安全的，如String。</li>
<li><strong>绝对线程安全</strong>：在多线程环境中需要在方法调用端做额外的同步措施。</li>
<li><strong>相对线程安全</strong>：需要保证这个对象单独的操作是线程安全的，如：Vector、HashTable等。</li>
<li><strong>线程兼容</strong>：对象本身并不是线程安全的，可以通过在调用端正确使用同步手段保证线程安全，如ArrayList、HashMap等。</li>
<li><strong>线程对立</strong>：无论调用端是否采用同步措施，都无法在多线程环境中并发使用。</li>
</ul>
<h4 id="线程安全的实现"><a href="#线程安全的实现" class="headerlink" title="线程安全的实现"></a>线程安全的实现</h4><ul>
<li><strong>互斥同步</strong>：synchronized或java.util.concurrent包中ReentrantLock实现。</li>
<li><strong>非阻塞同步</strong>：先进行操作，产生了冲突再采取补偿措施，也称为“乐观锁”。</li>
<li><strong>无同步方案</strong>：可重入代码、线程本地存储。</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li><strong>自旋锁</strong>：不放弃处理器的执行时间，让线程执行一个忙循环（自旋）。</li>
<li><strong>锁消除</strong>：对一些代码要求同步却被检测到不可能存在共享数据竞争的锁进行消除。</li>
<li><strong>锁粗化</strong>：如果一系列的连续操作都对同一个对象反复加锁和解锁，则将加锁同步范围扩展到整个操作序列的外部。</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（六）-Realm及相关对象]]></title>
      <url>/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%85%AD%EF%BC%89-Realm%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><h2 id="定义实体及关系"><a href="#定义实体及关系" class="headerlink" title="定义实体及关系"></a>定义实体及关系</h2><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-1.png" alt="跟我学Shiro（六）-Realm及相关对象/6-1.png"><br><strong>用户-角色</strong>之间是多对多关系，<strong>角色-权限</strong>之间是多对多关系；且<code>用户</code>和<code>权限</code>之间通过<code>角色</code>建立关系。<br>在系统中验证时通过<code>权限验证</code>，角色只是权限集合，即所谓的显式角色。</p>
<ul>
<li><strong>用户</strong>实体包括：编号<code>id</code>、用户名<code>username</code>、密码<code>password</code>、盐<code>salt</code>、是否锁定<code>locked</code>；</li>
<li><strong>角色</strong>实体包括：、编号<code>id</code>、角色标识符<code>role</code>、描述<code>description</code>、是否可用<code>available</code>；</li>
<li><strong>权限</strong>实体包括：编号<code>id</code>、权限标识符<code>permission</code>、描述<code>description</code>、是否可用<code>available</code>。</li>
</ul>
<blockquote>
<p>另外还有两个<strong>关系实体</strong>：<br><strong>用户-角色</strong>实体：用户编号、角色编号，且组合为复合主键）；<br><strong>角色-权限</strong>实体：角色编号、权限编号，且组合为复合主键）。</p>
</blockquote>
<a id="more"></a>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>为了方便数据库操作，使用 <code>org.springframework: spring-jdbc: 4.0.0.RELEASE</code> 依赖。</p>
<h3 id="定义Service及Dao"><a href="#定义Service及Dao" class="headerlink" title="定义Service及Dao"></a>定义Service及Dao</h3><blockquote>
<p>为了实现的简单性，只实现必须的功能，其他的可以自己实现即可。</p>
</blockquote>
<h4 id="PermissionService"><a href="#PermissionService" class="headerlink" title="PermissionService"></a>PermissionService</h4><p>实现基本的<strong>创建/删除</strong>权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface PermissionService &#123;  </div><div class="line">    public Permission createPermission(Permission permission);  </div><div class="line">    public void deletePermission(Long permissionId);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="RoleService"><a href="#RoleService" class="headerlink" title="RoleService"></a>RoleService</h4><p>相对于PermissionService多了<strong>关联/移除关联角色-权限</strong>功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface RoleService &#123;  </div><div class="line">    public Role createRole(Role role);  </div><div class="line">    public void deleteRole(Long roleId);  </div><div class="line">    // 添加角色-权限之间关系  </div><div class="line">    public void correlationPermissions(Long roleId, Long... permissionIds);  </div><div class="line">    // 移除角色-权限之间关系  </div><div class="line">    public void uncorrelationPermissions(Long roleId, Long... permissionIds);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h4><p>使用 <strong>findByUsername</strong> 、 <strong>findRoles</strong> 及 <strong>findPermissions</strong> 来查找用户名对应的帐号、角色及权限信息。  </p>
<blockquote>
<p>之后的Realm就使用这些方法来查找相关信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface UserService &#123;  </div><div class="line">    // 创建账户</div><div class="line">    public User createUser(User user);   </div><div class="line">    // 修改密码</div><div class="line">    public void changePassword(Long userId, String newPassword);  </div><div class="line">    // 添加用户-角色关系</div><div class="line">    public void correlationRoles(Long userId, Long... roleIds);   </div><div class="line">    // 移除用户-角色关系</div><div class="line">    public void uncorrelationRoles(Long userId, Long... roleIds);  </div><div class="line">    // 根据用户名查找用户</div><div class="line">    public User findByUsername(String username);  </div><div class="line">    // 根据用户名查找其角色</div><div class="line">    public Set&lt;String&gt; findRoles(String username); </div><div class="line">    // 根据用户名查找其权限  </div><div class="line">    public Set&lt;String&gt; findPermissions(String username); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UserServiceImpl"><a href="#UserServiceImpl" class="headerlink" title="UserServiceImpl"></a>UserServiceImpl</h4><p>在创建账户及修改密码时直接把<strong>生成密码操作</strong>委托给 <code>PasswordHelper</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public User createUser(User user) &#123;  </div><div class="line">    // 加密密码  </div><div class="line">    passwordUtils.encryptPassword(user);  </div><div class="line">    return userDao.createUser(user);  </div><div class="line">&#125;  </div><div class="line">public void changePassword(Long userId, String newPassword) &#123;  </div><div class="line">    User user =userDao.findOne(userId);  </div><div class="line">    user.setPassword(newPassword);  </div><div class="line">    passwordUtils.encryptPassword(user);  </div><div class="line">    userDao.updateUser(user);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="PasswordUtils"><a href="#PasswordUtils" class="headerlink" title="PasswordUtils"></a>PasswordUtils</h4><p>之后的CredentialsMatcher需要和此处加密的算法一样。<br>user.getCredentialsSalt()辅助方法返回username+salt。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class PasswordUtils &#123;  </div><div class="line">    private RandomNumberGenerator randomNumberGenerator =  </div><div class="line">     new SecureRandomNumberGenerator();  </div><div class="line">    private String algorithmName = &quot;md5&quot;;  </div><div class="line">    private final int hashIterations = 2;  </div><div class="line">    public void encryptPassword(User user) &#123;  </div><div class="line">        user.setSalt(randomNumberGenerator.nextBytes().toHex());  </div><div class="line">        String newPassword = new SimpleHash(  </div><div class="line">                algorithmName,  </div><div class="line">                user.getPassword(),  </div><div class="line">                ByteSource.Util.bytes(user.getCredentialsSalt()),  </div><div class="line">                hashIterations).toHex();  </div><div class="line">        user.setPassword(newPassword);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>为了节省篇幅，对于<strong>DAO/Service</strong>的接口及实现，具体请参考源码 <code>com.github.gojay001</code> ；<br>另外参考Service层的测试用例 <code>com.github.gojay001.service.ServiceTest</code> 。</p>
</blockquote>
<h3 id="定义Realm"><a href="#定义Realm" class="headerlink" title="定义Realm"></a>定义Realm</h3><h4 id="RetryLimitHashedCredentialsMatcher"><a href="#RetryLimitHashedCredentialsMatcher" class="headerlink" title="RetryLimitHashedCredentialsMatcher"></a>RetryLimitHashedCredentialsMatcher</h4><blockquote>
<p>com.github.gojay001.credentials</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class RetryLimitHashedCredentialsMatcher extends HashedCredentialsMatcher &#123;</div><div class="line"></div><div class="line">    private Ehcache passwordRetryCache;</div><div class="line"></div><div class="line">    public RetryLimitHashedCredentialsMatcher() &#123;</div><div class="line">        CacheManager cacheManager = CacheManager.newInstance(CacheManager.class.getClassLoader().getResource(&quot;ehcache.xml&quot;));</div><div class="line">        passwordRetryCache = cacheManager.getCache(&quot;passwordRetryCache&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;</div><div class="line">        String username = (String)token.getPrincipal();</div><div class="line">        // retry count + 1</div><div class="line">        Element element = passwordRetryCache.get(username);</div><div class="line">        if(element == null) &#123;</div><div class="line">            element = new Element(username , new AtomicInteger(0));</div><div class="line">            passwordRetryCache.put(element);</div><div class="line">        &#125;</div><div class="line">        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();</div><div class="line">        if(retryCount.incrementAndGet() &gt; 5) &#123;</div><div class="line">            // if retry count &gt; 5 throw</div><div class="line">            throw new ExcessiveAttemptsException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        boolean matches = super.doCredentialsMatch(token, info);</div><div class="line">        if(matches) &#123;</div><div class="line">            // clear retry count</div><div class="line">            passwordRetryCache.remove(username);</div><div class="line">        &#125;</div><div class="line">        return matches;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="UserRealm"><a href="#UserRealm" class="headerlink" title="UserRealm"></a>UserRealm</h4><blockquote>
<p>com.github.gojay001.realm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class UserRealm extends AuthorizingRealm &#123;</div><div class="line">    private UserService userService = new UserServiceImpl();</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) &#123;</div><div class="line">        String username = (String)principals.getPrimaryPrincipal();</div><div class="line"></div><div class="line">        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();</div><div class="line">        authorizationInfo.setRoles(userService.findRoles(username));</div><div class="line">        authorizationInfo.setStringPermissions(userService.findPermissions(username));</div><div class="line"></div><div class="line">        return authorizationInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line"></div><div class="line">        String username = (String)token.getPrincipal();</div><div class="line"></div><div class="line">        User user = userService.findByUsername(username);</div><div class="line"></div><div class="line">        //没找到帐号</div><div class="line">        if(user == null) &#123;</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //帐号锁定</div><div class="line">        if(Boolean.TRUE.equals(user.getLocked())) &#123;</div><div class="line">            throw new LockedAccountException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现</div><div class="line">        return new SimpleAuthenticationInfo(</div><div class="line">                user.getUsername(),</div><div class="line">                user.getPassword(),</div><div class="line">                // salt=username+salt</div><div class="line">                ByteSource.Util.bytes(user.getCredentialsSalt()),</div><div class="line">                //realm name</div><div class="line">                getName()</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>UserRealm父类AuthorizingRealm将获取Subject相关信息分成两步</strong>：获取身份验证信息 <code>doGetAuthenticationInfo</code> 及授权信息 <code>doGetAuthorizationInfo</code> ；</li>
<li><strong>doGetAuthenticationInfo</strong>：首先根据传入的用户名获取User信息；在组装SimpleAuthenticationInfo信息时，需要传入：身份信息<code>用户名</code>、凭据<code>密文密码</code>、盐<code>username+salt</code>， <em>CredentialsMatcher</em> 使用盐加密传入的明文密码和此处的密文密码进行匹配。</li>
<li><strong>doGetAuthorizationInfo</strong>：<code>PrincipalCollection</code> 是一个身份集合，因为我们现在就一个Realm，所以直接调用getPrimaryPrincipal得到之前传入的<code>用户名</code>即可；然后根据用户名<code>调用UserService接口</code>获取角色及权限信息。</li>
</ul>
<h1 id="AuthenticationToken"><a href="#AuthenticationToken" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-2.png" alt="跟我学Shiro（六）-Realm及相关对象/6-2.png"><br><strong>AuthenticationToken</strong>用于收集用户提交的身份 <code>用户名</code> 及凭据 <code>密码</code> ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface AuthenticationToken extends Serializable &#123;  </div><div class="line">    Object getPrincipal(); </div><div class="line">    Object getCredentials(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>RememberMeAuthenticationToken</strong>：提供了 <code>boolean isRememberMe()</code> <strong>记住我</strong>的功能；</li>
<li><strong>HostAuthenticationToken</strong>：提供了 <code>String getHost()</code> 方法用于获取用户<strong>主机</strong>的功能。</li>
</ul>
<blockquote>
<p>Shiro提供了一个直接拿来用的<strong>UsernamePasswordToken</strong>，用于实现用户名/密码Token组。实现了 <code>RememberMeAuthenticationToken</code> 和 <code>HostAuthenticationToken</code> ，可以实现记住我及主机验证的支持。</p>
</blockquote>
<h1 id="AuthenticationInfo"><a href="#AuthenticationInfo" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-3.png" alt="跟我学Shiro（六）-Realm及相关对象/6-3.png"><br><strong>AuthenticationInfo</strong>有两个作用：</p>
<ul>
<li>如果Realm是 <code>AuthenticatingRealm</code> 子类，则提供给 <code>AuthenticatingRealm</code> 内部使用的 <code>CredentialsMatcher</code> 进行凭据验证；（如果没有继承它需要在自己的Realm中自己实现验证）。</li>
<li>提供给 <code>SecurityManager</code> 来创建 <code>Subject</code> （提供身份信息）。</li>
</ul>
<blockquote>
<p><strong>MergableAuthenticationInfo</strong>用于提供在多Realm时<code>合并AuthenticationInfo的功能</code>，主要合并Principal。<br>比如 <code>HashedCredentialsMatcher</code> ，在验证时会判断 <code>AuthenticationInfo</code> 是否是<strong>SaltedAuthenticationInfo</strong>子类，来获取盐信息。<br><strong>Account</strong>相当于我们之前的 <code>User</code> ， <code>SimpleAccount</code> 是其一个实现。<br>其他情况一般返回<strong>SimpleAuthenticationInfo</strong>即可。</p>
</blockquote>
<h1 id="PrincipalCollection"><a href="#PrincipalCollection" class="headerlink" title="PrincipalCollection"></a>PrincipalCollection</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-4.png" alt="跟我学Shiro（六）-Realm及相关对象/6-4.png"><br>因为我们可以在Shiro中同时配置多个Realm，所以身份信息可能就有多个；因此其提供了<strong>PrincipalCollection</strong>用于<code>聚合这些身份信息</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public interface PrincipalCollection extends Iterable, Serializable &#123;  </div><div class="line">    // 得到主要的身份</div><div class="line">    Object getPrimaryPrincipal();   </div><div class="line">    // 根据身份类型获取第一个</div><div class="line">    &lt;T&gt; T oneByType(Class&lt;T&gt; type);   </div><div class="line">    // 根据身份类型获取一组</div><div class="line">    &lt;T&gt; Collection&lt;T&gt; byType(Class&lt;T&gt; type);   </div><div class="line">    // 转换为List</div><div class="line">    List asList();   </div><div class="line">    // 转换为Set</div><div class="line">    Set asSet();</div><div class="line">    // 根据Realm名字获取</div><div class="line">    Collection fromRealm(String realmName);   </div><div class="line">    // 获取所有身份验证通过的Realm名字</div><div class="line">    Set&lt;String&gt; getRealmNames();   </div><div class="line">    // 判断是否为空</div><div class="line">    boolean isEmpty();  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>getPrimaryPrincipal</strong>：如果只有一个Principal那么直接返回即可，如果有多个Principal，则返回第一个（因为内部使用Map存储，所以可以认为是返回任意一个）；<br><strong>oneByType/byType</strong>：根据<code>凭据的类型</code>返回相应的Principal；<br><strong>fromRealm</strong>根据<code>Realm名字</code>（每个Principal都与一个Realm关联）获取相应的Principal。</p>
</blockquote>
<p><strong>MutablePrincipalCollection</strong>是一个可变的PrincipalCollection接口，即提供了如下可变方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public interface MutablePrincipalCollection extends PrincipalCollection &#123;  </div><div class="line">    // 添加Realm-Principal的关联</div><div class="line">    void add(Object principal, String realmName);   </div><div class="line">    // 添加一组Realm-Principal的关联</div><div class="line">    void addAll(Collection principals, String realmName);</div><div class="line">    // 添加PrincipalCollection</div><div class="line">    void addAll(PrincipalCollection principals);</div><div class="line">    // 清空</div><div class="line">    void clear();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="AuthorizationInfo"><a href="#AuthorizationInfo" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-5.png" alt="跟我学Shiro（六）-Realm及相关对象/6-5.png"><br><strong>AuthorizationInfo</strong>用于<code>聚合授权信息</code>的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public interface AuthorizationInfo extends Serializable &#123;  </div><div class="line">    // 获取角色字符串信息</div><div class="line">    Collection&lt;String&gt; getRoles();</div><div class="line">    // 获取权限字符串信息</div><div class="line">    Collection&lt;String&gt; getStringPermissions(); </div><div class="line">    // 获取Permission对象信息</div><div class="line">    Collection&lt;Permission&gt; getObjectPermissions(); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当我们使用 <code>AuthorizingRealm</code> 时，如果身份验证成功，在进行授权时就通过 <code>doGetAuthorizationInfo</code> 方法获取角色/权限信息用于授权验证。  </p>
<blockquote>
<p>Shiro提供了一个实现 <strong>SimpleAuthorizationInfo</strong> ，大多数时候使用这个即可。</p>
</blockquote>
<h1 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h1><p><img src="/2017/11/29/跟我学Shiro（六）-Realm及相关对象/6-6.png" alt="跟我学Shiro（六）-Realm及相关对象/6-6.png"><br><strong>Subject</strong>是Shiro的核心对象，基本所有<code>身份验证</code>、<code>授权</code>都是通过Subject完成。</p>
<h2 id="身份信息获取"><a href="#身份信息获取" class="headerlink" title="身份信息获取"></a>身份信息获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// Primary Principal</div><div class="line">Object getPrincipal(); </div><div class="line">// PrincipalCollection</div><div class="line">PrincipalCollection getPrincipals();</div></pre></td></tr></table></figure>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void login(AuthenticationToken token) throws AuthenticationException;  </div><div class="line">boolean isAuthenticated();  </div><div class="line">boolean isRemembered();</div></pre></td></tr></table></figure>
<h2 id="角色授权验证"><a href="#角色授权验证" class="headerlink" title="角色授权验证"></a>角色授权验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">boolean hasRole(String roleIdentifier);  </div><div class="line">boolean[] hasRoles(List&lt;String&gt; roleIdentifiers);  </div><div class="line">boolean hasAllRoles(Collection&lt;String&gt; roleIdentifiers);  </div><div class="line">void checkRole(String roleIdentifier) throws AuthorizationException;  </div><div class="line">void checkRoles(Collection&lt;String&gt; roleIdentifiers) throws AuthorizationException;  </div><div class="line">void checkRoles(String... roleIdentifiers) throws AuthorizationException;</div></pre></td></tr></table></figure>
<h2 id="权限授权验证"><a href="#权限授权验证" class="headerlink" title="权限授权验证"></a>权限授权验证</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">boolean isPermitted(String permission);  </div><div class="line">boolean isPermitted(Permission permission);  </div><div class="line">boolean[] isPermitted(String... permissions);  </div><div class="line">boolean[] isPermitted(List&lt;Permission&gt; permissions);  </div><div class="line">boolean isPermittedAll(String... permissions);  </div><div class="line">boolean isPermittedAll(Collection&lt;Permission&gt; permissions);  </div><div class="line">void checkPermission(String permission) throws AuthorizationException;  </div><div class="line">void checkPermission(Permission permission) throws AuthorizationException;  </div><div class="line">void checkPermissions(String... permissions) throws AuthorizationException;  </div><div class="line">void checkPermissions(Collection&lt;Permission&gt; permissions) throws AuthorizationException;</div></pre></td></tr></table></figure>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 相当于getSession(true)</div><div class="line">Session getSession(); </div><div class="line">Session getSession(boolean create);</div></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>create=false</code> 如果没有会话将<code>返回null</code>；而 <code>create=true</code> 如果没有会话会强制<code>创建一个</code>。</p>
</blockquote>
<h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void logout();</div></pre></td></tr></table></figure>
<h2 id="RunAs"><a href="#RunAs" class="headerlink" title="RunAs"></a>RunAs</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void runAs(PrincipalCollection principals) throws NullPointerException, IllegalStateException;  </div><div class="line">boolean isRunAs();  </div><div class="line">PrincipalCollection getPreviousPrincipals();  </div><div class="line">PrincipalCollection releaseRunAs();</div></pre></td></tr></table></figure>
<p><strong>RunAs</strong>即实现<strong>允许A假设为B身份进行访问</strong>：  </p>
<blockquote>
<p>通过调用 <code>subject.runAs(b)</code> 进行访问；<br>接着调用 <code>subject.getPrincipals</code> 将获取到B的身份；<br>此时调用 <code>isRunAs</code> 将返回true，而a的身份需要通过 <code>subject.getPreviousPrincipals</code> 获取；<br>如果不需要RunAs了调用 <code>subject.releaseRunAs</code> 即可。</p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;V&gt; V execute(Callable&lt;V&gt; callable) throws ExecutionException;  </div><div class="line">void execute(Runnable runnable);  </div><div class="line">&lt;V&gt; Callable&lt;V&gt; associateWith(Callable&lt;V&gt; callable);  </div><div class="line">Runnable associateWith(Runnable runnable);</div></pre></td></tr></table></figure>
<blockquote>
<p>在多线程执行中需要传播到相应的线程才能获取到相应的Subject。<br>最简单的办法就是通过 <code>execute(runnable/callable实例)</code> 直接调用；<br>或者通过 <code>associateWith(runnable/callable实例)</code> 得到一个包装后的实例；<br>它们都是通过：把当前线程的Subject绑定过去；在线程执行结束后自动释放。</p>
</blockquote>
<p>Subject自己不会实现相应的身份验证/授权逻辑，而是通过DelegatingSubject委托给SecurityManager实现。</p>
<p>如果想自定义创建，可以通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new Subject.Builder().principals(身份).authenticated(true/false).buildSubject()</div></pre></td></tr></table></figure></p>
<h2 id="Subject一般流程"><a href="#Subject一般流程" class="headerlink" title="Subject一般流程"></a>Subject一般流程</h2><ul>
<li><strong>身份验证</strong>（login）</li>
<li><strong>授权</strong>（hasRole*/isPermitted*或checkRole*/checkPermission*）</li>
<li>将相应的数据存储到<strong>会话</strong>（Session）</li>
<li><strong>切换身份</strong>（RunAs）/<strong>多线程</strong>身份传播</li>
<li><strong>退出</strong></li>
</ul>
<blockquote>
<p>必须的功能就是1、2、5。到目前为止我们就可以使用Shiro进行应用程序的安全控制了，但是还是缺少如对Web验证、Java方法验证等的一些简化实现。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h2><ul>
<li>Permission</li>
<li>Role</li>
<li>User</li>
<li>User-Role</li>
<li>Role-Permission</li>
</ul>
<h2 id="AuthenticationToken-1"><a href="#AuthenticationToken-1" class="headerlink" title="AuthenticationToken"></a>AuthenticationToken</h2><ul>
<li>Principal</li>
<li>Credentials</li>
<li>RemeberMeAuthenticationToken</li>
<li>HostAuthenticationToken</li>
<li>UsernamePasswordToken</li>
</ul>
<h2 id="AuthenticationInfo-1"><a href="#AuthenticationInfo-1" class="headerlink" title="AuthenticationInfo"></a>AuthenticationInfo</h2><ul>
<li>提供身份信息</li>
<li>提供凭据验证</li>
<li>SimpleAuthenticationInfo</li>
</ul>
<h2 id="PrincipalCollection-1"><a href="#PrincipalCollection-1" class="headerlink" title="PrincipalCollection"></a>PrincipalCollection</h2><ul>
<li>Principal</li>
<li>MutablePrincipalCollection</li>
<li>PrincipalMap</li>
</ul>
<h2 id="AuthorizationInfo-1"><a href="#AuthorizationInfo-1" class="headerlink" title="AuthorizationInfo"></a>AuthorizationInfo</h2><ul>
<li>Roles</li>
<li>StringPermissions</li>
<li>ObjectPermissions</li>
<li>SimpleAuthorizationInfo</li>
</ul>
<h2 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h2><ul>
<li>身份获取</li>
<li>身份验证</li>
<li>角色授权</li>
<li>权限授权</li>
<li>会话</li>
<li>退出</li>
<li>RunAs</li>
<li>多线程</li>
</ul>
<blockquote>
<p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter6</code></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Shiro </tag>
            
            <tag> Realm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（五）-编码、加密]]></title>
      <url>/2017/11/29/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BC%96%E7%A0%81%E3%80%81%E5%8A%A0%E5%AF%86/</url>
      <content type="html"><![CDATA[<p>在涉及到<strong>密码存储</strong>问题上，应该加密/生成密码摘要存储，而不是存储明文密码。</p>
<h1 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码/解码"></a>编码/解码</h1><p>Shiro提供了 <strong>base64</strong> 和 <strong>16进制字符串</strong> 编码/解码的API支持，方便一些编码解码操作。Shiro内部的一些数据的存储/表示都使用了base64和16进制字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String base64Encoded = Base64.encodeToString(str.getBytes());  </div><div class="line">String str2 = Base64.decodeToString(base64Encoded);  </div><div class="line">Assert.assertEquals(str, str2);</div></pre></td></tr></table></figure></p>
<p>通过如上方式可以进行<code>base64编码/解码</code>操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String base64Encoded = Hex.encodeToString(str.getBytes());  </div><div class="line">String str2 = new String(Hex.decode(base64Encoded.getBytes()));  </div><div class="line">Assert.assertEquals(str, str2);</div></pre></td></tr></table></figure></p>
<p>通过如上方式可以进行<code>16进制字符串编码/解码</code>操作。</p>
<blockquote>
<p>还有一个可能经常用到的类<code>CodecSupport</code>，提供了<code>toBytes(str, &quot;utf-8&quot;)</code> / <code>toString(bytes, &quot;utf-8&quot;)</code>用于在byte数组/String之间转换。</p>
</blockquote>
<a id="more"></a>
<h1 id="散列（Hash）算法"><a href="#散列（Hash）算法" class="headerlink" title="散列（Hash）算法"></a>散列（Hash）算法</h1><p><strong>散列算法</strong>一般用于<code>生成数据的摘要信息</code>，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如MD5、SHA等。</p>
<p>一般进行散列时最好提供一个<code>salt</code>（盐），如用户名和ID（即盐）；这样散列的对象是“密码+用户名+ID”，这样生成的散列值相对来说更难破解。</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">String md5 = new Md5Hash(str, salt).toString();//还可以转换为 toBase64()/toHex()</div></pre></td></tr></table></figure>
<p>如上代码使用<code>MD5算法</code>通过盐“123”生成MD5散列。<br>另外散列时还可以指定散列次数，如2次表示：md5(md5(str))：<br><code>new Md5Hash(str, salt, 2).toString()</code>。</p>
<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">String sha1 = new Sha256Hash(str, salt).toString();</div></pre></td></tr></table></figure>
<p>使用<code>SHA256算法</code>生成相应的散列数据，另外还有如SHA1、SHA512算法。</p>
<h2 id="通用的散列支持"><a href="#通用的散列支持" class="headerlink" title="通用的散列支持"></a>通用的散列支持</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot;;  </div><div class="line">String salt = &quot;123&quot;;  </div><div class="line">//内部使用MessageDigest  </div><div class="line">String simpleHash = new SimpleHash(&quot;SHA-1&quot;, str, salt).toString();</div></pre></td></tr></table></figure>
<p>通过调用 <code>SimpleHash</code> 时指定散列算法，其内部使用了Java的 <code>MessageDigest</code> 实现。</p>
<p>为了方便使用，Shiro提供了 <code>HashService</code> ，默认提供了 <code>DefaultHashService</code> 实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 默认算法SHA-512</div><div class="line">DefaultHashService hashService = new DefaultHashService(); </div><div class="line">hashService.setHashAlgorithmName(&quot;SHA-512&quot;);</div><div class="line">// 私盐，默认无</div><div class="line">hashService.setPrivateSalt(new SimpleByteSource(&quot;123&quot;)); </div><div class="line">// 是否生成公盐，默认false</div><div class="line">hashService.setGeneratePublicSalt(true);</div><div class="line">// 用于生成公盐。默认就这个</div><div class="line">hashService.setRandomNumberGenerator(new SecureRandomNumberGenerator());</div><div class="line">// 生成Hash值的迭代次数</div><div class="line">hashService.setHashIterations(1); </div><div class="line">  </div><div class="line">HashRequest request = new HashRequest.Builder()  </div><div class="line">            .setAlgorithmName(&quot;MD5&quot;).setSource(ByteSource.Util.bytes(&quot;hello&quot;))  </div><div class="line">            .setSalt(ByteSource.Util.bytes(&quot;123&quot;)).setIterations(2).build();  </div><div class="line">String hex = hashService.computeHash(request).toHex();</div></pre></td></tr></table></figure></p>
<ul>
<li>首先创建一个 <code>DefaultHashService</code> ，默认使用<code>SHA-512算法</code>；</li>
<li>可以通过 <code>hashAlgorithmName</code> 属性修改算法；</li>
<li>可以通过 <code>privateSalt</code> 设置一个<code>私盐</code>，其在散列时自动与用户传入的公盐混合产生一个新盐；</li>
<li>可以通过 <code>generatePublicSalt</code> 属性在用户没有传入公盐的情况下是否生成<code>公盐</code>；</li>
<li>可以设置 <code>randomNumberGenerator</code> 用于生成<code>公盐</code>；</li>
<li>可以设置 <code>hashIterations</code> 属性来修改默认加密<code>迭代次数</code>；</li>
<li>需要构建一个 <code>HashRequest</code> ，传入算法、数据、公盐、迭代次数。</li>
</ul>
<p>SecureRandomNumberGenerator用于<strong>生成一个随机数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SecureRandomNumberGenerator randomNumberGenerator =  </div><div class="line">     new SecureRandomNumberGenerator();  </div><div class="line">randomNumberGenerator.setSeed(&quot;123&quot;.getBytes());  </div><div class="line">String hex = randomNumberGenerator.nextBytes().toHex();</div></pre></td></tr></table></figure></p>
<h1 id="加密-解密"><a href="#加密-解密" class="headerlink" title="加密/解密"></a>加密/解密</h1><p>Shiro提供<strong>对称式加密/解密算法</strong>的支持，如AES、Blowfish等。<br>当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p>
<h2 id="AES算法实现"><a href="#AES算法实现" class="headerlink" title="AES算法实现"></a>AES算法实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AesCipherService aesCipherService = new AesCipherService();</div><div class="line">// 设置key长度</div><div class="line">aesCipherService.setKeySize(128); </div><div class="line">//生成key  </div><div class="line">Key key = aesCipherService.generateNewKey();  </div><div class="line">String text = &quot;hello&quot;;  </div><div class="line">//加密  </div><div class="line">String encrptText =   </div><div class="line">aesCipherService.encrypt(text.getBytes(), key.getEncoded()).toHex();  </div><div class="line">//解密  </div><div class="line">String text2 =  </div><div class="line"> new String(aesCipherService.decrypt(Hex.decode(encrptText), key.getEncoded()).getBytes());  </div><div class="line">  </div><div class="line">Assert.assertEquals(text, text2);</div></pre></td></tr></table></figure>
<h1 id="PasswordService-CredentialsMatcher"><a href="#PasswordService-CredentialsMatcher" class="headerlink" title="PasswordService/CredentialsMatcher"></a>PasswordService/CredentialsMatcher</h1><p>Shiro提供了 <code>PasswordService</code> 及 <code>CredentialsMatcher</code> 用于提供<strong>加密</strong>密码及<strong>验证</strong>密码服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface PasswordService &#123;  </div><div class="line">    // 输入明文密码得到密文密码</div><div class="line">    String encryptPassword(Object plaintextPassword) throws IllegalArgumentException;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface CredentialsMatcher &#123;  </div><div class="line">    // 匹配用户输入的token的凭证（未加密）与系统提供的凭证（已加密）  </div><div class="line">    boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Shiro默认提供了<strong>PasswordService</strong>实现<code>DefaultPasswordService</code>；<strong>CredentialsMatcher</strong>实现<code>PasswordMatcher</code>及<code>HashedCredentialsMatcher</code>（更强大）。</p>
<h2 id="DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务"><a href="#DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务" class="headerlink" title="DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务"></a>DefaultPasswordService配合PasswordMatcher实现简单的密码加密与验证服务</h2><h3 id="定义Realm"><a href="#定义Realm" class="headerlink" title="定义Realm"></a>定义Realm</h3><blockquote>
<p>com.github.gojay001.relam.MyRealm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public class MyRealm extends AuthorizingRealm &#123;  </div><div class="line">    private PasswordService passwordService;  </div><div class="line">    public void setPasswordService(PasswordService passwordService) &#123;  </div><div class="line">        this.passwordService = passwordService;  </div><div class="line">    &#125;  </div><div class="line">     // 省略doGetAuthorizationInfo，具体看代码   </div><div class="line">    @Override  </div><div class="line">    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;  </div><div class="line">        return new SimpleAuthenticationInfo(  </div><div class="line">                &quot;root&quot;,  </div><div class="line">                passwordService.encryptPassword(&quot;root&quot;),  </div><div class="line">                getName());  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了方便，直接注入一个<code>passwordService</code>来加密密码；实际使用时需要在<code>Service层</code>使用passwordService<code>加密</code>密码<code>并存储</code>到数据库。</p>
</blockquote>
<h3 id="INI配置"><a href="#INI配置" class="headerlink" title="INI配置"></a>INI配置</h3><blockquote>
<p>shiro-passwordservice.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">passwordService=org.apache.shiro.authc.credential.DefaultPasswordService  </div><div class="line">hashService=org.apache.shiro.crypto.hash.DefaultHashService  </div><div class="line">passwordService.hashService=$hashService  </div><div class="line">hashFormat=org.apache.shiro.crypto.hash.format.Shiro1CryptFormat  </div><div class="line">passwordService.hashFormat=$hashFormat  </div><div class="line">hashFormatFactory=org.apache.shiro.crypto.hash.format.DefaultHashFormatFactory  </div><div class="line">passwordService.hashFormatFactory=$hashFormatFactory  </div><div class="line">  </div><div class="line">passwordMatcher=org.apache.shiro.authc.credential.PasswordMatcher  </div><div class="line">passwordMatcher.passwordService=$passwordService  </div><div class="line">  </div><div class="line">myRealm=com.github.gojay001.realm.MyRealm  </div><div class="line">myRealm.passwordService=$passwordService  </div><div class="line">myRealm.credentialsMatcher=$passwordMatcher  </div><div class="line">securityManager.realms=$myRealm</div></pre></td></tr></table></figure>
<ul>
<li><strong>passwordService</strong>使用<code>DefaultPasswordService</code>，如果有必要也可以自定义；</li>
<li><strong>hashService</strong>定义散列密码使用的HashService，默认使用<code>DefaultHashService</code>（默认SHA-256算法）；</li>
<li><strong>hashFormat</strong>用于对散列出的值进行格式化，默认使用<code>Shiro1CryptFormat</code>，另外提供了Base64Format和HexFormat，对于有salt的密码请<code>自定义实现</code>ParsableHashFormat然后把salt格式化到散列值中；</li>
<li><strong>hashFormatFactory</strong>用于根据散列值得到散列的密码和salt；因为如果使用如SHA算法，那么会生成一个salt，此salt需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用<code>DefaultHashFormatFactory</code>；</li>
<li><strong>passwordMatcher</strong>使用<code>PasswordMatcher</code>，其是一个CredentialsMatcher实现；</li>
<li>将<code>credentialsMatcher</code>赋值给<strong>myRealm</strong>，myRealm间接继承了AuthenticatingRealm，其在调用getAuthenticationInfo方法获取到AuthenticationInfo信息后，会使用credentialsMatcher来验证凭据是否匹配，如果不匹配将抛出IncorrectCredentialsException异常。</li>
</ul>
<blockquote>
<p>测试用例参考： <code>com.github.gojay001.test.PasswordTest</code> ，包含JdbcRealm测试用例。<br><strong>缺点</strong>：salt保存在散列值中，没有实现如密码重试次数限制。</p>
</blockquote>
<h2 id="HashedCredentialsMatcher实现密码验证服务"><a href="#HashedCredentialsMatcher实现密码验证服务" class="headerlink" title="HashedCredentialsMatcher实现密码验证服务"></a>HashedCredentialsMatcher实现密码验证服务</h2><p>Shiro提供了<strong>CredentialsMatcher</strong>的散列实现<code>HashedCredentialsMatcher</code>，和之前的PasswordMatcher不同的是，它只用于<code>密码验证</code>，且可以<code>提供自己的盐</code>，而不是随机生成盐，且生成密码散列值的算法需要自己写，因为能提供自己的盐。</p>
<h3 id="生成密码散列值"><a href="#生成密码散列值" class="headerlink" title="生成密码散列值"></a>生成密码散列值</h3><p>此处我们使用<code>MD5算法</code>，“密码+盐（用户名+随机数）”的方式生成散列值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String algorithmName = &quot;md5&quot;;  </div><div class="line">String username = &quot;root&quot;;  </div><div class="line">String password = &quot;root&quot;;  </div><div class="line">String salt1 = username;  </div><div class="line">String salt2 = new SecureRandomNumberGenerator().nextBytes().toHex();  </div><div class="line">int hashIterations = 2;  </div><div class="line">  </div><div class="line">SimpleHash hash = new SimpleHash(algorithmName, password, salt1 + salt2, hashIterations);  </div><div class="line">String encodedPassword = hash.toHex();</div></pre></td></tr></table></figure></p>
<p>如果要写用户模块，需要在新增用户/重置密码时使用如上算法保存密码，将<code>生成的密码</code>及<code>salt2</code>存入数据库。<br>因为我们的散列算法是：md5(密码+username+salt2)。</p>
<h3 id="生成Realm"><a href="#生成Realm" class="headerlink" title="生成Realm"></a>生成Realm</h3><h4 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h4><blockquote>
<p>com.github.gojay001.realm.MyRealm2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123;</div><div class="line">    // 用户名及salt1  </div><div class="line">    String username = &quot;liu&quot;; </div><div class="line">    // 加密后的密码  </div><div class="line">    String password = &quot;202cb962ac59075b964b07152d234b70&quot;; </div><div class="line">    String salt2 = &quot;202cb962ac59075b964b07152d234b70&quot;;  </div><div class="line">SimpleAuthenticationInfo ai =   </div><div class="line">        new SimpleAuthenticationInfo(username, password, getName());  </div><div class="line">    // 盐是用户名+随机数</div><div class="line">    ai.setCredentialsSalt(ByteSource.Util.bytes(username+salt2)); </div><div class="line">        return ai;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处就是把步骤1中生成的相应数据组装为 <code>SimpleAuthenticationInfo</code> ，通过 <code>SimpleAuthenticationInfo</code> 的 <code>credentialsSalt</code> 设置盐， <code>HashedCredentialsMatcher</code> 会自动识别这个盐。</p>
<h4 id="JdbcRealm"><a href="#JdbcRealm" class="headerlink" title="JdbcRealm"></a>JdbcRealm</h4><p>需要修改获取用户信息（包括盐）的sql： <code>“select password, password_salt from users where username = ?”</code> ；<br>而我们的盐是由 <code>username+password_salt</code> 组成，所以需要通过如下ini配置（<code>shiro-jdbc-hashedCredentialsMatcher.ini</code>）修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jdbcRealm.saltStyle=COLUMN  </div><div class="line">jdbcRealm.authenticationQuery=select password, concat(username,password_salt) from users where username = ?  </div><div class="line">jdbcRealm.credentialsMatcher=$credentialsMatcher</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>saltStyle</strong>表示使用<code>密码+盐</code>的机制，authenticationQuery第一列是密码，第二列是盐；</li>
<li>通过 <code>authenticationQuery</code> 指定密码及盐查询SQL。</li>
</ul>
<h3 id="INI配置-1"><a href="#INI配置-1" class="headerlink" title="INI配置"></a>INI配置</h3><blockquote>
<p>shiro-hashedCredentialsMatcher.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher  </div><div class="line">credentialsMatcher.hashAlgorithmName=md5  </div><div class="line">credentialsMatcher.hashIterations=2  </div><div class="line">credentialsMatcher.storedCredentialsHexEncoded=true  </div><div class="line">myRealm=com.github.gojay001.realm.MyRealm2  </div><div class="line">myRealm.credentialsMatcher=$credentialsMatcher  </div><div class="line">securityManager.realms=$myRealm</div></pre></td></tr></table></figure>
<ul>
<li>通过 <code>credentialsMatcher.hashAlgorithmName=md5</code> 指定散列算法为md5，需要和生成密码时的一样；</li>
<li><code>credentialsMatcher.hashIterations=2</code> ，散列迭代次数，需要和生成密码时的意义；</li>
<li><code>credentialsMatcher.storedCredentialsHexEncoded=true</code> 表示是否存储散列后的密码为16进制，需要和生成密码时的一样，默认是base64；</li>
</ul>
<blockquote>
<p>此处最需要注意的就是 <code>HashedCredentialsMatcher</code> 的算法需要和生成密码时的算法一样。另外HashedCredentialsMatcher会自动根据 <code>AuthenticationInfo</code> 的类型是否是 <code>SaltedAuthenticationInfo</code> 来<code>获取credentialsSalt盐</code>。</p>
</blockquote>
<h3 id="密码重试次数限制"><a href="#密码重试次数限制" class="headerlink" title="密码重试次数限制"></a>密码重试次数限制</h3><p>如在1个小时内密码最多重试5次，如果尝试次数超过5次就锁定1小时，1小时后可再次重试，如果还是重试失败，可以锁定如1天，以此类推，防止密码被暴力破解。我们通过<strong>继承HashedCredentialsMatcher</strong>，且使用<strong>Ehcache</strong>记录<code>重试次数</code>和<code>超时时间</code>。</p>
<blockquote>
<p>com.github.gojay001.credentials.RetryLimitHashedCredentialsMatcher</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123;  </div><div class="line">       String username = (String)token.getPrincipal();  </div><div class="line">        //retry count + 1  </div><div class="line">        Element element = passwordRetryCache.get(username);  </div><div class="line">        if(element == null) &#123;  </div><div class="line">            element = new Element(username , new AtomicInteger(0));  </div><div class="line">            passwordRetryCache.put(element);  </div><div class="line">        &#125;  </div><div class="line">        AtomicInteger retryCount = (AtomicInteger)element.getObjectValue();  </div><div class="line">        if(retryCount.incrementAndGet() &gt; 5) &#123;  </div><div class="line">            //if retry count &gt; 5 throw  </div><div class="line">            throw new ExcessiveAttemptsException();  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        boolean matches = super.doCredentialsMatch(token, info);  </div><div class="line">        if(matches) &#123;  </div><div class="line">            //clear retry count  </div><div class="line">            passwordRetryCache.remove(username);  </div><div class="line">        &#125;  </div><div class="line">        return matches;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上代码逻辑比较简单，即如果密码输入<code>正确</code>，<code>清除cache</code>中的记录；否则<code>cache中的重试次数+1</code>，如果超出5次那么抛出异常表示超出重试次数了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="编码-解码-1"><a href="#编码-解码-1" class="headerlink" title="编码/解码"></a>编码/解码</h2><ul>
<li>Base64</li>
<li>Hex</li>
<li>Hash()</li>
</ul>
<h2 id="加密-解密-1"><a href="#加密-解密-1" class="headerlink" title="加密/解密"></a>加密/解密</h2><ul>
<li>对称式加密/解密</li>
</ul>
<h2 id="加密-验证"><a href="#加密-验证" class="headerlink" title="加密/验证"></a>加密/验证</h2><h3 id="PasswordService"><a href="#PasswordService" class="headerlink" title="PasswordService"></a>PasswordService</h3><ul>
<li>DefaultPasswordService</li>
</ul>
<h3 id="CredentialsMatcher"><a href="#CredentialsMatcher" class="headerlink" title="CredentialsMatcher"></a>CredentialsMatcher</h3><ul>
<li>PasswordMatcher</li>
<li>HashedCredentialsMatcher</li>
</ul>
<h2 id="DefaultPasswordService配合PasswordMatcher"><a href="#DefaultPasswordService配合PasswordMatcher" class="headerlink" title="DefaultPasswordService配合PasswordMatcher"></a>DefaultPasswordService配合PasswordMatcher</h2><h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>自定义Realm</li>
<li>JdbcRealm</li>
</ul>
<h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><ul>
<li>passwordService</li>
<li>hashService</li>
<li>hashFormat</li>
<li>hashFormatFactory</li>
<li>passwordMatcher</li>
<li>myRealm</li>
</ul>
<h2 id="HashedCredentialsMatcher"><a href="#HashedCredentialsMatcher" class="headerlink" title="HashedCredentialsMatcher"></a>HashedCredentialsMatcher</h2><h3 id="生成Realm-1"><a href="#生成Realm-1" class="headerlink" title="生成Realm"></a>生成Realm</h3><ul>
<li>使用MD5算法</li>
</ul>
<h3 id="ini配置-1"><a href="#ini配置-1" class="headerlink" title="ini配置"></a>ini配置</h3><ul>
<li>credentialsMatcher</li>
<li>hashAlgorithmName</li>
<li>hashIterations</li>
<li>myRealm</li>
</ul>
<h3 id="添加密码重试次数限制"><a href="#添加密码重试次数限制" class="headerlink" title="添加密码重试次数限制"></a>添加密码重试次数限制</h3><ul>
<li>记录重试次数</li>
</ul>
<blockquote>
<p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter5</code></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> 编码 </tag>
            
            <tag> Shiro </tag>
            
            <tag> 加密 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（四）-INI配置]]></title>
      <url>/2017/11/28/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E5%9B%9B%EF%BC%89-INI%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h1 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h1><p>Shiro是从根对象 <code>SecurityManager</code> 进行身份验证和授权的，这个对象是线程安全且真个应用只需要一个即可，因此Shiro提供了 <code>SecurityUtils</code> 让我们绑定它为<code>全局</code>的，方便后续操作。</p>
<blockquote>
<p>因为Shiro的类都是POJO的，因此都很容易放到任何IoC容器管理。<br>但是和一般的IoC容器的区别在于，Shiro从根对象securityManager开始导航。<br>Shiro支持的依赖注入：public空参构造器对象的创建、setter依赖注入。</p>
</blockquote>
<a id="more"></a>
<h2 id="纯Java代码写法"><a href="#纯Java代码写法" class="headerlink" title="纯Java代码写法"></a>纯Java代码写法</h2><blockquote>
<p>com.github.gojay001.test.NonConfigurationCreateTest</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DefaultSecurityManager securityManager = new DefaultSecurityManager();</div><div class="line"></div><div class="line">//设置authenticator</div><div class="line">ModularRealmAuthenticator authenticator = new ModularRealmAuthenticator();</div><div class="line">authenticator.setAuthenticationStrategy(new AtLeastOneSuccessfulStrategy());</div><div class="line">securityManager.setAuthenticator(authenticator);</div><div class="line"></div><div class="line">//设置authorizer</div><div class="line">ModularRealmAuthorizer authorizer = new ModularRealmAuthorizer();</div><div class="line">authorizer.setPermissionResolver(new WildcardPermissionResolver());</div><div class="line">securityManager.setAuthorizer(authorizer);</div><div class="line"></div><div class="line">//设置Realm</div><div class="line">DruidDataSource ds = new DruidDataSource();</div><div class="line">ds.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</div><div class="line">ds.setUrl(&quot;jdbc:mysql://localhost:3306/shiro&quot;);</div><div class="line">ds.setUsername(&quot;root&quot;);</div><div class="line">ds.setPassword(&quot;root&quot;);</div><div class="line"></div><div class="line">JdbcRealm jdbcRealm = new JdbcRealm();</div><div class="line">jdbcRealm.setDataSource(ds);</div><div class="line">jdbcRealm.setPermissionsLookupEnabled(true);</div><div class="line">securityManager.setRealms(Arrays.asList((Realm) jdbcRealm));</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure>
<h2 id="等价的INI配置"><a href="#等价的INI配置" class="headerlink" title="等价的INI配置"></a>等价的INI配置</h2><h3 id="shiro-config-ini："><a href="#shiro-config-ini：" class="headerlink" title="shiro-config.ini："></a>shiro-config.ini：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#覆盖默认的securityManager</div><div class="line">#securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div><div class="line"></div><div class="line">#authenticator</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy</div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#realm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line"></div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure>
<blockquote>
<p><code>对象名=全限定类名</code>  相对于调用public无参构造器创建对象<br><code>对象名.属性名=值</code>    相当于调用setter方法设置常量值<br><code>对象名.属性名=$对象引用</code>    相当于调用setter方法设置对象引用</p>
</blockquote>
<h3 id="com-github-gojay001-test-ConfigurationCreateTest："><a href="#com-github-gojay001-test-ConfigurationCreateTest：" class="headerlink" title="com.github.gojay001.test.ConfigurationCreateTest："></a>com.github.gojay001.test.ConfigurationCreateTest：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Factory&lt;SecurityManager&gt; factory =</div><div class="line">    new IniSecurityManagerFactory(&quot;classpath:shiro-config.ini&quot;);</div><div class="line"></div><div class="line">SecurityManager securityManager = factory.getInstance();</div><div class="line"></div><div class="line">//将SecurityManager设置到SecurityUtils 方便全局使用</div><div class="line">SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">Subject subject = SecurityUtils.getSubject();</div><div class="line"></div><div class="line">UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line">subject.login(token);</div><div class="line"></div><div class="line">Assert.assertTrue(subject.isAuthenticated());</div></pre></td></tr></table></figure>
<blockquote>
<p>如上代码是从Shiro <code>INI配置</code>中获取相应的<code>securityManager</code>实例：  </p>
<ol>
<li>默认情况先创建一个名字为 <code>securityManager</code> ，类型为 <code>org.apache.shiro.mgt.DefaultSecurityManager</code> 的默认的 <code>SecurityManager</code> ，如果想<code>自定义</code>，只需要在ini配置文件中指定“securityManager=SecurityManager实现类”即可，名字必须为securityManager，它是起始的根；  </li>
<li><code>IniSecurityManagerFactory</code> 是创建 <code>securityManager</code> 的工厂，其需要一个ini配置文件路径，其支持<code>classpath:</code>（类路径）、<code>file:</code>（文件系统）、<code>url:</code>（网络）三种路径格式，默认是<code>文件系统</code>；  </li>
<li>接着获取<code>SecuriyManager实例</code>，后续步骤和之前的一样。</li>
</ol>
</blockquote>
<p>如上可以看出Shiro INI配置方式本身提供了一个简单的<code>IoC/DI机制</code>方便在配置文件配置，但是是从 <code>securityManager</code> 这个根对象开始导航。</p>
<h1 id="INI配置"><a href="#INI配置" class="headerlink" title="INI配置"></a>INI配置</h1><p><code>ini配置文件</code>类似于Java中的 <code>properties（key=value）</code> ，不过提供了将key/value分类的特性，key是每个部分不重复即可，而不是整个配置文件。如下是INI配置分类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[main]  </div><div class="line">#提供了对根对象securityManager及其依赖的配置  </div><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager  </div><div class="line">…………  </div><div class="line">securityManager.realms=$jdbcRealm  </div><div class="line">  </div><div class="line">[users]  </div><div class="line">#提供了对用户/密码及其角色的配置，用户名=密码，角色1，角色2  </div><div class="line">username=password,role1,role2  </div><div class="line">  </div><div class="line">[roles]  </div><div class="line">#提供了角色及权限之间关系的配置，角色=权限1，权限2  </div><div class="line">role1=permission1,permission2  </div><div class="line">  </div><div class="line">[urls]  </div><div class="line">#用于web，提供了对web url拦截相关的配置，url=拦截器[参数]，拦截器  </div><div class="line">/index.html = anon  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p>
<h2 id="main-部分"><a href="#main-部分" class="headerlink" title="[main]部分"></a>[main]部分</h2><p>提供了对根对象 <strong>securityManager</strong> 及其依赖对象的配置。</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager=org.apache.shiro.mgt.DefaultSecurityManager</div></pre></td></tr></table></figure>
<p>其构造器必须是<code>public空参构造器</code>，通过反射创建相应的实例。</p>
<h3 id="常量值setter注入"><a href="#常量值setter注入" class="headerlink" title="常量值setter注入"></a>常量值setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div></pre></td></tr></table></figure>
<p>会自动调用 <code>jdbcRealm.setPermissionsLookupEnabled(true)</code> ，对于这种常量值会自动类型转换。</p>
<h3 id="对象引用setter注入"><a href="#对象引用setter注入" class="headerlink" title="对象引用setter注入"></a>对象引用setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator  </div><div class="line">authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy  </div><div class="line">authenticator.authenticationStrategy=$authenticationStrategy  </div><div class="line">securityManager.authenticator=$authenticator</div></pre></td></tr></table></figure>
<p>会自动通过 <code>securityManager.setAuthenticator(authenticator)</code> 注入引用依赖。</p>
<h3 id="嵌套属性setter注入"><a href="#嵌套属性setter注入" class="headerlink" title="嵌套属性setter注入"></a>嵌套属性setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">securityManager.authenticator.authenticationStrategy=$authenticationStrategy</div></pre></td></tr></table></figure>
<p>支持这种嵌套方式的setter注入。</p>
<h3 id="byte数组setter注入"><a href="#byte数组setter注入" class="headerlink" title="byte数组setter注入"></a>byte数组setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#base64 byte[]  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">#hex byte[]  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure>
<p>默认需要使用Base64进行编码，也可以使用0x十六进制。</p>
<h3 id="Array-Set-List-setter注入"><a href="#Array-Set-List-setter注入" class="headerlink" title="Array/Set/List setter注入"></a>Array/Set/List setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authenticator.array=1,2,3  </div><div class="line">authenticator.set=$jdbcRealm,$jdbcRealm</div></pre></td></tr></table></figure>
<p>多个之间通过“，”分割。</p>
<h3 id="Map-setter注入"><a href="#Map-setter注入" class="headerlink" title="Map setter注入"></a>Map setter注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">authenticator.map=$jdbcRealm:$jdbcRealm,1:1,key:abc</div></pre></td></tr></table></figure>
<p>格式是： <code>map=key：value，key：value</code> ，可以注入常量及引用值，常量的话都看作字符串（即使有泛型也不会自动造型）。  </p>
<h3 id="实例化-注入顺序"><a href="#实例化-注入顺序" class="headerlink" title="实例化/注入顺序"></a>实例化/注入顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">realm=Realm1  </div><div class="line">realm=Realm12  </div><div class="line">  </div><div class="line">authenticator.bytes=aGVsbG8=  </div><div class="line">authenticator.bytes=0x68656c6c6f</div></pre></td></tr></table></figure>
<p>后边的<code>覆盖</code>前边的注入。</p>
<h2 id="users-部分"><a href="#users-部分" class="headerlink" title="[users]部分"></a>[users]部分</h2><p>配置用户名/密码及其角色，格式：<code>用户名=密码，角色1，角色2</code>，角色部分可省略。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test</div></pre></td></tr></table></figure></p>
<p>密码一般生成其摘要/加密存储。</p>
<h2 id="roles-部分"><a href="#roles-部分" class="headerlink" title="[roles]部分"></a>[roles]部分</h2><p>配置角色及权限之间的关系，格式：<code>角色=权限1，权限2</code>；如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[roles]  </div><div class="line">role1=user:create,user:update  </div><div class="line">role2=*</div></pre></td></tr></table></figure></p>
<p>如果只有角色没有对应的权限，可以不配roles。</p>
<h2 id="urls-部分"><a href="#urls-部分" class="headerlink" title="[urls]部分"></a>[urls]部分</h2><p>配置url及相应的拦截器之间的关系，格式：<code>url=拦截器[参数]，拦截器[参数]</code>，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[urls]  </div><div class="line">/admin/** = authc, roles[admin], perms[&quot;permission1&quot;]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考代码： <code>https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter4</code></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（三）-授权]]></title>
      <url>/2017/11/23/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8E%88%E6%9D%83/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>授权</strong>：也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象：<code>主体</code>（Subject）、<code>资源</code>（Resource）、<code>权限</code>（Permission）、<code>角色</code>（Role）。</p>
<ul>
<li><strong>主体</strong>：即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。</li>
<li><strong>资源</strong>：在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。</li>
<li><strong>权限</strong>：安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。</li>
<li><strong>角色</strong>：角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。</li>
<li><strong>隐式角色</strong>：即直接通过角色来验证用户有没有操作权限。</li>
<li><strong>显式角色</strong>：在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合。</li>
</ul>
<blockquote>
<p><strong>了解更多</strong>：搜索<code>“RBAC”</code>和<code>“RBAC新解”</code>分别了解<code>“基于角色的访问控制”</code>和<code>“基于资源的访问控制”</code>。</p>
</blockquote>
<a id="more"></a>
<h1 id="授权方式"><a href="#授权方式" class="headerlink" title="授权方式"></a>授权方式</h1><blockquote>
<p>Shiro支持三种方式的授权。</p>
</blockquote>
<h2 id="编程式"><a href="#编程式" class="headerlink" title="编程式"></a>编程式</h2><p>通过写if/else授权代码块完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Subject subject = SecurityUtils.getSubject();  </div><div class="line">if(subject.hasRole(“admin”)) &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125; else &#123;  </div><div class="line">    //无权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="注解式"><a href="#注解式" class="headerlink" title="注解式"></a>注解式</h2><p>通过在执行的Java方法上放置相应的注解完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@RequiresRoles(&quot;admin&quot;)  </div><div class="line">public void hello() &#123;  </div><div class="line">    //有权限  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>没有权限将抛出相应的异常。</p>
<h2 id="JSP-GSP标签"><a href="#JSP-GSP标签" class="headerlink" title="JSP/GSP标签"></a>JSP/GSP标签</h2><p>在JSP/GSP页面通过相应的标签完成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;shiro:hasRole name=&quot;admin&quot;&gt;  </div><div class="line">&lt;!— 有权限 —&gt;  </div><div class="line">&lt;/shiro:hasRole&gt;</div></pre></td></tr></table></figure></p>
<h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="基于角色的访问控制（隐式角色）"><a href="#基于角色的访问控制（隐式角色）" class="headerlink" title="基于角色的访问控制（隐式角色）"></a>基于角色的访问控制（隐式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色"><a href="#在ini配置文件配置用户拥有的角色" class="headerlink" title="在ini配置文件配置用户拥有的角色"></a>在ini配置文件配置用户拥有的角色</h3><blockquote>
<p>shiro-role.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则</strong>：<code>“用户名=密码,角色1，角色2”</code>，如果需要在应用中判断用户是否有相应角色，就需要在相应的Realm中返回角色信息；也就是说<code>Shiro不负责维护用户-角色信息</code>，需要应用提供，Shiro只是提供相应的接口方便验证。</p>
</blockquote>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote>
<p>com.github.gojay001.test.RoleTest</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testHasRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有角色：role1</div><div class="line">    Assert.assertTrue(subject().hasRole(&quot;role1&quot;));</div><div class="line">    // 判断拥有角色：role1 and role2</div><div class="line">    Assert.assertTrue(subject().hasAllRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;)));</div><div class="line">    // 判断拥有角色：role1 and role2 and !role3</div><div class="line">    boolean[] result = subject().hasRoles(Arrays.asList(&quot;role1&quot;, &quot;role2&quot;, &quot;role3&quot;));</div><div class="line">    Assert.assertEquals(true, result[0]);</div><div class="line">    Assert.assertEquals(true, result[1]);</div><div class="line">    Assert.assertEquals(false, result[2]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Shiro提供了<code>hasRole/hasAllRoles</code>用于判断用户是否拥有某个角色/某些权限；但是没有提供如hashAnyRole用于判断是否有某些权限中的某一个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckRole() &#123;</div><div class="line">    login(&quot;classpath:shiro-role.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有角色：role1</div><div class="line">    subject().checkRole(&quot;role1&quot;);</div><div class="line">    // 断言拥有角色：role1 and role3 失败抛出异常</div><div class="line">    subject().checkRoles(&quot;role1&quot;, &quot;role3&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Shiro提供的<code>checkRole/checkRoles</code>和<code>hasRole/hasAllRoles</code>不同的地方是它在判断为假的情况下会<code>抛出UnauthorizedException异常</code>。</p>
</blockquote>
<p><strong>基于角色的访问控制</strong>（即隐式角色）的缺点：如果很多地方进行了角色判断，但是有一天不需要了那么就需要修改相应代码把<code>所有相关的地方</code>进行删除；这就是粗粒度造成的问题。</p>
<h2 id="基于资源的访问控制（显式角色）"><a href="#基于资源的访问控制（显式角色）" class="headerlink" title="基于资源的访问控制（显式角色）"></a>基于资源的访问控制（显式角色）</h2><h3 id="在ini配置文件配置用户拥有的角色及角色-权限关系"><a href="#在ini配置文件配置用户拥有的角色及角色-权限关系" class="headerlink" title="在ini配置文件配置用户拥有的角色及角色-权限关系"></a>在ini配置文件配置用户拥有的角色及角色-权限关系</h3><blockquote>
<p>shiro-permission.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">root=root,role1,role2</div><div class="line">gojay=test,role1</div><div class="line">[roles]</div><div class="line">role1=user:create,user:update</div><div class="line">role2=user:create,user:delete</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>规则</strong>：<code>“用户名=密码，角色1，角色2”“角色=权限1，权限2”</code>，即首先根据用户名找到角色，然后根据角色再找到权限；即角色是权限集合；Shiro同样不进行权限的维护，需要我们通过Realm返回相应的权限信息。只需要维护“用户——角色”之间的关系即可。</p>
</blockquote>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><blockquote>
<p>com.github.gojay001.test.PermissionTest</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user:create&quot;));</div><div class="line">    // 判断拥有权限：user:update and user:delete</div><div class="line">    Assert.assertTrue(subject().isPermittedAll(&quot;user:update&quot;, &quot;user:delete&quot;));</div><div class="line">    // 判断没有权限：user:view</div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;user:view&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Shiro提供了<code>isPermitted</code>和<code>isPermittedAll</code>用于判断用户是否拥有某个权限或所有权限，也<code>没有提供如isPermittedAny</code>用于判断拥有某一个权限的接口。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnauthorizedException.class)</div><div class="line">public void testCheckPermission() &#123;</div><div class="line">    login(&quot;classpath:shiro-permission.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 断言拥有权限：user:create</div><div class="line">    subject().checkPermission(&quot;user:create&quot;);</div><div class="line">    // 断言拥有权限：user:delete and user:update</div><div class="line">    subject().checkPermissions(&quot;user:delete&quot;, &quot;user:update&quot;);</div><div class="line">    // 断言拥有权限：user:view 失败抛出异常</div><div class="line">    subject().checkPermissions(&quot;user:view&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>checkPermissions</code>失败的情况下会抛出UnauthorizedException异常。</p>
</blockquote>
<p><strong>基于资源的访问控制</strong>（显式角色），也可以叫基于权限的访问控制，这种方式的一般规则是<code>“资源标识符：操作”</code>，即是资源级别的粒度；这种方式的好处就是如果要修改基本都是一个资源级别的修改，不会对其他模块代码产生影响，粒度小。但是实现起来可能稍微复杂点，需要维护“用户——角色，角色——权限（资源：操作）”之间的关系。 </p>
<h1 id="Permission"><a href="#Permission" class="headerlink" title="Permission"></a>Permission</h1><p><strong>字符串通配符权限</strong><br><strong>规则</strong>：<code>“资源标识符：操作：对象实例ID”</code>  即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>“:”</code>表示资源/操作/实例的分割；<code>“,”</code>表示操作的分割；<code>“*”</code>表示任意资源/操作/实例。</p>
<h2 id="单个资源单个权限"><a href="#单个资源单个权限" class="headerlink" title="单个资源单个权限"></a>单个资源单个权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;);</div></pre></td></tr></table></figure>
<blockquote>
<p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>权限。</p>
</blockquote>
<h2 id="单个资源多个权限"><a href="#单个资源多个权限" class="headerlink" title="单个资源多个权限"></a>单个资源多个权限</h2><p>ini配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role41=system:user:update,system:user:delete</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:update&quot;, &quot;system:user:delete&quot;);</div></pre></td></tr></table></figure></p>
<p>可以简写为：<code>&quot;system:user:update,delete&quot;</code></p>
<blockquote>
<p>用户拥有资源<code>“system:user”</code>的<code>“update”</code>和<code>“delete”</code>权限。</p>
</blockquote>
<h2 id="单个资源全部权限"><a href="#单个资源全部权限" class="headerlink" title="单个资源全部权限"></a>单个资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role51=&quot;system:user:create,update,delete,view&quot;</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;system:user:create,delete,update:view&quot;);</div></pre></td></tr></table></figure></p>
<p>可以简写为：<code>system:user:*</code></p>
<blockquote>
<p>用户拥有资源<code>“system:user”</code>的<code>“create”</code>、<code>“update”</code>、<code>“delete”</code>和<code>“view”</code>所有权限。</p>
</blockquote>
<h2 id="所有资源全部权限"><a href="#所有资源全部权限" class="headerlink" title="所有资源全部权限"></a>所有资源全部权限</h2><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role61=*:view</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>用户拥有所有资源的<code>“view”</code>所有权限。</p>
</blockquote>
<h2 id="实例级别的权限"><a href="#实例级别的权限" class="headerlink" title="实例级别的权限"></a>实例级别的权限</h2><h3 id="单个实例单个权限"><a href="#单个实例单个权限" class="headerlink" title="单个实例单个权限"></a>单个实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role71=user:view:1</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对资源user的1实例拥有view权限。</p>
</blockquote>
<h3 id="单个实例多个权限"><a href="#单个实例多个权限" class="headerlink" title="单个实例多个权限"></a>单个实例多个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role72=&quot;user:update,delete:1&quot;</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:delete,update:1&quot;);  </div><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对资源user的1实例拥有update、delete权限。</p>
</blockquote>
<h3 id="单个实例所有权限"><a href="#单个实例所有权限" class="headerlink" title="单个实例所有权限"></a>单个实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role73=user:*:1</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:update:1&quot;, &quot;user:delete:1&quot;, &quot;user:view:1&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对资源user的1实例拥有所有权限。</p>
</blockquote>
<h3 id="所有实例单个权限"><a href="#所有实例单个权限" class="headerlink" title="所有实例单个权限"></a>所有实例单个权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role74=user:auth:*</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:auth:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对资源user的1实例拥有所有权限。</p>
</blockquote>
<h3 id="所有实例所有权限"><a href="#所有实例所有权限" class="headerlink" title="所有实例所有权限"></a>所有实例所有权限</h3><p>ini配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">role75=user:*:*</div></pre></td></tr></table></figure></p>
<p>通过判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subject().checkPermissions(&quot;user:view:1&quot;, &quot;user:auth:2&quot;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>对资源user的1实例拥有所有权限。</p>
</blockquote>
<h2 id="Shiro对权限字符串缺失部分的处理"><a href="#Shiro对权限字符串缺失部分的处理" class="headerlink" title="Shiro对权限字符串缺失部分的处理"></a>Shiro对权限字符串缺失部分的处理</h2><ul>
<li>如<code>user:view</code> 等价于 <code>user:view:*</code>；<br><code>organization</code> 等价于 <code>organization:*</code> 或者 <code>organization:*:*</code>。<br>可以这么理解，这种方式实现了<strong>前缀匹配</strong>。</li>
<li>如<code>user:*</code> 可以匹配 <code>user:delete</code>；<br><code>user:delete</code> 可以匹配 <code>user:delete:1</code>；<br><code>user:*:1</code> 可以匹配 <code>user:view:1</code>；<br><code>user</code> 可以匹配 <code>user:view</code> 或 <code>user:view:1</code>等。<br>即*可以匹配所有，不加*可以进行前缀匹配；</li>
<li>如<code>*:view</code> 不能匹配 <code>system:user:view</code>；需要使用 <code>*:*:view</code>；<br>即<strong>后缀匹配</strong>必须指定前缀（多个冒号就需要多个*来匹配）。</li>
</ul>
<h2 id="WildcardPermission"><a href="#WildcardPermission" class="headerlink" title="WildcardPermission"></a>WildcardPermission</h2><p>如下两种方式是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subject().checkPermission(&quot;menu:view:1&quot;);  </div><div class="line">subject().checkPermission(new WildcardPermission(&quot;menu:view:1&quot;));</div></pre></td></tr></table></figure></p>
<blockquote>
<p>因此没什么必要的话使用字符串更方便。</p>
</blockquote>
<h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p><code>通配符匹配</code>方式比<code>字符串匹配</code>来说是更复杂的，因此需要花费更长时间，但是一般系统的权限不会太多，且可以配合缓存来提供其性能，如果这样性能还达不到要求我们可以实现位操作算法实现性能更好的权限匹配。另外实例级别的权限验证如果数据量太大也不建议使用，可能造成查询权限及匹配变慢。可以考虑比如在sql查询时加上权限字符串之类的方式在查询时就完成了权限匹配。</p>
<h1 id="授权流程"><a href="#授权流程" class="headerlink" title="授权流程"></a>授权流程</h1><p><img src="/2017/11/23/跟我学Shiro（三）-授权/3-1.png" alt="跟我学Shiro（三）-授权/3-1.png"></p>
<h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote>
<ol>
<li>首先调用<code>Subject.isPermitted*/hasRole*</code>接口，其会委托给SecurityManager，而<code>SecurityManager</code>接着会委托给<code>Authorizer</code>；</li>
<li><code>Authorizer</code>是真正的授权者；如果我们调用如<code>isPermitted(“user:view”)</code>，其首先会通过<code>PermissionResolver</code>把字符串转换成相应的<code>Permission实例</code>；</li>
<li>在进行授权之前，其会<code>调用相应的Realm</code>获取Subject相应的<code>角色/权限</code>用于匹配传入的角色/权限；</li>
<li><code>Authorizer</code>会<code>判断</code>Realm的角色/权限是否和传入的<code>匹配</code>，如果有<code>多个Realm</code>，会委托给<code>ModularRealmAuthorizer</code>进行循环判断，如果匹配如isPermitted<em>/hasRole</em>会返回true，否则返回false表示授权失败。</li>
</ol>
</blockquote>
<ul>
<li>ModularRealmAuthorizer进行多Realm匹配流程：</li>
</ul>
<blockquote>
<ol>
<li>首先检查相应的<code>Realm</code>是否实现了<code>Authorizer</code>；</li>
<li>如果实现了Authorizer，那么接着调用其相应的<code>isPermitted*/hasRole*接口</code>进行匹配；</li>
<li>如果有一个<code>Realm匹配</code>那么将返回true，否则返回false。</li>
</ol>
</blockquote>
<ul>
<li>如果Realm进行授权的话，应该继承AuthorizingRealm，其流程是：</li>
</ul>
<blockquote>
<ol>
<li>如果调用<code>hasRole*</code>，则直接获取<code>AuthorizationInfo.getRoles()</code>与传入的角色比较即可；</li>
<li>如果调用如<code>isPermitted(“user:view”)</code>，首先通过<code>PermissionResolver</code>将权限字符串转换成相应的<code>Permission实例</code>，默认使用<code>WildcardPermissionResolver</code>，即转换为通配符的<code>WildcardPermission</code>；</li>
<li>通过<code>AuthorizationInfo.getObjectPermissions()</code>得到<code>Permission实例集合</code>；通过<code>AuthorizationInfo. getStringPermissions()</code>得到字符串集合并通过PermissionResolver解析为<code>Permission实例</code>；然后获取用户的角色，并通过<code>RolePermissionResolver</code>解析角色对应的<code>权限集合</code>（默认没有实现，可以自己提供）；</li>
<li>接着调用<code>Permission. implies(Permission p)</code>逐个与传入的权限比较，如果有<code>匹配</code>的则返回true，否则false。</li>
</ol>
</blockquote>
<h1 id="Authorizer"><a href="#Authorizer" class="headerlink" title="Authorizer"></a>Authorizer</h1><p><strong>Authorizer</strong>的职责是进行授权（访问控制），提供了相应的角色/权限判断接口。<code>SecurityManager</code>继承了<code>Authorizer接口</code>，且提供了<code>ModularRealmAuthorizer</code>用于多Realm时的授权匹配。<br><strong>PermissionResolver</strong>用于解析权限字符串到Permission实例。<br><strong>RolePermissionResolver</strong>用于根据角色解析相应的权限集合。</p>
<ul>
<li><p>可以通过如下ini配置更改<code>Authorizer</code>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer  </div><div class="line">securityManager.authorizer=$authorizer</div></pre></td></tr></table></figure>
</li>
<li><p>设置<code>ModularRealmAuthorizer</code>的<code>permissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>PermissionResolverAware</code>接口），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver  </div><div class="line">authorizer.permissionResolver=$permissionResolver</div></pre></td></tr></table></figure>
</li>
<li><p>设置<code>ModularRealmAuthorizer</code>的<code>rolePermissionResolver</code>，其会自动设置到相应的Realm上（其实现了<code>RolePermissionResolverAware</code>接口），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver  </div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote>
<p>shiro-jdbc-authorizer.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#自定义authorizer</div><div class="line">authorizer=org.apache.shiro.authz.ModularRealmAuthorizer</div><div class="line">#自定义permissionResolver</div><div class="line">#permissionResolver=org.apache.shiro.authz.permission.WildcardPermissionResolver</div><div class="line">permissionResolver=com.github.gojay001.permission.BitAndWildPermissionResolver</div><div class="line">authorizer.permissionResolver=$permissionResolver</div><div class="line">#自定义rolePermissionResolver</div><div class="line">rolePermissionResolver=com.github.gojay001.permission.MyRolePermissionResolver</div><div class="line">authorizer.rolePermissionResolver=$rolePermissionResolver</div><div class="line"></div><div class="line">securityManager.authorizer=$authorizer</div><div class="line"></div><div class="line">#自定义realm 一定要放在securityManager.authorizer赋值之后</div><div class="line">#因为调用setRealms会将realms设置给authorizer，并给各个Realm设置permissionResolver和rolePermissionResolver</div><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm</div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource</div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver</div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro</div><div class="line">dataSource.username=root</div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource</div><div class="line">jdbcRealm.permissionsLookupEnabled=true</div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure>
<blockquote>
<p>不能使用<code>IniSecurityManagerFactory</code>创建的<code>IniRealm</code>，因为其初始化顺序的问题可能造成后续的初始化Permission造成影响。</p>
</blockquote>
<h3 id="定义BitAndWildPermissionResolver及BitPermission"><a href="#定义BitAndWildPermissionResolver及BitPermission" class="headerlink" title="定义BitAndWildPermissionResolver及BitPermission"></a>定义BitAndWildPermissionResolver及BitPermission</h3><blockquote>
<p><strong>BitPermission</strong>用于实现位移方式的权限，如规则是：<br>权限字符串格式：<code>+资源字符串+权限位+实例ID</code>；以+开头中间通过+分割；权限：<code>0 表示所有权限</code>；<code>1 新增</code>（二进制：0001）、<code>2 修改</code>（二进制：0010）、<code>4 删除</code>（二进制：0100）、<code>8 查看</code>（二进制：1000）；如 <code>+user+10</code> 表示对资源user拥有<code>修改/查看</code>权限。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class BitPermission implements Permission &#123;</div><div class="line">    private String resourceIdentify;</div><div class="line">    private int permissionBit;</div><div class="line">    private String instanceId;</div><div class="line"></div><div class="line">    public BitPermission(String permissionString) &#123;</div><div class="line">        String[] array = permissionString.split(&quot;\\+&quot;);</div><div class="line"></div><div class="line">        if (array.length &gt; 1) &#123;</div><div class="line">            resourceIdentify = array[1];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(resourceIdentify)) &#123;</div><div class="line">            resourceIdentify = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 2) &#123;</div><div class="line">            permissionBit = Integer.valueOf(array[2]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (array.length &gt; 3) &#123;</div><div class="line">            instanceId = array[3];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (StringUtils.isEmpty(instanceId)) &#123;</div><div class="line">            instanceId = &quot;*&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean implies(Permission permission) &#123;</div><div class="line">        if(!(permission instanceof BitPermission)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        BitPermission other = (BitPermission) permission;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.resourceIdentify) || this.resourceIdentify.equals(other.resourceIdentify))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(this.permissionBit ==0 || (this.permissionBit &amp; other.permissionBit) != 0)) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if(!(&quot;*&quot;.equals(this.instanceId) || this.instanceId.equals(other.instanceId))) &#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;BitPermission&#123;&quot; +</div><div class="line">                &quot;resourceIdentify=&apos;&quot; + resourceIdentify + &apos;\&apos;&apos; +</div><div class="line">                &quot;, permissionBit=&quot; + permissionBit +</div><div class="line">                &quot;, instanceId=&apos;&quot; + instanceId + &apos;\&apos;&apos; +</div><div class="line">                &apos;&#125;&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Permission接口</strong>提供了<code>boolean implies(Permission p)方法</code>用于判断权限匹配的；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class BitAndWildPermissionResolver implements PermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Permission resolvePermission(String permissionString) &#123;  </div><div class="line">        if(permissionString.startsWith(&quot;+&quot;)) &#123;  </div><div class="line">            return new BitPermission(permissionString);  </div><div class="line">        &#125;  </div><div class="line">        return new WildcardPermission(permissionString);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>BitAndWildPermissionResolver</strong>实现了<code>PermissionResolver接口</code>，并根据权限字符串是否以“+”开头来解析权限字符串为BitPermission或WildcardPermission。</p>
<h3 id="定义MyRolePermissionResolver"><a href="#定义MyRolePermissionResolver" class="headerlink" title="定义MyRolePermissionResolver"></a>定义MyRolePermissionResolver</h3><p><strong>RolePermissionResolver</strong>用于根据角色字符串来解析得到权限集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MyRolePermissionResolver implements RolePermissionResolver &#123;  </div><div class="line">    @Override  </div><div class="line">    public Collection&lt;Permission&gt; resolvePermissionsInRole(String roleString) &#123;  </div><div class="line">        if(&quot;role1&quot;.equals(roleString)) &#123;  </div><div class="line">            return Arrays.asList((Permission)new WildcardPermission(&quot;menu:*&quot;));  </div><div class="line">        &#125;  </div><div class="line">        return null;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="自定义Realm"><a href="#自定义Realm" class="headerlink" title="自定义Realm"></a>自定义Realm</h3><p>使用<strong>JdbcRealm</strong>，需要做的操作如下：</p>
<ul>
<li>执行<code>sql/shiro-init-data.sql</code> 插入相关的权限数据；</li>
<li>使用<code>shiro-jdbc-authorizer.ini配置文件</code>，需要<code>设置jdbcRealm.permissionsLookupEnabled为true</code>来开启权限查询。</li>
</ul>
<blockquote>
<p>这里也可以自定义实现Realm，可参考com.github.gojay001.realm.MyRealm</p>
</blockquote>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testIsPermitted2() &#123;</div><div class="line">    login(&quot;classpath:shiro-jdbc-authorizer.ini&quot;, &quot;root&quot;, &quot;root&quot;);</div><div class="line">    // 判断拥有权限：user:create</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user1:update&quot;));</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;user2:update&quot;));</div><div class="line">    // 通过二进制位的方式表示权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+2&quot;));// 新增权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user1+8&quot;));// 查看权限</div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;+user2+10&quot;));// 新增及查看</div><div class="line"></div><div class="line">    Assert.assertFalse(subject().isPermitted(&quot;+user1+4&quot;));// 没有删除权限</div><div class="line"></div><div class="line">    Assert.assertTrue(subject().isPermitted(&quot;menu:view&quot;));// 通过MyRolePermissionResolver解析得到的权限</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="授权流程-1"><a href="#授权流程-1" class="headerlink" title="授权流程"></a>授权流程</h2><ul>
<li>Subject.isPermitted*/hasRole*</li>
<li>SecurityManager</li>
<li>Authorizer</li>
<li>PermissionResolver/RolePermissionResolver/Permission</li>
<li>Realm</li>
</ul>
<h2 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h2><ul>
<li>user</li>
<li>role</li>
<li>permission</li>
</ul>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><ul>
<li>Authorizer</li>
<li>PermissionResolver</li>
<li>RolePermissionResolver</li>
<li>Realm</li>
</ul>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><ul>
<li>hasRole/hasAllRoles</li>
<li>checkRole/checkRoles</li>
<li>isPermitted/isPermittedAll</li>
<li>checkPermission/checkPermissions</li>
</ul>
<blockquote>
<p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter3</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Shiro </tag>
            
            <tag> 授权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（二）-身份认证]]></title>
      <url>/2017/11/22/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%BA%8C%EF%BC%89-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>身份验证</strong>：在应用中能<code>证明他就是他本人</code>。一般提供一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>在 shiro 中，用户需要提供 <code>principals</code> （身份）和 <code>credentials</code>（证明）给 shiro，从而应用能验证用户身份。  </p>
<ul>
<li><strong>principals</strong>：身份；即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个 principals，但<code>只有一个 Primary principals</code>，一般是用户名/密码/手机号。 </li>
<li><strong>credentials</strong>：证明/凭证；即只有主体知道的安全值，如密码/数字证书等。   </li>
</ul>
<blockquote>
<p>最常见的 principals 和 credentials 组合就是<code>用户名/密码</code>了。<br>另外两个相关的概念是之前提到的 <code>Subject</code> 及 <code>Realm</code>，分别是主体及验证主体的数据源。</p>
</blockquote>
<a id="more"></a>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="使用Maven构建"><a href="#使用Maven构建" class="headerlink" title="使用Maven构建"></a>使用Maven构建</h2><p>准备环境依赖：添加 <code>junit</code>、<code>common-logging</code> 及 <code>shiro-core</code> 依赖；</p>
<blockquote>
<p><strong>更新</strong>：加入slf4j-nop依赖包。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;dependencies&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;4.12&lt;/version&gt;</div><div class="line">        &lt;scope&gt;test&lt;/scope&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;commons-logging&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.2&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.4.0&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">    &lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;1.7.25&lt;/version&gt;</div><div class="line">    &lt;/dependency&gt;</div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure>
<h1 id="登录-退出"><a href="#登录-退出" class="headerlink" title="登录/退出"></a>登录/退出</h1><h2 id="准备一些用户身份-凭据"><a href="#准备一些用户身份-凭据" class="headerlink" title="准备一些用户身份/凭据"></a>准备一些用户身份/凭据</h2><blockquote>
<p>shiro.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[users]</div><div class="line">gojay=test</div><div class="line">root=root</div></pre></td></tr></table></figure>
<p>此处使用ini配置文件，通过<code>[user]</code>指定两个主体。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><blockquote>
<p>com.github.gojay001.test.LoginLogoutTest<br><strong>更新</strong>：注意类过时。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Test</div><div class="line">public void testLoginLogout() &#123;</div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</div><div class="line">    Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory(&quot;classpath:shiro.ini&quot;);</div><div class="line"></div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils</div><div class="line">    SecurityManager securityManager = factory.getInstance();</div><div class="line">    SecurityUtils.setSecurityManager(securityManager);</div><div class="line"></div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）</div><div class="line">    Subject subject = SecurityUtils.getSubject();</div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        //4、登录，即身份验证</div><div class="line">        subject.login(token);</div><div class="line">    &#125; catch (AuthenticationException e) &#123;</div><div class="line">        //5、身份验证失败</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Assert.assertEquals(true, subject.isAuthenticated());</div><div class="line"></div><div class="line">    //6、退出</div><div class="line">    subject.logout();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先通过new IniSecurityManagerFactory并指定一个ini配置文件来<code>创建一个SecurityManager工厂</code>；</li>
<li>接着<code>获取SecurityManager并绑定到SecurityUtils</code>，这是一个全局设置，设置一次即可；</li>
<li>通过SecurityUtils<code>得到Subject</code>，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后<code>获取身份验证的Token</code>，如用户名/密码；</li>
<li><code>调用subject.login方法</code>进行登录，其会自动委托给SecurityManager.login方法进行登录；</li>
<li><code>如果身份验证失败捕获AuthenticationException或其子类</code>，常见的如： <code>DisabledAccountException</code>（禁用的帐号）、<code>LockedAccountException</code>（锁定的帐号）、<code>UnknownAccountException</code>（错误的帐号）、<code>ExcessiveAttemptsException</code>（登录失败次数过多）、<code>IncorrectCredentialsException</code> （错误的凭证）、<code>ExpiredCredentialsException</code>（过期的凭证）等，具体查看其继承关系；</li>
<li>最后可以<code>调用subject.logout退出</code>，其会自动委托给SecurityManager.logout方法退出。</li>
</ul>
<h2 id="总结步骤"><a href="#总结步骤" class="headerlink" title="总结步骤"></a>总结步骤</h2><blockquote>
<ol>
<li>收集用户身份/凭证，即如用户名/密码；</li>
<li>调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功；</li>
<li>最后调用Subject.logout进行退出操作。</li>
</ol>
</blockquote>
<h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><blockquote>
<ol>
<li><code>用户名/密码硬编码</code>在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储；</li>
<li><code>用户身份Token</code>可能不仅仅是用户名/密码，也可能<code>还有其他的</code>，如登录时允许用户名/邮箱/手机号同时登录。 </li>
</ol>
</blockquote>
<h1 id="身份认证流程"><a href="#身份认证流程" class="headerlink" title="身份认证流程"></a>身份认证流程</h1><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-1.png" alt="跟我学Shiro（二）-身份认证/2-1.png"></p>
<h2 id="流程如下："><a href="#流程如下：" class="headerlink" title="流程如下："></a>流程如下：</h2><blockquote>
<ol>
<li>首先<code>调用Subject.login(token)</code>进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；</li>
<li><code>SecurityManager</code>负责真正的身份验证逻辑；它会<code>委托给Authenticator进行身份验证</code>；</li>
<li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处<code>可以自定义插入自己的实现</code>；</li>
<li>Authenticator可能会委托给相应的AuthenticationStrategy<code>进行多Realm身份验证</code>，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；</li>
<li>Authenticator会<code>把相应的token传入Realm，从Realm获取身份验证信息</code>，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li>
</ol>
</blockquote>
<h1 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h1><p><strong>Realm</strong>：域；Shiro从Realm获取安全数据（如用户、角色、权限），可以把Realm看成DataSource，即<code>安全数据源</code>。</p>
<p>org.apache.shiro.realm.Realm接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String getName(); //返回一个唯一的Realm名字  </div><div class="line">boolean supports(AuthenticationToken token); //判断此Realm是否支持此Token  </div><div class="line">AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException;  //根据Token获取认证信息</div></pre></td></tr></table></figure></p>
<h2 id="单Realm配置"><a href="#单Realm配置" class="headerlink" title="单Realm配置"></a>单Realm配置</h2><h3 id="自定义Realm实现"><a href="#自定义Realm实现" class="headerlink" title="自定义Realm实现"></a>自定义Realm实现</h3><blockquote>
<p>com.github.gojay001.realm.MyRealm1</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> public class MyRealm1 implements Realm &#123;</div><div class="line">    public String getName() &#123;</div><div class="line">        return &quot;myRealm1&quot;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public boolean supports(AuthenticationToken authenticationToken) &#123;</div><div class="line">        return authenticationToken instanceof UsernamePasswordToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public AuthenticationInfo getAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123;</div><div class="line">        // 得到用户名</div><div class="line">        String username = (String)authenticationToken.getPrincipal();</div><div class="line">        // 得到密码</div><div class="line">        String password = new String((char[])authenticationToken.getCredentials());</div><div class="line">        if(!&quot;root&quot;.equals(username)) &#123;</div><div class="line">            //用户名错误</div><div class="line">            throw new UnknownAccountException();</div><div class="line">        &#125;</div><div class="line">        if(!&quot;root&quot;.equals(password)) &#123;</div><div class="line">            //密码错误</div><div class="line">            throw new IncorrectCredentialsException();</div><div class="line">        &#125;</div><div class="line">        //如果身份认证验证成功，返回一个AuthenticationInfo实现；</div><div class="line">        return new SimpleAuthenticationInfo(username, password, getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ini配置文件指定自定义Realm实现"><a href="#ini配置文件指定自定义Realm实现" class="headerlink" title="ini配置文件指定自定义Realm实现"></a>ini配置文件指定自定义Realm实现</h3><blockquote>
<p>shiro-realm.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#声明一个realm</div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">#指定securityManager的realms实现</div><div class="line">securityManager.realms=$myRealm1</div></pre></td></tr></table></figure>
<p>通过$name来引入之前的realm定义。</p>
<h2 id="多Realm配置"><a href="#多Realm配置" class="headerlink" title="多Realm配置"></a>多Realm配置</h2><h3 id="ini配置文件"><a href="#ini配置文件" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote>
<p>shiro-multi-realm.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#声明一个realm  </div><div class="line">myRealm1=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm1  </div><div class="line">myRealm2=com.github.zhangkaitao.shiro.chapter2.realm.MyRealm2  </div><div class="line">#指定securityManager的realms实现  </div><div class="line">securityManager.realms=$myRealm1,$myRealm2</div></pre></td></tr></table></figure>
<p>securityManager会按照realms指定的顺序进行身份认证。</p>
<h2 id="Shiro默认提供的Realm"><a href="#Shiro默认提供的Realm" class="headerlink" title="Shiro默认提供的Realm"></a>Shiro默认提供的Realm</h2><p><img src="/2017/11/22/跟我学Shiro（二）-身份认证/2-2.png" alt="跟我学Shiro（二）-身份认证/2-2.png"></p>
<p>以后一般继承<code>AuthorizingRealm</code>（授权）即可；其继承了<code>AuthenticatingRealm</code>（即身份验证），而且也间接继承了<code>CachingRealm</code>（带有缓存实现）。<br>其中主要默认实现如下：</p>
<ul>
<li><strong>org.apache.shiro.realm.text.IniRealm</strong>：<code>[users]部分</code>指定用户名/密码及其角色；<code>[roles]部分</code>指定角色即权限信息；</li>
<li><strong>org.apache.shiro.realm.text.PropertiesRealm</strong>： <code>user.username=password,role1,role2</code>指定用户名/密码及其角色；<code>role.role1=permission1,permission2</code>指定角色及权限信息；</li>
<li><strong>org.apache.shiro.realm.jdbc.JdbcRealm</strong>：通过sql查询相应的信息，如<code>“select password from users where username = ?”</code>获取用户密码，<code>“select role_name from user_roles where username = ?”</code>获取用户角色；<code>“select permission from roles_permissions where role_name = ?”</code>获取角色对应的权限信息；也可以调用相应的api进行自定义sql；</li>
</ul>
<h2 id="JDBC-Realm使用"><a href="#JDBC-Realm使用" class="headerlink" title="JDBC Realm使用"></a>JDBC Realm使用</h2><h3 id="数据库及依赖"><a href="#数据库及依赖" class="headerlink" title="数据库及依赖"></a>数据库及依赖</h3><blockquote>
<p><strong>更新</strong>：alibaba的druid包更新版本。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;6.0.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.1.5&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>本文将使用mysql数据库及druid连接池。</p>
<h3 id="数据库下建表"><a href="#数据库下建表" class="headerlink" title="数据库下建表"></a>数据库下建表</h3><p><code>users</code>（用户名/密码）、<code>user_roles</code>（用户/角色）、<code>roles_permissions</code>（角色/权限）；<br>具体请参照sql/shiro.sql；并添加一个用户记录，用户名/密码为root/root。</p>
<h3 id="ini配置"><a href="#ini配置" class="headerlink" title="ini配置"></a>ini配置</h3><blockquote>
<p>shiro-jdbc-realm.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">jdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm  </div><div class="line">dataSource=com.alibaba.druid.pool.DruidDataSource  </div><div class="line">dataSource.driverClassName=com.mysql.jdbc.Driver  </div><div class="line">dataSource.url=jdbc:mysql://localhost:3306/shiro  </div><div class="line">dataSource.username=root  </div><div class="line">dataSource.password=root</div><div class="line">jdbcRealm.dataSource=$dataSource  </div><div class="line">securityManager.realms=$jdbcRealm</div></pre></td></tr></table></figure>
<ol>
<li><code>变量名=全限定类名</code> 自动创建一个类实例</li>
<li><code>变量名.属性=值</code> 自动调用相应的setter方法进行赋值</li>
<li><code>$变量名</code> 引用之前的一个对象实例 </li>
<li><code>测试代码</code>和之前的没什么区别。</li>
</ol>
<h1 id="Authenticator及AuthenticationStrategy"><a href="#Authenticator及AuthenticationStrategy" class="headerlink" title="Authenticator及AuthenticationStrategy"></a>Authenticator及AuthenticationStrategy</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>Authenticator</strong>的职责是验证用户帐号，<br>是Shiro API中身份验证核心的入口点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public AuthenticationInfo authenticate(AuthenticationToken authenticationToken) throws AuthenticationException;</div></pre></td></tr></table></figure></p>
<p>如果验证成功，将返回AuthenticationInfo验证信息，此信息中包含了身份及凭证；<br>如果验证失败将抛出相应的AuthenticationException实现。</p>
<p><strong>SecurityManager</strong>接口继承了Authenticator，另外还有一个<code>ModularRealmAuthenticator实现</code>，其委托给多个Realm进行验证，验证规则通过<code>AuthenticationStrategy接口</code>指定，默认提供的实现：</p>
<ul>
<li><strong>FirstSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，<code>只返回第一个Realm</code>身份验证成功的认证信息，其他的忽略；</li>
<li><strong>AtLeastOneSuccessfulStrategy</strong>：只要有<code>一个Realm验证成功</code>即可，和FirstSuccessfulStrategy不同，<code>返回所有Realm</code>身份验证成功的认证信息；</li>
<li><strong>AllSuccessfulStrategy</strong>：<code>所有Realm验证成功</code>才算成功，且<code>返回所有Realm</code>身份验证成功的认证信息，如果有一个失败就失败了。<blockquote>
<p><code>ModularRealmAuthenticator</code>默认使用<code>AtLeastOneSuccessfulStrategy</code>策略。</p>
</blockquote>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote>
<p>假设有三个realm：<br>myRealm1： 用户名/密码为root/root时成功，且返回身份/凭据为root/root；<br>myRealm2： 用户名/密码为gojay/test时成功，且返回身份/凭据为gojay/test；<br>myRealm3： 用户名/密码为root/root时成功，且返回身份/凭据为root@foxmail.com/root；</p>
</blockquote>
<h3 id="ini配置文件-1"><a href="#ini配置文件-1" class="headerlink" title="ini配置文件"></a>ini配置文件</h3><blockquote>
<p>shiro-authenticator-all-success.ini</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[main]</div><div class="line">#指定securityManager的authenticator实现</div><div class="line">authenticator=org.apache.shiro.authc.pam.ModularRealmAuthenticator</div><div class="line">securityManager.authenticator=$authenticator</div><div class="line"></div><div class="line">#指定securityManager.authenticator的authenticationStrategy</div><div class="line">allSuccessfulStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy</div><div class="line">securityManager.authenticator.authenticationStrategy=$allSuccessfulStrategy</div><div class="line"></div><div class="line">myRealm1=com.github.gojay001.realm.MyRealm1</div><div class="line">myRealm2=com.github.gojay001.realm.MyRealm2</div><div class="line">myRealm3=com.github.gojay001.realm.MyRealm3</div><div class="line">securityManager.realms=$myRealm1,$myRealm3</div></pre></td></tr></table></figure>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><blockquote>
<p>com.github.gojay001.test.AuthenticatorTest</p>
</blockquote>
<h4 id="首先通用化登录逻辑"><a href="#首先通用化登录逻辑" class="headerlink" title="首先通用化登录逻辑"></a>首先通用化登录逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private void login(String configFile) &#123;  </div><div class="line">    //1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager  </div><div class="line">    Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory =  </div><div class="line">            new IniSecurityManagerFactory(configFile);  </div><div class="line">  </div><div class="line">    //2、得到SecurityManager实例 并绑定给SecurityUtils  </div><div class="line">    org.apache.shiro.mgt.SecurityManager securityManager = factory.getInstance();  </div><div class="line">    SecurityUtils.setSecurityManager(securityManager);  </div><div class="line">  </div><div class="line">    //3、得到Subject及创建用户名/密码身份验证Token（即用户身份/凭证）  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">    UsernamePasswordToken token = new UsernamePasswordToken(&quot;root&quot;, &quot;root&quot;);  </div><div class="line">  </div><div class="line">    subject.login(token);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试AllSuccessfulStrategy成功"><a href="#测试AllSuccessfulStrategy成功" class="headerlink" title="测试AllSuccessfulStrategy成功"></a>测试AllSuccessfulStrategy成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Test  </div><div class="line">public void testAllSuccessfulStrategyWithSuccess() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-success.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">  </div><div class="line">    //得到一个身份集合，其包含了Realm验证成功的身份信息  </div><div class="line">    PrincipalCollection principalCollection = subject.getPrincipals();  </div><div class="line">    Assert.assertEquals(2, principalCollection.asList().size());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="测试AllSuccessfulStrategy失败"><a href="#测试AllSuccessfulStrategy失败" class="headerlink" title="测试AllSuccessfulStrategy失败"></a>测试AllSuccessfulStrategy失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Test(expected = UnknownAccountException.class)  </div><div class="line">public void testAllSuccessfulStrategyWithFail() &#123;  </div><div class="line">    login(&quot;classpath:shiro-authenticator-all-fail.ini&quot;);  </div><div class="line">    Subject subject = SecurityUtils.getSubject();  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>shiro-authenticator-all-fail.ini</code> 与 <code>shiro-authenticator-all-success.ini</code> 不同的配置是使用了 <code>securityManager.realms=$myRealm1,$myRealm2</code> ；即myRealm验证失败。</p>
<p> 对于 <code>AtLeastOneSuccessfulStrategy</code> 和 <code>FirstSuccessfulStrategy</code> 的区别：唯一不同点一个是<code>返回所有</code>验证成功的Realm的认证信息；另一个是<code>只返回第一个</code>验证成功的Realm的认证信息.<code>示例代码同上</code></p>
</blockquote>
<h3 id="自定义AuthenticationStrategy实现"><a href="#自定义AuthenticationStrategy实现" class="headerlink" title="自定义AuthenticationStrategy实现"></a>自定义AuthenticationStrategy实现</h3><p>首先看其API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//在所有Realm验证之前调用  </div><div class="line">AuthenticationInfo beforeAllAttempts(  </div><div class="line">Collection&lt;? extends Realm&gt; realms, AuthenticationToken token)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之前调用  </div><div class="line">AuthenticationInfo beforeAttempt(  </div><div class="line">Realm realm, AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;  </div><div class="line">//在每个Realm之后调用  </div><div class="line">AuthenticationInfo afterAttempt(  </div><div class="line">Realm realm, AuthenticationToken token,   </div><div class="line">AuthenticationInfo singleRealmInfo, AuthenticationInfo aggregateInfo, Throwable t)  </div><div class="line">throws AuthenticationException;  </div><div class="line">//在所有Realm之后调用  </div><div class="line">AuthenticationInfo afterAllAttempts(  </div><div class="line">AuthenticationToken token, AuthenticationInfo aggregate)   </div><div class="line">throws AuthenticationException;</div></pre></td></tr></table></figure></p>
<p>因为每个<code>AuthenticationStrategy</code>实例都是无状态的，所有每次都通过接口将相应的认证信息传入下一次流程；<br>通过如上接口可以进行如合并/返回第一个验证成功的认证信息。<br>自定义实现时一般<code>继承 org.apache.shiro.authc.pam.AbstractAuthenticationStrategy</code> 即可。<code>参考代码同上</code></p>
<blockquote>
<p>到此基本的身份验证就结束了。</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="Assert过时"><a href="#Assert过时" class="headerlink" title="Assert过时"></a>Assert过时</h3><blockquote>
<p><strong>Assert in junit.framework has been deprecated</strong><br><strong>解决</strong>：将 <code>import junit.framework.Assert;</code> 改为 <code>import org.junit.Assert;</code> </p>
</blockquote>
<h3 id="SLF4J加载失败"><a href="#SLF4J加载失败" class="headerlink" title="SLF4J加载失败"></a>SLF4J加载失败</h3><blockquote>
<p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”<br><strong>解决</strong>：Maven引入slf4j-nop包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.7.6&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="implements不需要-Override"><a href="#implements不需要-Override" class="headerlink" title="implements不需要@Override"></a>implements不需要@Override</h3><h3 id="alibaba的druid版本更新"><a href="#alibaba的druid版本更新" class="headerlink" title="alibaba的druid版本更新"></a>alibaba的druid版本更新</h3><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="用户登录流程"><a href="#用户登录流程" class="headerlink" title="用户登录流程"></a>用户登录流程</h3><ul>
<li>Subject.login(token)</li>
<li>SecurityManager</li>
<li>Authenticator</li>
<li>AuthenticatorStrategy</li>
<li>Realm</li>
</ul>
<h3 id="Realm-1"><a href="#Realm-1" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>单Realm</li>
<li>多Realm</li>
<li>JDBCRealm</li>
</ul>
<h3 id="AuthenticatorStrategy"><a href="#AuthenticatorStrategy" class="headerlink" title="AuthenticatorStrategy"></a>AuthenticatorStrategy</h3><ul>
<li>FirstSuccessfulStrategy</li>
<li>AtLeastOneSuccessfulStrategy</li>
<li>AllSuccessfulStrategy</li>
<li>自定义Strategy</li>
</ul>
<blockquote>
<p>参考代码：<a href="https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2" target="_blank" rel="external">https://github.com/Gojay001/Demo/tree/master/ShiroTest/ShiroTest-chapter2</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Shiro </tag>
            
            <tag> 身份认证 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跟我学Shiro（一）-Shiro简介]]></title>
      <url>/2017/11/19/%E8%B7%9F%E6%88%91%E5%AD%A6Shiro%EF%BC%88%E4%B8%80%EF%BC%89-Shiro%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h2><ul>
<li>Apache Shiro是Java的一个安全框架。  </li>
<li>对比<code>Spring Security</code>小而简单。  </li>
<li>可同时用在JavaSE、JavaEE环境中。  </li>
<li>主要完成认证、授权、加密、会话管理、与Web集成、缓存等。</li>
</ul>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-1.png" alt="跟我学Shiro（一）-Shiro简介/1-1.png"></p>
<ul>
<li><strong>Authentication</strong>：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li><strong>Authorization</strong>：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；</li>
<li><strong>Session Manager</strong>：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；</li>
<li><strong>Cryptography</strong>：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li><strong>Web Support</strong>：Web 支持，可以非常容易的集成到 Web 环境；</li>
<li><strong>Concurrency</strong>：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li><strong>Testing</strong>：提供测试支持；</li>
<li><strong>Run As</strong>：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li><strong>Remember Me</strong>：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<blockquote>
<p>Shiro不会去维护用户、维护权限；这些需要自己设计提供，然后通过相应的接口注入给Shiro。</p>
</blockquote>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="从外部看Shiro："><a href="#从外部看Shiro：" class="headerlink" title="从外部看Shiro："></a>从外部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-2.png" alt="跟我学Shiro（一）-Shiro简介/1-2.png"></p>
<ul>
<li><strong>Subject</strong>：主体；代表了与当前应用交互的用户，如网络爬虫、机器人等；所有 <code>Subject</code> 都绑定到 <code>SecurityManager</code>，与 <code>Subject</code> 的所有交互都会委托给 <code>SecurityManager</code>；可以把 <code>Subject</code> 认为是一个门面，<code>SecurityManager</code> 才是实际的执行者；</li>
<li><strong>SecurityManager</strong>：安全管理器；即所有与安全有关的操作都会与 <code>SecurityManager</code> 交互，且它管理着所有 <code>Subject</code>；它是 Shiro 的核心，负责与其他组件进行交互，可以把它看成<code>Spring NVC</code>中的 <code>DispatcherServlet</code> 前端控制器；</li>
<li><strong>Realm</strong>：域；<code>Shiro</code> 从 <code>Realm</code> 获取安全数据（如用户、角色、权限），就是说 <code>SecurityManager</code> 要验证用户身份，那么它需要从 <code>Realm</code> 获取相应的用户进行比较以确定用户身份是否合法；也需要从 <code>Realm</code> 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把 Realm 看成 <code>DataSource</code>，即安全数据源。</li>
</ul>
<blockquote>
<p>最简单的一个 Shiro 应用：</p>
<ul>
<li>应用代码通过 <code>Subject</code> 来进行认证和授权，而 <code>Subject</code> 又委托给 <code>SecurityManager</code>；</li>
<li>我们需要给 Shiro 的 <code>SecurityManager</code> 注入 <code>Realm</code>，从而让 <code>SecurityManager</code> 能得到合法的用户及其权限进行判断。</li>
<li>可以看出：Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。</li>
</ul>
</blockquote>
<h3 id="从内部看Shiro："><a href="#从内部看Shiro：" class="headerlink" title="从内部看Shiro："></a>从内部看Shiro：</h3><p><img src="/2017/11/19/跟我学Shiro（一）-Shiro简介/1-3.png" alt="跟我学Shiro（一）-Shiro简介/1-3.png"></p>
<ul>
<li><strong>Subject</strong>：主体；可以看到主体可以是任何可以与应用交互的“用户”；</li>
<li><strong>SecurityManager</strong> ：安全管理器；所有具体的交互都通过 <code>SecurityManager</code> 进行控制；它管理着所有 <code>Subject</code>，且负责进行认证和授权、及会话、缓存的管理，是Shiro的心脏；</li>
<li><strong>Authenticator</strong>：认证器；负责主体认证的，这是一个扩展点，如果用户觉得 Shiro 默认的不好，可以自定义实现；其需要认证策略<code>Authentication Strategy</code>，即什么情况下算用户认证通过了； </li>
<li><strong>Authrizer</strong>：授权器；用来决定主体是否有权限进行相应的操作，即控制着用户能访问应用中的哪些功能；</li>
<li><strong>Realm</strong>：可以有 1 个或多个 <code>Realm</code>，可以认为是安全实体数据源，即用于获取安全实体的，由用户提供；Shiro 不知道用户/权限存储在哪及以何种格式存储，所以我们一般在应用中都需要实现自己的 <code>Realm</code>；</li>
<li><strong>SessionManager</strong>：Session需要有人去管理它的生命周期，这个组件就是<code>SessionManager</code>；Shiro 抽象了一个自己的 Session 来管理主体与应用之间交互的数据；这样的话，比如我们在 Web 环境用，刚开始是一台 Web 服务器；接着又上了台 EJB 服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到 Memcached 服务器）；</li>
<li><strong>SessionDAO</strong>：数据访问对象<code>DAO</code>，用于会话的 CRUD，比如我们想把 Session 保存到数据库，那么可以实现自己的 SessionDAO，通过如JDBC写到数据库；比如想把 <code>Session</code> 放到<code>Memcached</code>中，可以实现自己的 <code>Memcached SessionDAO</code>；另外 <code>SessionDAO</code> 中可以使用 <code>Cache</code> 进行缓存，以提高性能；</li>
<li><strong>CacheManager</strong>：缓存控制器；来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能；</li>
<li><strong>Cryptography</strong>：密码模块;Shiro 提高了一些常见的加密组件用于如密码加密/解密的。</li>
</ul>
<blockquote>
<p>到此 Shiro 架构及其组件就认识完了。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Shiro </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> Shiro </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java Web路径问题解析]]></title>
      <url>/2017/11/19/Java-Web%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="基本概念的理解"><a href="#基本概念的理解" class="headerlink" title="基本概念的理解"></a>基本概念的理解</h1><ul>
<li><strong>绝对路径</strong>：绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，(URL和物理路径)，例如：<code>C:\xyz\test.txt</code>；<code>http://www.test.com/index.html</code>；</li>
<li><strong>相对路径</strong>：相对与某个基准目录的路径，例如：<code>&quot;/&quot;</code>代表Web应用的<code>根目录</code>，<code>&quot;./&quot;</code>代表<code>当前目录</code>,<code>&quot;../&quot;</code>代表<code>上级目录</code>。</li>
</ul>
<blockquote>
<p>另外关于URI，URL,URN等内容，请参考RFC相关文档标准。</p>
</blockquote>
<a id="more"></a>
<h1 id="关于JSP-Servlet中的相对路径和绝对路径"><a href="#关于JSP-Servlet中的相对路径和绝对路径" class="headerlink" title="关于JSP/Servlet中的相对路径和绝对路径"></a>关于JSP/Servlet中的相对路径和绝对路径</h1><h2 id="服务器端的地址"><a href="#服务器端的地址" class="headerlink" title="服务器端的地址"></a>服务器端的地址</h2><blockquote>
<p>服务器端的相对地址指的是相对于你的web应用的地址，这个地址是在服务器端解析的（不同于<code>html</code>和<code>javascript</code>中的相对地址，他们是由客户端浏览器解析的）；<br>在jsp和servlet中的相对地址应该是相对于你的web应用，即相对于<code>http://192.168.0.1/webapp/</code>的。</p>
</blockquote>
<p>用到的地方：  </p>
<ul>
<li><strong>forward</strong>：servlet中的request.getRequestDispatcher(address);这个address是在服务器端解析的。<br><code>request.getRequestDispatcher(“/pages/a.jsp”)</code>的绝对路径地址：<br><code>http://192.168.0.1/webapp/pages/a.jsp</code>；</li>
<li><strong>sendRedirect</strong>：在jsp中<code>&lt;%response.sendRedirect(&quot;/user/a.jsp&quot;);%&gt;</code>。</li>
</ul>
<h2 id="客户端的地址"><a href="#客户端的地址" class="headerlink" title="客户端的地址"></a>客户端的地址</h2><blockquote>
<p>所有的html页面中的相对地址都是相对于服务器根目录<code>http://192.168.0.1/</code>的，而<code>不是</code>根目录下的该Web应用的目录：<code>http://192.168.0.1/webapp/</code>。</p>
</blockquote>
<ul>
<li>HTML中的<strong>form表单的action属性</strong>的地址应该是相对于服务器根目录<code>http://192.168.0.1/</code>；如果提交到a.jsp为：<code>action＝&quot;/webapp/user/a.jsp&quot;</code>或<code>action=&quot;&lt;%=request.getContextPath()%&gt;&quot;/user/a.jsp</code>；</li>
<li><strong>Javascript</strong>也是在客户端解析的，所以其相对路径和form表单一样。</li>
</ul>
<blockquote>
<p>因此，一般情况下，在<code>JSP/HTML</code>页面等引用的<code>CSS</code>、<code>Javascript</code>、<code>Action</code>等属性前面最好都加上<code>&lt;%=request.getContextPath()%&gt;</code>,以确保所引用的文件都属于Web应用中的目录。<br>另外，应该尽量避免使用类似<code>&quot;.&quot;</code>,<code>&quot;./&quot;</code>,<code>&quot;../&quot;</code>等类似的相对该文件位置的相对路径，这样当文件移动时，很容易出问题。</p>
</blockquote>
<h2 id="站点根目录和css路径问题"><a href="#站点根目录和css路径问题" class="headerlink" title="站点根目录和css路径问题"></a>站点根目录和css路径问题</h2><blockquote>
<p>当在<code>jsp中引入css</code>时，如果其相对路径相对于当前jsp文件的，而在一个和这个jsp的<code>路径不一样的servlet中forward</code>这个jsp时，就会发现这个css样式根本没有起作用。<br>这是因为在servlet中转发时<code>css的路径</code>就是相对于这个<code>servlet的相对路径</code>，而非jsp的路径了。<br>所以这时候不能在jsp中用这样的路径：<code>&lt;link href=&quot;one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>或者<code>&lt;link href=&quot;../../one.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code>。<br>这个时候要用站点根目录，就是相对于<code>http://192.168.0.1/</code>的目录，以<code>&quot;/&quot;</code>开头。<br>因此上述错误应更正为<code>href=”/test/one.css”</code> 类似的站点根目录的相对目录。</p>
</blockquote>
<h1 id="获得JSP-Servlet中当前应用的相对路径和绝对路径"><a href="#获得JSP-Servlet中当前应用的相对路径和绝对路径" class="headerlink" title="获得JSP/Servlet中当前应用的相对路径和绝对路径"></a>获得JSP/Servlet中当前应用的相对路径和绝对路径</h1><h2 id="JSP中获得当前应用的相对路径和绝对路径"><a href="#JSP中获得当前应用的相对路径和绝对路径" class="headerlink" title="JSP中获得当前应用的相对路径和绝对路径"></a>JSP中获得当前应用的相对路径和绝对路径</h2><ul>
<li><strong>根目录</strong>所对应的绝对路径:<code>request.getRequestURI()</code>;</li>
<li><strong>文件</strong>的绝对路径:<code>application.getRealPath(request.getRequestURI())</code>;</li>
<li><strong>当前web应用</strong>的绝对路径:<code>application.getRealPath(&quot;/&quot;)</code>;</li>
<li><strong>请求文件的上层目录</strong>:<code>new File(application.getRealPath(request.getRequestURI())).getParent()</code>;</li>
</ul>
<h2 id="Servlet中获得当前应用的相对路径和绝对路径"><a href="#Servlet中获得当前应用的相对路径和绝对路径" class="headerlink" title="Servlet中获得当前应用的相对路径和绝对路径"></a>Servlet中获得当前应用的相对路径和绝对路径</h2><ul>
<li><strong>根目录</strong>所对应的绝对路径:<code>request.getServletPath()</code>;</li>
<li><strong>文件</strong>的绝对路径:<br><code>request.getSession().getServletContext().
getRealPath(request.getRequestURI())</code>;</li>
<li><strong>当前web应用</strong>的绝对路径:<code>servletConfig.getServletContext().getRealPath(&quot;/&quot;)</code>;<blockquote>
<p><strong>ServletContext对象</strong>获得几种方式：<br>javax.servlet.http.HttpSession.getServletContext();<br>javax.servlet.jsp.PageContext.getServletContext();<br>javax.servlet.ServletConfig.getServletContext(); </p>
</blockquote>
</li>
</ul>
<h1 id="JAVA的Class中获得相对路径，绝对路径"><a href="#JAVA的Class中获得相对路径，绝对路径" class="headerlink" title="JAVA的Class中获得相对路径，绝对路径"></a>JAVA的Class中获得相对路径，绝对路径</h1><h2 id="单独的Java类中获得绝对路径"><a href="#单独的Java类中获得绝对路径" class="headerlink" title="单独的Java类中获得绝对路径"></a>单独的Java类中获得绝对路径</h2><blockquote>
<p>根据<code>java.io.File</code>的Doc文挡，可知:<br> 默认情况下<code>new File(&quot;/&quot;)</code>代表的目录为：<code>System.getProperty(&quot;user.dir&quot;)</code>;<br>程序获得执行类的当前路径:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import java.io.File;</div><div class="line">public class FileTest &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;      </div><div class="line">        System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;));    </div><div class="line">        System.out.println(FileTest.class.getClassLoader().getResource(&quot;&quot;));</div><div class="line">　      System.out.println(ClassLoader.getSystemResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;&quot;));        </div><div class="line">        System.out.println(FileTest.class.getResource(&quot;/&quot;));//Class文件所在路径  </div><div class="line">        System.out.println(new File(&quot;/&quot;).getAbsolutePath());   </div><div class="line">        System.out.println(System.getProperty(&quot;user.dir&quot;));    </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务器中的Java类获得当前路径"><a href="#服务器中的Java类获得当前路径" class="headerlink" title="服务器中的Java类获得当前路径"></a>服务器中的Java类获得当前路径</h2><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3><blockquote>
<p>WebApplication的系统文件根目录是你的weblogic安装所在根目录。<br>例如：如果你的weblogic安装在<code>c:\bea\weblogic700.....</code><br>那么，你的文件根路径就是<code>c:\</code><br>所以，有两种方式能够让你访问你的服务器端的文件:  </p>
<ol>
<li>使用<strong>绝对路径</strong>：<br>比如将你的参数文件放在c:\yourconfig\yourconf.properties，直接使用<code>new FileInputStream(&quot;yourconfig/yourconf.properties&quot;)</code>;  </li>
<li>使用<strong>相对路径</strong>：<br>相对路径的根目录就是你的<code>webapplication的根路径</code>，即WEB-INF的上一级目录，将你的参数文件放在<br><code>yourwebapp\yourconfig\yourconf.properties</code>，<br>这样使用：<code>new FileInputStream(&quot;./yourconfig/yourconf.properties&quot;)</code>;</li>
</ol>
</blockquote>
<h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><blockquote>
<p>在类中输出<code>System.getProperty(&quot;user.dir&quot;);</code>显示的是<code>%Tomcat_Home%/bin</code></p>
</blockquote>
<h3 id="如何读相对路径哪"><a href="#如何读相对路径哪" class="headerlink" title="如何读相对路径哪?"></a>如何读相对路径哪?</h3><blockquote>
<p>在Java文件中<code>getResource</code>或<code>getResourceAsStream</code>均可。<br>例：<code>getClass().getResourceAsStream(filePath)</code>;filePath可以是”/filename”,这里的/代表web发布根路径下<code>WEB-INF/classes</code>。</p>
</blockquote>
<p>参考文档：<a href="http://huttoncs.iteye.com/blog/2270670" target="_blank" rel="external">java路径问题</a></p>
]]></content>
      
        <categories>
            
            <category> Java Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 路径问题 </tag>
            
            <tag> Java Web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[web编码问题详解]]></title>
      <url>/2017/11/15/web%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近搭建spring mvc项目时又再次遇到了编码问题，仔细想想，虽然以前用JSP+Servlet的时候解决了中文乱码的问题，但是都没有仔细分析过每个流程。于是今天在这里整理一下,web应用中常见的与编码相关配置：<br><a id="more"></a></p>
<h1 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h1><blockquote>
<p>首先配置好项目里的编码，这里主要有三个地方需要注意：</p>
</blockquote>
<h2 id="页面乱码"><a href="#页面乱码" class="headerlink" title="页面乱码"></a>页面乱码</h2><blockquote>
<p>页面乱码相对简单，只需要设置相关字符集编码即可。</p>
</blockquote>
<h3 id="JSP页面"><a href="#JSP页面" class="headerlink" title="JSP页面"></a>JSP页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;%@ page pageEncoding=&quot;UTF-8&quot; contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>pageEncoding：该页面编码格式；<br>charset：页面解码格式。</p>
</blockquote>
<h3 id="HTML页面"><a href="#HTML页面" class="headerlink" title="HTML页面"></a>HTML页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=Content-Type content=&quot;text/html;charset=utf-8&quot;&gt;</div></pre></td></tr></table></figure>
<h2 id="传值乱码"><a href="#传值乱码" class="headerlink" title="传值乱码"></a>传值乱码</h2><blockquote>
<p>页面到controller传值乱码需要在web.xml配置字符编码过滤器。</p>
</blockquote>
<h3 id="直接应用spring中字符编码过滤器"><a href="#直接应用spring中字符编码过滤器" class="headerlink" title="直接应用spring中字符编码过滤器"></a>直接应用spring中字符编码过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!--字符编码--&gt;</div><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</div><div class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure>
<h4 id="字符编码拦截器作用："><a href="#字符编码拦截器作用：" class="headerlink" title="字符编码拦截器作用："></a>字符编码拦截器作用：</h4><blockquote>
<p>分析源码发现作用相当于servlet中：<br>request.setCharacterEncoding(“UTF-8”);<br>response.setCharacterEncoding(“UTF-8”);</p>
</blockquote>
<h4 id="spring自带过滤器主要针对POST请求，对GET请求无效："><a href="#spring自带过滤器主要针对POST请求，对GET请求无效：" class="headerlink" title="spring自带过滤器主要针对POST请求，对GET请求无效："></a>spring自带过滤器主要针对POST请求，对GET请求无效：</h4><blockquote>
<p>对于GET请求的参数乱码，解决方法是采用数据还原：<br>String userName= request.getParameter(“userName”);<br>userName=new String(userName.getBytes(“iso8859-1”),”UTF-8”);</p>
</blockquote>
<h4 id="lt-url-pattern-gt-中匹配说明："><a href="#lt-url-pattern-gt-中匹配说明：" class="headerlink" title="&lt;url-pattern&gt;中匹配说明："></a><code>&lt;url-pattern&gt;</code>中匹配说明：</h4><blockquote>
<p><code>/</code>：不会匹配到<code>/*.jsp</code>，但会匹配<code>/login</code>等路径类型的url；<br><code>/*</code>：会匹配<code>/login</code>、<code>*.jsp</code>、<code>*.html</code>等路径；</p>
</blockquote>
<h3 id="根据源码可自己编写字符编码过滤器"><a href="#根据源码可自己编写字符编码过滤器" class="headerlink" title="根据源码可自己编写字符编码过滤器"></a>根据源码可自己编写字符编码过滤器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class CharacterEncodingFilter implements Filter &#123;</div><div class="line">    private String encoding = null;</div><div class="line">    private FilterConfig filterConfig = null;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(FilterConfig config) throws ServletException &#123;</div><div class="line">        this.filterConfig = config;</div><div class="line">        this.encoding = config.getInitParameter(&quot;encoding&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</div><div class="line">            throws ServletException, IOException &#123;</div><div class="line">        if (encoding != null) &#123;</div><div class="line">            request.setCharacterEncoding(encoding);</div><div class="line">            response.setContentType(&quot;text/html;charset=&quot; + encoding);</div><div class="line">        &#125;</div><div class="line">        chain.doFilter(request, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="存入数据库乱码"><a href="#存入数据库乱码" class="headerlink" title="存入数据库乱码"></a>存入数据库乱码</h2><blockquote>
<p>需要在数据库配置文件设置参数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">url=jdbc:mysql://gojay001.mysql.rds.aliyuncs.com:3306/trade?useUnicode=true&amp;characterEncoding=utf8</div></pre></td></tr></table></figure>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><blockquote>
<p>按照上述确认了项目内的字符编码后，在实际运行环境中可能还是会出现乱码的情况，比如发布到云服务器上。这时候就需要配置相关的环境，主要是数据库和tomcat的配置。</p>
</blockquote>
<h2 id="Tomcat配置"><a href="#Tomcat配置" class="headerlink" title="Tomcat配置"></a>Tomcat配置</h2><blockquote>
<p>在tomcat的conf/server.xml中配置Get请求默认编码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;  </div><div class="line">      connectionTimeout=&quot;20000&quot;  </div><div class="line">      redirectPort=&quot;8443&quot;   </div><div class="line">      URIEncoding=&quot;UTF-8&quot;  </div><div class="line">      useBodyEncodingForURI=&quot;true&quot;  </div><div class="line">      /&gt;</div></pre></td></tr></table></figure>
<h2 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h2><blockquote>
<p>参考：<a href="http://www.linuxidc.com/Linux/2014-10/108610.htm" target="_blank" rel="external">CentOS安装MySQL中文乱码问题解决</a><br>1、原因：安装mysql之后默认的字符编码为latin1;<br>2、查看：<code>show variables like &#39;%char%&#39;</code>;<br>3、修改为下面内容后重启mysql：<code>vi /etc/my.cf</code>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">character_set_server=utf8</div><div class="line">lower_case_table_names=1</div><div class="line">datadir=/var/lib/mysql</div><div class="line">socket=/var/lib/mysql/mysql.sock</div><div class="line">user=mysql</div><div class="line">symbolic-links=0</div><div class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</div><div class="line"> </div><div class="line">[mysqld_safe]</div><div class="line">default-character-set = utf8</div><div class="line">log-error=/var/log/mysqld.log</div><div class="line">pid-file=/var/run/mysqld/mysqld.pid</div><div class="line"></div><div class="line">[client]</div><div class="line">default-character-set = utf8</div><div class="line"></div><div class="line">[mysql.server]</div><div class="line">default-character-set = utf8</div><div class="line"></div><div class="line">[mysql]</div><div class="line">default-character-set = utf8</div></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h3 id="HTML文件仍然显示乱码："><a href="#HTML文件仍然显示乱码：" class="headerlink" title="HTML文件仍然显示乱码："></a>HTML文件仍然显示乱码：</h3><p><strong>将编码格式保存为UTF-8包含BOM</strong></p>
<blockquote>
<p>这次总结编码也就是因为遇到这个问题，一直以为是项目配置或者服务器的问题，困扰了几天后才发现这个原因。至于为什么需要带BOM，网上的评论也很多，这里也确实解决了我出现的问题。</p>
</blockquote>
<h3 id="静态资源访问："><a href="#静态资源访问：" class="headerlink" title="静态资源访问："></a>静态资源访问：</h3><p>1、在web.xml中配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!--解决静态资源访问--&gt;</div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.png&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div><div class="line"></div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>2、路径说明：<br><strong>/page/index.html</strong>:根目录下的page文件夹；<br><strong>../page/index.html</strong>:当前路径的上一级的page文件夹；<br><strong>page/index.html</strong>:当前路径的page文件夹。</p>
<blockquote>
<p>以上目前我所遇到并解决的问题，可能还有其他相关我不了解的配置，以后学习了也会继续补充上来。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> 编码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云搭建java Web环境]]></title>
      <url>/2017/11/06/%E9%98%BF%E9%87%8C%E4%BA%91%E6%90%AD%E5%BB%BAjava-Web%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><hr>
<p>最近重新在阿里云上配置了服务器和数据库，今天正好整理一下配置过程并且结合以前在CentOS下搭建java Web的流程，写在这里，以免以后忘记了不知所措。下面进入主题：<br><a id="more"></a></p>
<h1 id="二、配置阿里云"><a href="#二、配置阿里云" class="headerlink" title="二、配置阿里云"></a>二、配置阿里云</h1><hr>
<p>阿里云有学生优惠9.9一个月的云服务器，可以直接购买配置，选择CentOS。我在活动期间购买时花了9.9买了.xin域名和域名解析1年，还送了阿里云一整套6个月：服务器、数据库、OSS等等。我目前只在云服务器下搭建java Web环境并发布项目，然后连接的云数据库。服务器和数据库的配置都比较简单，阿里云上也有官方文档可以查看，按着步骤一步步配置下来就行了。</p>
<h1 id="三、工具准备"><a href="#三、工具准备" class="headerlink" title="三、工具准备"></a>三、工具准备</h1><hr>
<p>我采用的是在Windows下开发，然后将项目发布在云服务器上。所以，首先需要在Windows下准备几个工具。</p>
<h2 id="1、SecureCRT"><a href="#1、SecureCRT" class="headerlink" title="1、SecureCRT"></a>1、SecureCRT</h2><p>SecureCRT用于连接云服务器，能够在Windows下直接操作服务器。</p>
<h3 id="安装SecureCRT："><a href="#安装SecureCRT：" class="headerlink" title="安装SecureCRT："></a>安装SecureCRT：</h3><blockquote>
<p>下载SecureCRT及注册机<br>安装<br>打开注册机生成key<br>输入注册信息</p>
</blockquote>
<p>因为安装SercureCRT比较简单，这里就不过多介绍，在这里附上一个详细的<a href="http://www.cnblogs.com/qingtingzhe/articles/5008902.html" target="_blank" rel="external">安装步骤</a>。</p>
<h3 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h3><blockquote>
<p>输入ip、username、password建立session；<br>设置session选项；<code>（输出日志文件文件可以保存命令）</code><br>其他一些<a href="http://blog.csdn.net/sfslife/article/details/50923954" target="_blank" rel="external">个性化配置</a>可以参考。</p>
</blockquote>
<h2 id="2、FileZilla-FTP-Client"><a href="#2、FileZilla-FTP-Client" class="headerlink" title="2、FileZilla FTP Client"></a>2、FileZilla FTP Client</h2><p>FileZilla用于从Windows上传文件到服务器。</p>
<h3 id="下载、安装FileZilla"><a href="#下载、安装FileZilla" class="headerlink" title="下载、安装FileZilla"></a>下载、安装FileZilla</h3><p>直接官网下载安装</p>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>输入sftp://ip，username，password（端口若无修改可以不填）</p>
<h1 id="四、安装java-Web环境"><a href="#四、安装java-Web环境" class="headerlink" title="四、安装java Web环境"></a>四、安装java Web环境</h1><hr>
<h2 id="1、安装JDK并配置环境变量"><a href="#1、安装JDK并配置环境变量" class="headerlink" title="1、安装JDK并配置环境变量"></a>1、安装JDK并配置环境变量</h2><h3 id="查看当前系统是否安装过JDK："><a href="#查看当前系统是否安装过JDK：" class="headerlink" title="查看当前系统是否安装过JDK："></a>查看当前系统是否安装过JDK：</h3><p><code>rpm -qa|grep java</code>（某些系统默认安装了JDK1.7）</p>
<h3 id="如果有JDK，卸载："><a href="#如果有JDK，卸载：" class="headerlink" title="如果有JDK，卸载："></a>如果有JDK，卸载：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum -y remove java java-1.4.2-gcj-compat-1.4.2.0-4ojpp.155</div><div class="line">yum -y remove java-1.6.0-openjdk-1.6.0.0-1.7.b09.el5</div></pre></td></tr></table></figure>
<h3 id="上传并解压安装包："><a href="#上传并解压安装包：" class="headerlink" title="上传并解压安装包："></a>上传并解压安装包：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /usr/local</div><div class="line">mkdir jdk_home tomcat_home soft</div></pre></td></tr></table></figure>
<p>通过Filezilla上传tar.gz压缩包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd soft</div><div class="line">tar -xvf jdk-8u144-linux-x64.tar.gz -C /usr/local/jdk_home</div></pre></td></tr></table></figure></p>
<h3 id="配置JDK环境变量："><a href="#配置JDK环境变量：" class="headerlink" title="配置JDK环境变量："></a>配置JDK环境变量：</h3><ul>
<li>打开文件：<code>vi /etc/profile</code>  </li>
<li><p>将下列内容追加到末尾：</p>
<blockquote>
<p>#set java environment<br>  JAVA_HOME=/usr/local/jdk_home/jdk1.8<br>  CLASSPATH=.:$JAVA_HOME/lib/tools.jar<br>  PATH=$JAVA_HOME/bin:$PATH<br>  export JAVA_HOME CLASSPATH PATH  </p>
</blockquote>
</li>
<li><p>使文件生效：<code>source /etc/profile</code></p>
</li>
</ul>
<h3 id="查看java版本："><a href="#查看java版本：" class="headerlink" title="查看java版本："></a>查看java版本：</h3><p><code>java-version</code></p>
<h2 id="2、安装MySQL并配置"><a href="#2、安装MySQL并配置" class="headerlink" title="2、安装MySQL并配置"></a>2、安装MySQL并配置</h2><h3 id="mysql的安装"><a href="#mysql的安装" class="headerlink" title="mysql的安装"></a>mysql的安装</h3><blockquote>
<p>yum install mysql<br>yum install mysql-devel<br>yum install mysql-server（会出错）</p>
</blockquote>
<p><strong>CentOS 7将MySQL从默认的程序列表中移除，用mariadb代替了。</strong></p>
<h3 id="官网下载安装mysql-server"><a href="#官网下载安装mysql-server" class="headerlink" title="官网下载安装mysql-server"></a>官网下载安装mysql-server</h3><blockquote>
<p>wget <a href="http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm" target="_blank" rel="external">http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</a><br>rpm -ivh mysql-community-release-el7-5.noarch.rpm<br>yum install mysql-community-server</p>
</blockquote>
<h3 id="安装成功后重启mysql服务"><a href="#安装成功后重启mysql服务" class="headerlink" title="安装成功后重启mysql服务"></a>安装成功后重启mysql服务</h3><p><code>service mysqld restart</code></p>
<h3 id="初次安装mysql，root账号没有密码"><a href="#初次安装mysql，root账号没有密码" class="headerlink" title="初次安装mysql，root账号没有密码"></a>初次安装mysql，root账号没有密码</h3><p><code>mysql -u root</code><br>设置密码：<code>set password for &#39;root&#39;@&#39;localhost&#39; =password(&#39;root&#39;);</code></p>
<h3 id="安装完后mariadb自动被替换了，将不再生效"><a href="#安装完后mariadb自动被替换了，将不再生效" class="headerlink" title="安装完后mariadb自动被替换了，将不再生效"></a>安装完后mariadb自动被替换了，将不再生效</h3><p><code>rpm -qa |grep mariadb</code></p>
<h3 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h3><ul>
<li><p>编码：<br>打开mysql配置文件：<code>vi /etc/my.cnf</code><br>在最后追加编码配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[mysql]  </div><div class="line">default-character-set =utf8</div></pre></td></tr></table></figure>
</li>
<li><p>远程连接设置：</p>
<blockquote>
<p>把在所有数据库的所有表的所有权限赋值给位于所有IP地址的root用户：<br><code>mysql&gt; grant all privileges on *.* to root@&#39;%&#39;identified by &#39;root&#39;;</code><br>如果是新用户而不是root，则要先新建用户:<br><code>mysql&gt; create user &#39;username&#39;@&#39;%&#39; identified by &#39;password&#39;;</code></p>
</blockquote>
</li>
</ul>
<h3 id="测试mysql启动停止"><a href="#测试mysql启动停止" class="headerlink" title="测试mysql启动停止"></a>测试mysql启动停止</h3><p><code>service mysqld start/stop</code></p>
<p><code>mysql的安装就到这里了，附上一个[详细说明](http://www.cnblogs.com/starof/p/4680083.html)。</code></p>
<h2 id="3、安装Tomcat并配置"><a href="#3、安装Tomcat并配置" class="headerlink" title="3、安装Tomcat并配置"></a>3、安装Tomcat并配置</h2><h3 id="解析Tomact"><a href="#解析Tomact" class="headerlink" title="解析Tomact"></a>解析Tomact</h3><blockquote>
<p>解压：tar -xvf apache-tomcat-9.0.0.M26.tar.gz -C /usr/local/tomcat_home；<br>重命名：mv apache-tomcat-9.0…. tomcat9</p>
</blockquote>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><blockquote>
<p><code>vi /etc/profile</code><br>在文件最后追加配置：<br> #tomcat evn<br> CATALINA_HOME=/usr/local/tomcat_home/tomcat9<br> export CATALINA_HOME</p>
</blockquote>
<h3 id="配置tomcat的catalina-sh文件"><a href="#配置tomcat的catalina-sh文件" class="headerlink" title="配置tomcat的catalina.sh文件"></a>配置tomcat的catalina.sh文件</h3><blockquote>
<p>cd $CATALINA_HOME/bin<br>vi catalina.sh<br>找到 # OS specific support，然后在这行下面添加以下配置：<br>CATALINA_HOME=/usr/local/tomcat_home/tomcat9<br>JAVA_HOME=/usr/local/jdk_home/jdk1.8</p>
</blockquote>
<h3 id="安装tomcat服务"><a href="#安装tomcat服务" class="headerlink" title="安装tomcat服务"></a>安装tomcat服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd $CATALINA_HOME/bin</div><div class="line">cp catalina.sh /etc/init.d/tomcat</div></pre></td></tr></table></figure>
<h3 id="测试tomcat的启动和停用"><a href="#测试tomcat的启动和停用" class="headerlink" title="测试tomcat的启动和停用"></a>测试tomcat的启动和停用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">service tomcat start</div><div class="line">service tomcat stop</div></pre></td></tr></table></figure>
<h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a><a href="http://blog.csdn.net/u011846257/article/details/54707864" target="_blank" rel="external">防火墙配置</a></h3><p><code>到这里Tomcat环境就已经搭建完成了，附上[参考文档](http://www.jianshu.com/p/b71296e8b9a7)。</code></p>
<h1 id="五、更多配置"><a href="#五、更多配置" class="headerlink" title="五、更多配置"></a>五、更多配置</h1><hr>
<p>这里只是简单地在阿里云的云服务器上搭建了java Web环境，其他的一些配置就需要以后有需求或者遇到困难的时候解决。</p>
]]></content>
      
        <categories>
            
            <category> Java Web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java Web </tag>
            
            <tag> 阿里云 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown基本语法]]></title>
      <url>/2017/10/30/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h1><ol>
<li>在HTML区块标签间的Markdown格式语法将不会被处理。</li>
<li><code>&lt;</code> 和 <code>&amp;</code> 特殊字符自动转换。</li>
<li>段落由一个或多个连续的文本行组成，它的前后要有一个以上的空行。  （空行的定义是显示上看起来像是空的，便会被视为空行）</li>
<li>两个以上的空格可实现 <code>&lt;br\&gt;</code> 标签。  <a id="more"></a>  
</li>
</ol>
<h1 id="二、区块元素"><a href="#二、区块元素" class="headerlink" title="二、区块元素"></a>二、区块元素</h1><h2 id="（一）标题设置"><a href="#（一）标题设置" class="headerlink" title="（一）标题设置"></a>（一）标题设置</h2><ol>
<li>效果：让字体变大，和word的标题意思一样。</li>
<li>在Markdown当中设置标题，有<strong>两种方式</strong>：<br>-在文字下方添加 <code>=</code> 和 <code>-</code> ，他们分别表示一级标题和二级标题。<br>-在文字开头加上 <code>#</code>，通过 <code>#</code> 数量表示几级标题。  （一共只有1-6级标题，1级标题字体最大） </li>
</ol>
<h2 id="（二）区块引用"><a href="#（二）区块引用" class="headerlink" title="（二）区块引用"></a>（二）区块引用</h2><ol>
<li>先断好行，然后在<strong>每行（或第一行）</strong>的最前面加上 <code>&gt;</code> 。</li>
<li>区块引用可以嵌套。</li>
</ol>
<h2 id="（三）列表"><a href="#（三）列表" class="headerlink" title="（三）列表"></a>（三）列表</h2><ol>
<li><strong>无序列表</strong>：<br>在文字开头添加(*,+,-)实现无序列表。（和文字之间添加空格）</li>
<li><strong>有序列表</strong>：<br>使用数字后面跟上句号。（和文字之间添加空格）  </li>
</ol>
<h2 id="（四）分割线"><a href="#（四）分割线" class="headerlink" title="（四）分割线"></a>（四）分割线</h2><ol>
<li>在空白行下方添加 <code>---</code> 横线。</li>
</ol>
<h1 id="三、区段元素"><a href="#三、区段元素" class="headerlink" title="三、区段元素"></a>三、区段元素</h1><h2 id="（一）链接"><a href="#（一）链接" class="headerlink" title="（一）链接"></a>（一）链接</h2><p>Markdown中有两种方式实现链接，分别为<strong>内联方式</strong>和<strong>引用方式</strong>。  </p>
<ol>
<li>内联方式：<br><code>This is an [example link](http://example.com/).</code>  </li>
<li>引用方式：<br><code>I get from [Google][1] than from [Yahoo][2] or [MSN][3].</code><br><code>[1]: http://google.com/        &quot;Google&quot;</code><br><code>[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</code><br><code>[3]: http://search.msn.com/    &quot;MSN Search&quot;</code>  </li>
</ol>
<h2 id="（二）强调"><a href="#（二）强调" class="headerlink" title="（二）强调"></a>（二）强调</h2><ol>
<li><em>斜体</em>：文字两端使用1个“*”或者“_”夹起来。</li>
<li><strong>粗体</strong>：文字两端使用2个“*”或者“_”夹起来。  </li>
</ol>
<h2 id="（三）代码"><a href="#（三）代码" class="headerlink" title="（三）代码"></a>（三）代码</h2><p>实现方式有两种：  </p>
<ol>
<li>简单文字出现一个代码框。使用<code>&lt;blockquote&gt;</code>。（<code>不是单引号而是左上角的ESC下面~中的</code>）  </li>
<li>大片文字需要实现代码框。使用Tab或四个空格。  </li>
</ol>
<h2 id="（四）图片"><a href="#（四）图片" class="headerlink" title="（四）图片"></a>（四）图片</h2><ol>
<li>内联方式：<br><code>![alt text](/path/to/img.jpg &quot;Title&quot;)</code></li>
<li>引用方式：<br><code>![alt text][id]</code><br><code>[id]: /path/to/img.jpg &quot;Title&quot;</code></li>
</ol>
<h1 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h1><h2 id="（一）表格"><a href="#（一）表格" class="headerlink" title="（一）表格"></a>（一）表格</h2><ol>
<li>用|表示表格纵向边界，表头和表内容用-隔开。</li>
<li>—-:为右对齐  :—-为左对齐  :—:居中对齐  —–默认左对齐。  </li>
</ol>
<h2 id="（二）删除线"><a href="#（二）删除线" class="headerlink" title="（二）删除线"></a>（二）删除线</h2><ol>
<li>使用<code>~~</code>表示删除线。</li>
<li><code>注意</code>：~~和被删除的文字之间不能有空格。  </li>
</ol>
<h2 id="（三）脚注（之间必须空一行）"><a href="#（三）脚注（之间必须空一行）" class="headerlink" title="（三）脚注（之间必须空一行）"></a>（三）脚注（之间必须空一行）</h2><p><code>hello[^hello]</code><br><code>[^hello]: hi</code></p>
]]></content>
      
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
